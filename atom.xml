<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Weyoung&#39;s Blog</title>
  
  <subtitle>Nothing can prevent is going to be</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://talentprince.github.io/"/>
  <updated>2020-06-23T00:24:21.407Z</updated>
  <id>http://talentprince.github.io/</id>
  
  <author>
    <name>Prince Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Refresh Java</title>
    <link href="http://talentprince.github.io/2020/06/02/Refresh-Java/"/>
    <id>http://talentprince.github.io/2020/06/02/Refresh-Java/</id>
    <published>2020-06-02T09:54:52.000Z</published>
    <updated>2020-06-23T00:24:21.407Z</updated>
    
    <content type="html"><![CDATA[<p>当你的知识来源于实践, 你可能会忽略很多细节.<br>当你的知识来源于阅读, 你可能会很快的忘掉.</p><p>那么, 不如在空闲之余, 浏览一遍, 把觉得有必要的记录下来, 也便于以后温故而知新, 何乐而不为呢?<br>于是便有了这138条从Thinking In Java中记下来的条目.<br>这本书不同于其他的Java教材, 它的作者更喜欢通过与C++进行对比来阐述Java的不同思想, 如果读者有一定C++知识储备, 会更好的理解Java的很多设计.</p><a id="more"></a><ul><li><code>&gt;&gt;&gt;</code>无符号移位</li><li><code>for(1 : range(10))</code>可实现计数器循环foreach</li><li><code>printnb</code>不会换行放在缓冲区, <code>print()</code>将其输出</li><li>带标签的<code>break</code>与<code>continue</code>可以跳出嵌套循环</li><li>构造调用<code>this(xxx)</code>只能调用一次,并且在最开始</li><li>Java的<code>finalize</code>是在垃圾回收时候调用的, 一般是配合释放ndk相关的底层空间</li><li>静态对象只有在所属类被实创建时才会被加载</li><li>构造方法其实也是静态方法</li><li><code>int[] a</code>与<code>int a[]</code>都可以,  前一种更合理, 后一种像C++</li><li>数组初始化花括号最后一个逗号可选, 即<code>{x,y,z,}</code></li><li>没有写<code>package</code>的类默认属于目录所在包</li><li>即时类不是<code>public</code>, 但是<code>main</code>方法依旧可以被调用</li><li>子类调用父类方法, 父类再调用<code>public</code>方法则可能会调用到子类所继承的方法(如果覆盖的话), 如果该方法在父类是<code>private</code>, 则只会调用父类方法, 因为不能覆盖, C++如果不是虚函数, 则只会调用父类的, 因为<code>this</code>内函数地址编译时就确定了</li><li><code>Java</code>函数没有隐藏/屏蔽特性, <code>C++</code>子类会同名函数会隐藏/屏蔽掉父类所有同名重载函数, 因为它会先查找函数名, 再找具体类型.</li><li>早起<code>JVM</code>会根据<code>final</code>类型来内联函数, 现在已经有更先进的技术了, 只为了禁止覆盖.</li><li>覆盖<code>private final</code>其实是假象而已</li><li>面向对象特性, 抽象, 继承, 多态</li><li><code>Java</code>除了<code>static</code>与<code>final</code>外函数都是后期绑定的, 即动态绑定</li><li><code>Java</code>构建子类时父类构造函数调用已被覆盖的函数会触发动态绑定, 但此时子类未完成构造, 所以类内对象都为空值. <code>C++</code>在处理同样问题时更加合理, 由于虚表指针未完整建立, 所以不会触发动态绑定, 无论是构造还是析构函数, 都是直接调用而非虚调用, 为了避免问题, 尽量不要在构造函数内调用可被覆盖的函数, 可以调用<code>final</code>函数来防止出错</li><li>Java5加入被覆盖方法返回参数协变(向下转型)</li><li>interface中定义的所有常量都是自动static fianl的</li><li>类内部定义的private接口可以进行内部public的实现, 但在外部无法看出任何有关私有接口的类型信息, 即不可向上转型</li><li>嵌套在接口内的接口自动public</li><li>private接口不能在定义它的类之外被实现</li><li>内部类持有的外部类对象学术名叫Enclosing Object(外围对象)</li><li>创建非静态内部类必须通过<code>.new</code>来创建, 即使用外部对象来创建内部对象</li><li>private内部类可以帮助隐藏具体实现, 外部类可以提供其实例的向上转型</li><li>内部类还可以放在方法里缩小scope, 作用于与局部变量一样</li><li>匿名内部类没有命名构造器, 只有实例初始化传参, 或者通过final形参直接在内部使用</li><li>static内部类叫作嵌套类, 它不持有外围对象</li><li>接口内部可以放嵌套类, 可以这么搞个测试在里面</li><li>内部类更重要的作用是有效的实现了<code>多重继承</code>, 比如需要继承多个抽象类而不是接口</li><li>Java使用内部类实例做回调来实现闭包功能</li><li>Java通过接口+内部类可以结果C++多重继承所能解决的问题</li><li>List/Set/Queue都继承Collection, Map独立有接口, 两者唯一的关系是Map提供一个返回Collection的entrySet与values</li><li>Queue虽然继承于Collection, 但Queue有自己独立的接口, 创建Queue不需要Collection的方法</li><li>LinkedList也继承于Dequeue</li><li>当我们在异常处理的终止与恢复中选择时, 开始往往是恢复, 最后趋向终止</li><li>对自定义异常的扩展可能没太大用, 因为更多的时候只关注异常类型</li><li>重新抛异常会保留之前的信息, 不会新加入抛出点的信息, 除非调用fillInStackTrace()</li><li>重新抛出新的异常则会清楚之前的信息</li><li>Finally用来清理，C++靠的是析构函数</li><li>即便有break，continue，return，finally始终都会被执行</li><li>Finally中return会吃掉try内的异常</li><li>Finally中抛异常会吃掉try内的异常</li><li>基类构造抛出异常不用在子类限制必须抛出， 因为基类构造必须调用， 并且需要处理</li><li>子类方法不能抛出基类未声明过的异常，这样直接调用基类接口不用处理，实际运行可能会出错</li><li>子类方法可以抛出基类声明异常的子类异常</li><li>对于构造需要清理的对象，如文件，应该将构造失败单独try/catch，而close方法放在内部的try/catch只对创建成功后进行清理</li><li>字符串正则表达式查找find匹配任意位置，lookingAt只从开头匹配， matches匹配全部</li><li>正则Pattern可以用<code>|</code>与操作进行组合</li><li>Java默认类型转换会RTTI，但是C++不会</li><li>setAccessable只是控制是否安全检测，public默认仍是false，关闭后速度快</li><li>泛型会被擦除， ArrayList<integer>跟ArrayList<string>一样，通过getTypeParameters()也只能得到占位符</string></integer></li><li>C++泛型不会擦除， 所以编译的时候仍然可以获得具体使用类型，所以定义时泛型对象就可以调用实际类型的方法，Java得通过泛型extends来实现</li><li>擦除主要是为了兼容低版本</li><li>C++可以直接new T()而Java只能通过泛型当参数newInstance，对于没有默认构造的Java可以传入泛型工场进行构造</li><li>泛型可以通过extends来限制边界, 并且可以通过<code>&amp;</code>增加多个边界, 类应该放在接口的前面</li><li><code>Clazz&lt;Apple&gt;</code>只能向上转型为<code>Clazz&lt;? extends Fruit&gt;</code>, 而不能<code>Clazz&lt;Fruit&gt;</code>, <code>Clazz&lt;Food&gt;</code>可以向下转型为<code>Clazz&lt;? super Fruit&gt;</code></li><li><code>&lt;? extends X&gt;</code>指定上界, 无法进行add操作, 因为它是由子类List向上转型来的, 子类多种多样不确定, 所以不让你放, 而get返回<code>X</code>, <code>&lt;? super X&gt;</code>指定下届, 是由父类List向下转型来的, 可以add <code>X</code>的子类, 内部可安全强转为同一个父类(X的某个父类), 但get就不清楚是哪个父类, 所以只能拿到<code>Object</code></li><li>类不能实现泛型接口的两种变体</li><li>自限定泛型继承, <code>class SelfBounded&lt;T extends SelfBounded&lt;T&gt;&gt;</code>, 任何继承SelfBounded类的泛型类型必须也是SelfBounded的导出类</li><li>继承自限定类可保证接口函数导入类唯一, 参数为限定类泛型指定</li><li>C++可以通过<code>template&lt;class T&gt; : T</code>来进行混型, 有一些AOP方面的思想</li><li>Java可以通过继承多个接口, 并分别初始化的时候进行实现, 然后再代理进行混型</li><li>Java也可以通过装饰器进行混型的概念, 但是由于装饰器其实只有最后一层是暴露的, 失去了内部各层的特性, 而混型是基于继承, 保留所有特性</li><li>Java还可以通过动态代理, 将所有需要混型的实现与接口导入, 在invoke的时候查表得到对应的Delegate来调用方法, 实现混型, 但是不方便, 也不易懂, 不如C++静态的好</li><li>对于一些脚本语言, 类型检测是在运行期, 所以可以使用潜在类型机制, 进行代码复用, 如Python, 只需要方法名一样, 或者称为鸭子类型机制, 只要走起来像鸭子, 叫起来像鸭子, 就当做鸭子…</li><li>由于C++的泛型在编译器可以检测T支持的方法, 可以直接对泛型类型调用相应函数,  也可以做到类似Python的效果. 表面上看C++的泛型成了弱类型, 但实际上是安全的, 称之为具有通气门的强类型</li><li>Java的泛型出现的晚, 已经不具备这种潜在类型机制了, 可以认为比他们更缺乏泛化性</li><li>Java虽然不能潜在类型, 但可以通过泛型, 一定程度补偿了这样的灵活性</li><li>虽然Java的Map有泛型, 但是<code>containsKey</code>, <code>get</code>之类的方法不受泛型约束, 而C++的Map是会在编译器检查类型的. 主要原因是泛型对于Java是后来引入的, 而对于C++在最初的标准版本里就引入了</li><li><code>Arrays.deepToString()</code>可以给数组填充初始默认值</li><li><code>Arrays.fill()</code>可以给数组填充指定值</li><li>无法创建泛型数组, 但是类型可以被赋值</li><li><code>Array.newInstance</code>用反射的Array可以生成任意类型, 指定大小的数组</li><li><code>System.arraycopy</code>可以实现高效的数组内存拷贝</li><li>自己实现Collection不一定需要支持所有的操作, 虽然平时用的List, Map, Set都实现了</li><li><code>Arrays.asList()</code>生成的是固定大小数组, 不支持改变大小的操作, 使用会抛异常</li><li><code>LinkedList</code>实现了<code>Queue</code>接口, 但是Java没有<code>Dequeue</code>接口, 不过它已经实现了所需方法<code>getLast</code>, 所以可以自己包装 </li><li><code>TreeMap</code>是唯一带<code>subMap</code>的Map, 返回一个子树, 它是<code>SortedMap</code>的唯一实现</li><li><code>LinkedHashMap</code>的散列是一个LRU, 没有被使用的数据放在前面</li><li>通过<code>Collection.synchronized</code>可以创建不同的线程同步子类</li><li><code>SoftReference</code>跟<code>WeakReference</code>都可以单独使用, 而<code>PhantomReference</code>必须跟<code>ReferenceQueue</code>一起使用</li><li>普通对象被gc后会进入<code>Finalizable</code>状态, finalize未被调用,  仍就可以有机会复生 (复写finalize), 当finalize调用后,  会进入<code>Finalized</code>状态, 下次GC会被回收</li><li><code>PhantomReference</code>天生就是finalized状态, GC发生后就清掉了</li><li><code>Stack</code>,<code>Vector</code>都是1.0/1.1版本的东西, 为了兼容性而保留了</li><li>1.4之后引入了<code>nio</code>相较于之前的被称之为新IO</li><li>1.1加入的Reader跟Writer是为了国际化兼容16位Unicode字符</li><li><code>BufferedInputFile.read</code>可以读取文件到Reader里, 在进行其他的包装, 如<code>StringReader</code>, <code>BufferedReader</code>, 没有快捷方式.</li><li>写入文本可以使用<code>PrinterWriter</code>简化, 直接<code>writer.println</code></li><li><code>System.out/in/err</code>被称为标准IO, 通过<code>setOut/In/Err</code>可以进行重定向</li><li><code>javap</code>随jdk一起发布做反编译</li><li>旧IO底层已经用nio重构过了</li><li>旧的<code>FileInputStream</code>, <code>FileOutputStream</code>等被修改支持生成一个<code>Channel</code>, Writer跟Reader不支持, 但是Channel有方法可以生成他们</li><li>Channel通过<code>ByteBuffer</code>进行读写, 写之前需要<code>flip</code>准备缓冲区, 读之前需要<code>rewind</code>回到数据头,  再通过<code>asCharBuffer</code>转换后打印</li><li><code>ByteBuffer.flip</code>是将position设置为0, 将limit设置为当前位置, 准备写;  <code>ByteBuffer.rewind</code>是将position设置为0, 并将marker清除, 准备读; <code>mark</code>会设置mark, <code>reset</code>会把position指向mark</li><li>通过ByteBuffer的<code>asCharBuffer</code>或者别的方法, 可以获得所谓缓冲器视图, 对缓冲器进行对应类型的<code>put</code>, 该缓冲器可通过其他as方法切换至其他的窗口进行输出</li><li>如果直接向缓冲器内写入Bytes, 那么无法通过<code>asCharBuffer</code>读出, 必须写入<code>UTF-16BE</code>才对应格式, 按Char读出不会乱码</li><li>通过<code>RandomAccesFile.map</code>可以产生<code>MappedByteBuffer</code>进行内存磁盘映射, 必须指定一个映射范围, 它的效率要比建立在nio之上的旧IO要快</li><li>Object序列化的文件, 必须能在找到类定义的环境下才能被反序列化成功, 否则会ClassNotFoundException</li><li>通过Serializable序列化, 内部有大量反射, 直接将二进制赋值,  不需要通过构造. 如果复写read/writeObject, 或者实现<code>Externalizable</code>接口, 自己实现序列化, 则需要有public默认构造, 没有反射, 效率高</li><li>静态成员变量不能自己序列化</li><li>枚举在编译的时候编译器会给加入<code>values</code>跟单参的<code>valueOf</code>静态方法</li><li>所以枚举向上转型Enum就没有values方法了, 但可以通过Class中<code>getEnumConstant</code>方法反射</li><li>构建枚举的枚举可以通过将枚举Class当构造参数传入枚举对象, 并且通过<code>geEnumConstant</code>覆盖其values</li><li><code>EnumSet.allOf</code>可以传入一个枚举类class, <code>of</code>则是手动传入N个枚举类型</li><li>枚举可以添加自定义方法, 每一个实例独自实现,  但是枚举实例不能像普通类一样作函数参数, 因为每一个实例其实是enum类型本身</li><li>注解不能继承, 注解的字段要么定义默认值, 要么使用时传入, 不能为空</li><li>线程设置为Deamon模式, 主线程结束后就被杀掉了</li><li>Thread可以设置<code>setDefaultUncaughtExceptionHandler</code>, 不设置就会被default处理</li><li>测试资源竞争可以调用<code>Thread.yield</code>增加几率</li><li>Java也提供手动的<code>Lock</code>, return要写在try里确保在finally的unlock之前调用</li><li>如果想实现尝试获取, 不行放弃的话, 需要自己封装<code>ReentrantLock</code>, 使用<code>tryLock</code></li><li>多核处理器上可视性比原子性问题多得多, volatile会解决可视性问题</li><li>volatile如果已经被synchronized防护, 则不需要加; 如果只在一个任务中用, 也不用加; 如果依赖前值, 或者某个域的值, 那也无法工作</li><li>在C++中自加可能是原子性的, 但是Java中肯定不是</li><li><code>synchronized</code>最合理的是锁被调用对象this, 或者加方法上, 这样如果一个线程获得了锁, 其他synchronized的方法也都不能被别的线程调用了</li><li>IO与Synchronized的阻塞无法被打断, 关闭资源才可以释放锁, 并打断线程, 锁阻塞续采用<code>Lock.lockInterruptibly</code>才可以被打断</li><li>线程被中断一般需要有清理逻辑, 通过try/catch/fanilly来做</li><li><code>sleep()</code>, <code>yield()</code>不会释放锁, <code>wait()</code>期间对象锁会释放, 被notify后, 醒之前必须重新获得锁</li><li><code>wait</code>一般跟while循环配合, 因为在即将被唤起之前(调用notify的前后), 可能条件已经发生了改变</li><li>为了防止错过信号, 通常也需要通过while(cindition)来保护wait, 防止死锁</li><li>因为wait会释放锁, 而notify在synchronized区间内, 会在之前获取锁, 而wait被唤醒又会重新获取锁,  所以实际上使用notifyAll也只能唤起在等待的一个任务, 同样, 使用notify的时候, 应使等待条件一致, 如果条件不一致, 则只能使用notifyAll</li><li>可以synchronized锁Object以及wait/notify做同步, 也可以通过<code>ReentrantLock</code>生成condition, 通过await/signal/lock/unlock来操控</li><li>有时候使用一些同步对象也可以简化逻辑, 如<code>BlockingQueue</code></li><li>简单的线程同步也ke已用1.5引入的<code>CountDownLatch</code>做</li><li>相较于CountDown只能计数一边, <code>CyclicBarrier</code>可以重复利用, 第一个参数传入parties个数, 当await数量达到时会停止等待, 并且调用第二个参数Runnable执行, 可以再次触发await, 这样可以形成一个循环, 或者闭环</li><li>除了<code>BlockingQueue</code>之外, 还有其他类似的同步队列, 但需要实现一定的接口, 如<code>DelayBlockingQueue</code>, <code>PriorityBlockingQueue</code></li><li><code>SynchronousQueue</code>的put必须等待take</li><li>常用的Excutor有<code>CachedThreadPool</code>, <code>ScheduledThreadPool</code>, <code>FixedThreadPool</code>等</li><li><code>Semaphore</code>作为信号量, 可以设置次数, 多次acquire, 并通过release来释放信号, 区别于<code>ReentrantLock</code></li><li><code>Exchanger</code>可以作为一个类似管道的东西, 同时传递生产到消费</li><li>一般使用synchronized, 可读性强, 调优用Lock, 简单情况用Atomic, 有性能指标可以替换</li><li><code>CopyOnWriteArrayList</code>内部使用整个数组的副本进行操作, 最终原子替换, 性能高一些, <code>ConcurrentHashMap</code>与<code>ConcurrentLinkededQueue</code>类似, 只不过是部分复制再操作. 这两者读取过程都有乐观锁处理, 所以性能要比synchronized List/Map好, 尤其是在很少写入的情况</li><li>AtomicXXX有一些乐观加锁的函数, 如compareAndSet, 当提供的oldValue发生变化时, set失败</li><li>读写锁(ReentrantReadWriteLock)保证了读取数据的一致性, 当写锁被持有的时候, 读锁将不能获取, 其他时候可多次获取读锁</li><li>更多的时候多线程的问题要通过Task+消息队列, 但这个依赖于平台或者额外复杂的设计</li></ul>]]></content>
    
    <summary type="html">
    
      Thinking in Java
    
    </summary>
    
      <category term="Java" scheme="http://talentprince.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://talentprince.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Refresh design pattern</title>
    <link href="http://talentprince.github.io/2019/09/30/Refresh-design-pattern/"/>
    <id>http://talentprince.github.io/2019/09/30/Refresh-design-pattern/</id>
    <published>2019-09-30T08:06:52.000Z</published>
    <updated>2020-06-22T09:53:06.843Z</updated>
    
    <content type="html"><![CDATA[<p>多年后, 再次翻阅设计模式书籍, 将每种模式的要点总结于此, 需要本身有一定设计模式基础, 再结合要点, 帮助更好理解与运用.</p><a id="more"></a><ul><li><p>策略模式 (Strategy)</p><ul><li>附加功能单独抽象不同接口</li><li>功能以组合方式引入抽象类</li><li>抽象类封装功能模块各调用</li><li>实现类可在构造中配置功能具体实现</li></ul></li><li><p>观察者模式 (Observer)</p><ul><li>被订阅者持有所有订阅者</li><li>数据更新可以直接推送</li><li>数据更新也可以通知加拉取</li><li>大程度解耦观察者与被订阅者</li></ul></li><li><p>装饰器模式 (Decorator)</p><ul><li>装饰器接口的简单实现叫做组件</li><li>持有组件对象的叫做装饰器</li><li>装饰是从里层的装饰器开始</li><li>最里层的装饰器会持有原始组件</li><li>各层通过对持有的底层对象进行包装完成所谓装饰并返回给上层</li><li>理论上可以做到一层套一层无穷尽</li></ul></li><li><p>工场方法模式 (Factory Method)</p><ul><li>解耦产品的实现与使用</li><li>产品需要进行抽象</li><li>工场方法定义创建产品的接口</li><li>工场方法内还可以封装使用过程</li><li>子工场配置自己的创建逻辑</li><li>工场方法常常与抽象工场结合</li><li>抽象工场定义了一组产品的创建</li><li>工厂方法的实现又用这些产品创建或组件具体的大产品</li><li>工厂方法通过继承来实现</li><li>抽象工场通过组合来实现(传入)</li></ul></li><li><p>单例模式 (Singleton)</p><ul><li>全局实例注意内存</li><li>多线程需要特殊照顾</li></ul></li><li><p>命令模式 (Command)</p><ul><li>解耦发请求者与执行请求者</li><li>命令内部可以直接执行也可以代理给被封装在内的接收者</li><li>命令支持撤销</li><li>宏命令包含多个命令同时调用</li></ul></li><li><p>适配器模式 (Adapter)</p><ul><li>对象适配器以组合来实现</li><li>类适配器以多继承来实现</li><li>新旧系统共用可双向适配</li></ul></li><li><p>外观模式 (Facade)</p><ul><li>从抽象层次看与适配器很像</li><li>外观模式创建新的简单接口</li><li>适配器模式使用已存在接口</li><li>新接口包装多个系统模块简化调用</li><li>老接口包装其他系统达到兼容</li></ul></li><li><p>模板方法模式 (Template Method)</p><ul><li>模板实现算法, 子类实现步骤</li><li>子类与父类尽量不能成环</li><li>好莱坞模式为子类全为回调方法</li><li>有默认实现的为钩子方法</li><li>策略用组合封装算法,模板用继承封装算法</li><li>工厂方法是特殊的模板方法</li></ul></li><li><p>迭代器模式 (Iterator)</p><ul><li>解耦游走数组而不要关心具体类型</li><li>集合类都有自己的迭代器</li><li>一般的迭代器具备hasNext与next两个方法</li><li>聚合器持有数据并创建迭代器</li></ul></li><li><p>组合模式 (Composite)</p><ul><li>组合模式的节点分为子节点与叶节点</li><li>子与叶都实现了同样的组合接口,所谓透明性</li><li>子节点会额外实现add与get</li><li>为了叶节点安全也可以具有不同接口</li><li>组合模式可以与迭代器共生</li><li>迭代器需要配合栈来实现树的遍历</li><li>子节点可以实现空迭代器来减少Null判断</li></ul></li><li><p>状态模式 (State)</p><ul><li>与策略模式类图相似</li><li>状态接口定义状态切换行为</li><li>所有状态实现统一接口</li><li>状态机定义并持有所有状态</li><li>状态机储存当前状态</li><li>状态切换由不同状态自己控制</li><li>状态内通过持有的状态机来切换下一状态</li></ul></li><li><p>代理模式 (Proxy)</p><ul><li>可分为远程代理与虚拟代理</li><li>与装饰者很像</li><li>代理更多的是控制真实对象的访问, 解耦客户与真实对象, 也可能帮助创建真实对象</li><li>装饰器更多是增加行为, 而且不创建对象</li><li>可通过工厂方法返回主体的代理</li><li>与适配器很像</li><li>代理不改变接口, 适配器改变接口</li><li>保护代理可以限制访问部分接口,更像适配器</li></ul></li><li><p>复合模式 (Compound)</p><ul><li>多用几种</li><li>比如MVC就融合了策略,组合,适配器等</li></ul></li></ul><hr><ul><li><p>一些冷门模式</p></li><li><p>桥接模式 (Bridge)</p><ul><li>与策略模式很像</li><li>主体都依赖于功能组件的抽象</li><li>策略模式的主体是具体算法的实现</li><li>桥接模式的主更抽象,需要子类来实现不同算法</li><li>可以做到主体和功能组件解耦</li><li>增加了复杂度</li></ul></li><li><p>生成器 (Builder)</p><ul><li>封装复杂对象的创建过程</li><li>隐藏内部实现</li><li>创建时需要对所创对象有更多认识</li></ul></li><li><p>责任链 (Resposibility)</p><ul><li>简单理解为一个Handler的对象链</li><li>比如很多程序里常用的Dispatcher链</li><li>或者很多系统启动时需要加载的数据链</li><li>不能保证一定会有对象对数据进行处理</li></ul></li><li><p>享元 (Flyweight)</p><ul><li>多个同样的实例可被一个方法控制, 就可以封装在一起轮询数组进行处理</li><li>但是不能有独立不同行为了</li></ul></li><li><p>解释器 (Intepretor)</p><ul><li>主要是做简单固定语法解析</li><li>抽象解释接口, 并实现多个解释器</li><li>如And, Or之类的, 可相互嵌套.</li><li>如果语法复杂, 种类繁多, 会不太适合</li></ul></li><li><p>中介者 (Mediator)</p><ul><li>解耦不同对象</li><li>它们只需要通知中介者, 中介者根据不同状态来控制整个逻辑</li><li>可能会让中介者逻辑过于复杂</li></ul></li><li><p>备忘录 (Momento)</p><ul><li>将对象的储存抽出来, 更好的维护了业务的内聚</li><li>一般会提供储存与获取接口</li><li>储存过程可能会耗时</li><li>可能需要考虑序列化</li></ul></li><li><p>原型 (Prototype)</p><ul><li>提供复制对象的方法</li><li>比如clone</li><li>如果对象层次深,复制起来可能复杂</li></ul></li><li><p>访问者 (Visitor)</p><ul><li>解耦对象与每个对象的具体操作, 如对电脑的不同部件进行不同操作</li><li>在对象种类变化小而操作变化大的时候使用</li><li>每一个对象实现visitor接口, 接受(accept)一个visitor,并把自己传给visitor (visit)</li><li>缺点是具体元素对访问者暴露, 而不是抽象接口</li></ul></li></ul><hr><p>有很多种分类方式, 不必拘泥, 也可忽略.</p><ul><li><p>分类方式 I</p><ul><li>创建型<ul><li>单例</li><li>抽象工厂</li><li>工厂方法</li><li>生成器</li><li>原型</li></ul></li><li>行为型<ul><li>模板方法</li><li>迭代器</li><li>状态</li><li>策略</li><li>观察者</li><li>命令</li><li>解释器</li><li>中介者</li><li>访问者</li><li>备忘录</li><li>责任链</li></ul></li><li>结构型<ul><li>装饰器</li><li>代理</li><li>外观</li><li>组合</li><li>适配器</li><li>桥接</li><li>享元</li></ul></li></ul></li><li><p>分类方式 II</p><ul><li>类<ul><li>模板方法</li><li>工厂方法</li><li>适配器</li><li>解释器</li></ul></li><li>对象<ul><li>单例</li><li>抽象工厂</li><li>装饰器</li><li>代理</li><li>外观</li><li>组合</li><li>适配器</li><li>迭代器</li><li>状态</li><li>策略</li><li>观察者</li><li>命令</li><li>桥接</li><li>享元</li><li>生成器</li><li>中介者</li><li>访问者</li><li>备忘录</li><li>责任链</li><li>原型 </li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      Design Pattern
    
    </summary>
    
      <category term="Design Pattern" scheme="http://talentprince.github.io/categories/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="http://talentprince.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Chernobyl, 切尔诺贝利, 車諾比</title>
    <link href="http://talentprince.github.io/2019/07/09/Chernobyl/"/>
    <id>http://talentprince.github.io/2019/07/09/Chernobyl/</id>
    <published>2019-07-09T08:06:52.000Z</published>
    <updated>2020-06-22T09:44:59.476Z</updated>
    
    <content type="html"><![CDATA[<p>虽然八季的权游的草草收尾让HBO被骂了个惨, 但是后续推出的Mini剧<code>切尔诺贝利</code>却以9.6的高分一绝红尘, 让大家对于人类历史上最大的核灾难有了形象生动的认识. <code>谎言的代价</code>, 一开始的旁白便以此为切入, 展开了整部剧的画面.</p><p>趁着热度, 我并没有先看这部西方指导的剧集, 而是分别看了美国拍的纪录片<a href="https://movie.douban.com/subject/3057368/" target="_blank" rel="noopener">抢救車諾比</a>, 俄罗斯的奇幻片<a href="https://movie.douban.com/subject/26214079/" target="_blank" rel="noopener">切尔诺贝利 禁区</a>, 以及乌克兰的电视剧<a href="https://movie.douban.com/subject/25834316/" target="_blank" rel="noopener">飞蛾</a>, 这三部剧让我从三个不同角度, 或者说是阵营去感知那段历史, 充分满足了我的好奇心, 也填补了我的很多困惑, 以及帮助了我更好的去思考时代的变迁. (Warning!!!后面会有一些剧透)</p><a id="more"></a><p>也许有人疑惑为何会对切尔诺贝利感兴趣, 说来可能会比较牵强, 首先作为一个社会主义工人阶级的后代, 对苏联有着一段莫名其妙的亲切感, 而这场核灾难在某种意义上来说是苏联的掘墓人, 这话也不是我说的, 是苏联最后一个总书记戈尔巴乔夫后来讲的. 其次在我的童年所生活过的几个地方, 都是类似于普里皮亚季这样的因为有某个工厂或者机构而盛极一时的地方, 而后又因为各种原因突然衰败, 最终被废弃, 成为小朋友们探险的场所. 再次作为半个历史的爱好者, 感慨过汉唐之兴衰, 民国之兴衰, 有时也会仰望星空, 感知人类的渺小, 感叹谁主沉浮.</p><center> <img src="https://res.cloudinary.com/dtn0pkdmg/image/upload/c_scale,w_600/v1562660097/old_vhuod3.jpg" alt="old_photo"> </center><p>距离1986年4月26号凌晨已经过去33年, 当我试图去寻找这个当年的苏联模板城市的资料时, 绝大部分都只有图片的对比, 不过最终还是找到了一个名为<code>苏联最好城市普里皮亚季</code>的<a href="https://www.bilibili.com/video/av30022920" target="_blank" rel="noopener">简短的视频</a>, 透过这段视频, 依稀可以感受到这个人口五万的城市曾经的生机勃勃与辉煌.</p><center> <img src="https://res.cloudinary.com/dtn0pkdmg/image/upload/v1562660465/map_m9wltl.gif" alt="map"> </center><p>普里皮亚季, 是切尔诺贝利西北方因为核电站而修建的城市, 兴建于1970年, 距离当时苏维埃乌克兰首府基辅(Kiev)一百公里, 人口将近五万, 平均年龄只有26岁, 聚集了大量的苏联技术青年, 一号核反应堆于1977年启用, 爆炸的四号反应堆是83年启用的, 并且一共规划了6座核电站. 整个城市修建了一家医院、一个公园、一座火车站、三家诊所、三个文化中心、二十一所学校、三个室内游泳馆、十个体育馆、十个射击场、35个体育场、25家商场和店铺、27个小餐馆, 就连基辅这等大城市的富贵们也会驱车来普里皮亚季的商场买西方最新上市的Dior香水, 不过这些繁华的景象, 都没有在目前的影视剧, 纪录片中有过多的描述, 留给人们印象最深的还是灾难本身的恐惧, 以及现在普里皮亚季废墟与鬼城的形象.</p><p>为了了解俄罗斯对于切尔诺贝利的视角, 我首先看的是<a href="https://movie.douban.com/subject/26214079/" target="_blank" rel="noopener">切尔诺贝利 禁区</a>这部俄剧, 俄剧在国内非常冷门, 但是这部剧居然达到近乎9分, 并且好评如潮. 大致的剧情是一群俄罗斯青年被一个偷钱的怪人引诱到了切尔诺贝利的普里皮亚季, 后来他们无意中通过一个设备穿越到了爆炸发生之前, 第一季的最后他们改变了过去, 导致回来的时候苏联并没有解体而成为世界上最强大的国家. 还记得印象最深的是女一号无意中从废墟穿越回过去, 一片欣欣向荣的景象让我感觉到心潮澎湃, 好希望灾难从未发生. 再后来他们真的阻止了爆炸的发生, 苏联又回来了, 男主穿越回来的第一瞬间, 便看到普里皮亚季大街上熙熙攘攘带着红领巾的小朋友, 看到这里, 我竟然莫名其妙的有一些激动. 虽然第二季最后一切又回归现实, 站在我们面前的依旧是现在的俄罗斯联邦. 整部剧里除了穿越还有一些惊悚成分, 例如普里皮亚季的高辐射成为了被称作<code>禁区</code>的物质, 它具备一定的超能力, 可以制造幻想, 并且期望将来这里的人杀死. 我还很好奇的查了一下拍摄资料, 原来他们从未实景拍摄过, 因为辐射会危害健康, 不过透过演员的FB看到了一张他们在普里皮亚季大门的合照, 可能最新的情节去采景了? 非常期待今年10月份上映的大电影.</p><center> <img src="https://res.cloudinary.com/dtn0pkdmg/image/upload/c_scale,w_600/v1562660192/%E7%A6%81%E5%8C%BA_t8wr6a.jpg" alt="禁区"> </center><p>俄剧的制作虽然不如美剧华丽, 但俄国作为切尔诺贝利事件的主要参与者, 一些细节足矣窥伺出他们的态度. 比如在前往切尔诺贝利途中被警察恶意扣留, 必须得用金钱进行贿赂, 或许侧面反映了大家对于目前俄罗斯腐败的不满. 当大家阻止了爆炸的发生, 苏联重振熊威, 成为世界霸主, 连互联网都变成了俄联网, iPhone8都变成了俄Phone8, 足矣见得大家对苏联大国地位的怀念, 以及切尔诺贝利对苏联的巨大影响. 由于历史被改变, 86年的核爆炸转移到了美国, 美国又爆发了内战, 可以看出俄方对于美国的态度还是非常敌对的. 而后一行人又穿越回美国阻止了核爆, 一切又回到正轨, 也表明了俄罗斯人不愿意利用灾难转移来恢复大国地位… 或许这些都是我想多了, 不过他们脑洞之大令人佩服.</p><p>乌克兰, 作为苏联三巨头之一, 一直都是附庸的地位, 乌克兰脱离苏联后也一直都表现浓厚的反俄情绪, 但<a href="https://movie.douban.com/subject/25834316/" target="_blank" rel="noopener">飞蛾</a>改变了一些我对乌克兰人的认知, 这部剧以平民视角出发, 客观真实以及浪漫的记录了灾难给人们的影响. 剧情是以苏军上校的女儿艾丽娅与士兵巴沙的生死之恋为主线, 士兵巴沙作为上校的下属来给艾丽娅送信, 两人对上了眼. 可是没过多久核爆发生, 上校坚持亲自驾机查看爆炸情况, 飞机受到强大的电离辐射坠毁, 成为孤儿的艾丽娅精神崩溃, 士兵巴沙变成为她的唯一依托, 可惜巴沙作为清理者(Liquidator)在四号核电站楼顶受到了致命的辐射, 他不愿被送往莫斯科, 私自逃离营帐与艾丽娅在已经空城的普里皮亚季度过了人生最浪漫的一天. 巴沙最后死在了莫斯科第六医院, 而艾丽娅没有接受医院的劝说堕胎, 电视剧的最后是艾丽娅的女儿来到了普里皮亚季废墟参观旅游, 在已经锈迹斑斑的电话亭里找到了当时她父母为躲避清城人员时刻的字, “艾丽娅 &amp; 巴沙”. </p><center> <img src="https://res.cloudinary.com/dtn0pkdmg/image/upload/c_scale,h_480/v1562660274/%E9%A3%9E%E8%9B%BE_q8ogvx.jpg" alt="飞蛾"> </center><p>这部四级的电视剧以”飞蛾”为名, 寓意飞蛾扑火, 与第一集核爆当晚灯光下的成群飞蛾在不明真相的人群中死亡想呼应. 整部剧没有丝毫讽俄的成分, 涉及到几个核爆重点事件也都是结合剧情改编的合情合理. 比如上校执意驾驶飞机查看爆炸情况坠机牺牲, 而他刚刚从阿富汗战场回来, 已经接受到了上级命令可以休假回家看望女儿, 并且上级也极力劝阻. 可见这里对苏军的英勇还是非常认可, 凸显了在亲情面前, 国家更为重要. 类似的剧情还有艾丽娅的姐姐在去医院找对象的途中发现人手不够主动帮忙, 在已知有辐射的情况下没有退缩, 在受到二次辐射后被送往莫斯科, 最后不幸去世. 当然也有像艾丽娅姐姐的未婚夫得知有辐射便谎称有家中有事逃回基辅, 在被未婚妻的爷爷(苏军老兵)鄙视后, 又硬着头皮回到普里皮亚季, 他始终犹豫不决, 胆战心惊, 慌乱中还是克服障碍, 参与了撤离人员难产接生. 这些在现在看来都算是所谓的正能量, 可歌可泣的东西, 也反映了从国家到平民大家都是国难当头, 上下一心. 针对于普里皮亚季的描写, 大致也与我查到的资料相符, 这些都可以从艾丽娅与巴沙逃回空城看得到. 他们分别去了幼儿园, 姐姐家中, 以及衣服店与理发馆. 印象最深的就是姐姐家中的暖水瓶与我们小时候(90年代)家中的红色铁皮那款一模一样, 电视冰箱等家电一应俱全, 幼儿园里环境优雅设施齐全, 衣服店里琳琅满目, 理发馆里海报女郎发型时尚, 广场还有冷饮外卖摊, 饮料自助机等等. 然而这一切最终还是化为乌有, 只留下了锈迹斑斑的”艾丽娅 &amp; 巴沙”, 令人惋惜.</p><p>除去影视剧的表现, 可能纪录片更能真实详细的反应事情的经过, 事件发生后的第五年, 苏联解体, 目前唯一一部<a href="https://movie.douban.com/subject/3057368/" target="_blank" rel="noopener">称得上纪录片的还是美国拍摄的</a>, 片中收集了大量珍贵的影像资料, 采访视频, 值得一看. 片子最初是以欢快的普里皮亚季生活开始的, 茁壮成长的青少年, 干净整洁的城市规划, 街头推着婴儿车的年轻人. 片中采访了几乎所有利害相关的人, 比如当时苏联最高领导人戈尔巴乔夫, 俄方的摄像师(参与拍摄屋顶清理石墨), 挖掘隧道的煤炭工人, 直升机救援队军方负责人, 从普里皮亚季撤出的居民等等. 从高官到平民, 无一不表露出对灾难的遗憾以及对救援行动的肯定. </p><center> <img src="https://res.cloudinary.com/dtn0pkdmg/image/upload/c_scale,h_480/v1562660344/%E6%8A%A2%E6%95%91%E8%BD%A6%E8%AF%BA%E6%AF%94_z43euo.jpg" alt="抢救"> </center><p>印象比较深刻的是挖掘隧道的工人说他从不后悔, 因为总该有人要去做这件事, 不是他们也会是别人. 拍摄清理者的摄影师也以第一人称的视角描述了苏联军人如何蚂蚁搬家的将楼顶所有的石墨清理干净, 为石棺的修建打好基础, 强大的辐射在照片下方留下的印记永远被记录了下来. 戈尔巴乔夫称整个救援行动花了180亿卢布, 折合180亿美元, 我也去查了一下当时的数据, 81-85年整个苏联的赤字平均就180亿, 而86年到89年上升到了690亿, 随后石油大跌也对苏联的经济雪上加霜.</p><p><code>一个国家的消亡, 或许也是造就英雄被遗忘的重要原因</code>. 与日本福岛核事故的处理, 显然苏共中央的决策与行动力是非常值得肯定的. 4月26日凌晨核爆发生, 26日当天中央便派技术检测人员去现场测量数据, 26日晚确定必须撤离所有群众, 并连夜调集了一千多辆大巴准备进行疏散, 27日十一时开始疏散居民, 总共耗时三小时, 并且派遣军方直升机进行投放铅与硼砂来降低辐射, 将爆炸区周围的辐射从12000伦琴每小时降低到100伦琴. 28日开始疏散10km内的群众, 29日开始疏散30km内的群众, 5月2日划定隔离区并使用铁丝网围起来, 为了防止核燃料烧穿地板接触用于降温的废水而产生更大的爆炸, 在明确高辐射危险的同时, 三名来自三号反应堆的工作人员冒死进入打开消防泵, 抽干了废水 (他们竟然幸存了下来), 5月7号政府决定修建石棺以及人工降温层来防止剩余的依旧燃烧的核燃料可能造成的影响. 年轻的苏联士兵每人工作90秒, 轮班将屋顶残留的高辐射石墨清理出来, 为石棺修建扫清障碍. 5月12号开始动员了1000km外苏联最优秀的一批矿工来切尔诺贝利, 13号他们开始了工作, 仅仅一个月就完成了预计三个月的工作量. 当年12月石棺完工. 前后两年间动员了多大30万人进行清理工作. (说道动员, 想起了红警苏联的动员兵, 100块一个, 口号就是for the Union, for mother Russia, 后面一句有点反苏).</p><center> <img src="https://res.cloudinary.com/dtn0pkdmg/image/upload/c_scale,h_600/v1562662049/compare_xx7dzm.jpg" alt="compare"> </center><p>事故距今已过33年, 也许没有HBO的热播剧, 就不会有更多的人对切尔诺贝利有详尽的了解, 虽然西方价值观下的影片在一定程度上掩盖了民族英雄, 或者说共产主义下的人民英雄的形象, 但它依旧是第一个能震撼的将整个过程呈现在人们面前的影视剧. 在人们指责当局掩盖事实, 阻止人们民众知道真相的同时, 是否考虑过在那个消息不发达的年代, 在资本主义社会主力两大阵营激烈对抗当中, 维稳与防止敌国的渗透更为重要. 面对人类历史上最大的核灾难, 或许只有苏联这样国家才能在最短的时间内调动全国的人力物力, 将损失降到最低.</p><p>而最终历史还是胜利者书写, 牢不可摧的联盟, 红色的CCCP, 也只能停留在记忆当中. </p><center> <img src="https://res.cloudinary.com/dtn0pkdmg/image/upload/v1562660807/cccp_e2sjcd.jpg" alt="CCCP"> </center><p>忘记苏联没良心, 而恢复苏联也决然不再可能.</p>]]></content>
    
    <summary type="html">
    
      Chernobyl, 切尔诺贝利, 車諾比
    
    </summary>
    
      <category term="nonsense" scheme="http://talentprince.github.io/categories/nonsense/"/>
    
    
      <category term="nonsense" scheme="http://talentprince.github.io/tags/nonsense/"/>
    
  </entry>
  
  <entry>
    <title>探究高级的Kotlin Coroutines知识</title>
    <link href="http://talentprince.github.io/2019/02/12/Deep-explore-kotlin-coroutines/"/>
    <id>http://talentprince.github.io/2019/02/12/Deep-explore-kotlin-coroutines/</id>
    <published>2019-02-12T01:14:52.000Z</published>
    <updated>2020-06-22T09:44:59.477Z</updated>
    
    <content type="html"><![CDATA[<p>要说程序如何从简单走向复杂, 线程的引入必然功不可没, 当我们期望利用线程来提升程序效能的过程中, 处理线程的方式也发生了从原始时代向科技时代发生了一步一步的进化, 正如我们的Elisha大神所著文章<a href="https://medium.com/@elye.project/the-evolution-of-android-network-access-1e199fc6e9a2" target="_blank" rel="noopener">The Evolution of Android Network Access</a>中所讲到的, Future可能会是Kotlin Coroutines的时代.</p><a id="more"></a><h3 id="什么是Coroutines"><a href="#什么是Coroutines" class="headerlink" title="什么是Coroutines"></a>什么是Coroutines</h3><p>Coroutines是Kotlin 1.1推出的实验性的一个扩展, 它被定义为一个轻量级的高效的线程框架, 并且在1.3版本正式发布, 去掉Experiment标签.</p><h3 id="如何启动一个Coroutines"><a href="#如何启动一个Coroutines" class="headerlink" title="如何启动一个Coroutines"></a>如何启动一个Coroutines</h3><p>最基础的创建一个Coroutines的方法就是使用<code>launch</code>或者<code>async</code>, 二者的区别是前者返回的是一个<code>Job</code>, 不带结果 而后者可以将结果以<code>Deferred&lt;T&gt;</code>格式返回.</p><p>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val job = launch &#123;</span><br><span class="line">    delay(100)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而通常在Coroutines内执行的函数都会有一个<code>suspend</code>声明, 而有<code>suspend</code>声明的函数也只能在Coroutines Scope中调用.</p><p><code>suspend</code>的意思是这个函数可以被suspend(挂起), 让Coroutines来调度它, 这也是为何Kotlin的<code>delay</code>函数可以不阻塞的进行延迟, 因为它就是一个suspend函数.</p><h3 id="Coroutines与线程的关系"><a href="#Coroutines与线程的关系" class="headerlink" title="Coroutines与线程的关系"></a>Coroutines与线程的关系</h3><p>Coroutines可以简单理解为一个有队列的任务链, 每一个Coroutines都有自己的Context, 而Context又可以决定其运行的线程.</p><p>所以可以看到, 并不是起一个Coroutines就是起了一个线程, 而只是启动了一个在某个Scope下运行的协程(Coroutines)罢了. 这里的Scope (CoroutineScope) 内部包含了一个 Context (CoroutineContext).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface CoroutineScope &#123;</span><br><span class="line">    public val coroutineContext: CoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只是通过<code>launch</code>来启动一个协程, 那它将会运行在Parent Scope所定义的线程中, 但是如果使用<code>GlobalScope.launch</code>来启动一个协程, 它将会使用线程池中的线程来创建一个协程, 线程池的大小跟CPU的核数相关.</p><p>当然<code>launch</code>也支持自己传入一个CoroutinesContext来控制它运行的线程, 它叫做<code>CoroutineDispatcher</code>, 是Context的子类.</p><p>上面讲了默认的<code>launch</code>会启在父Scope(Context)的线程中, 而<code>launch(Dispatchers.Default)</code>则等于<code>GlobalScope.launch</code>, 还可以通过<code>launch(newSingleThreadContext(&quot;MyOwnThread&quot;))</code>来启动自己的线程, 另外有一个不推荐在general code中出现的<code>launch(Dispatchers.Unconfined)</code>, 它将会运行在第一个进入Suspend状态的线程中.</p><p>可以举一个简单的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val job = launch &#123;</span><br><span class="line">    log(&quot;hehe&quot;)</span><br><span class="line">    delay(1000)</span><br><span class="line">    log(&quot;haha&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个协程是可以完全在main函数里执行完的, 即输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hehe</span><br><span class="line">haha</span><br></pre></td></tr></table></figure><p>因为launch会跑在main的scope中. 如果替换成:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val job = GlobalScope.launch &#123;</span><br><span class="line">    log(&quot;hehe&quot;)</span><br><span class="line">    delay(1000)</span><br><span class="line">    log(&quot;haha&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则只会输出<code>hehe</code>, 因为主线程已经结束.</p><p>这里我们可以通过<code>job.join()</code>来等待子协程执行结束, 这一点跟大家熟知的线程的join是一样.</p><h3 id="如何切换Context"><a href="#如何切换Context" class="headerlink" title="如何切换Context"></a>如何切换Context</h3><p>如果把Context对应到我们平时认为的线程, 那么这个问题可以类比成 <code>如何切换线程</code>.</p><p>答案是使用<code>withContext</code>, 举一个简单的栗子.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">launch(UI) &#123;</span><br><span class="line">    updateUI()</span><br><span class="line">    val result = withContext(IO) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    setView(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它类似于<code>async(IO){ }.await()</code>.</p><h3 id="如何共享资源"><a href="#如何共享资源" class="headerlink" title="如何共享资源"></a>如何共享资源</h3><p>线程与线程之间会涉及到同步与资源竞争的关系, 协程亦是如此.</p><p>通常情况下在线程中我们解决问题的方式是<code>加锁</code>, 而不正确的使用可能会导致性能下降甚至死锁（dead lock. 或者在高级语言中使用已经实现线程安全的数据类型, 来进行夸线程操作。</p><p>而我们的Coroutines自然也考虑到了这一点, 它认为我们<code>不应该以共享资源来进行通信, 而是以通信来进行资源共享</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Do not communicate by sharing memory; instead, share memory by communicating.</span><br></pre></td></tr></table></figure><p>所以它提出了一个叫做<code>Channel</code>的东西来在不同的Coroutines之间进行通信.</p><p>譬如我们期望将一堆数据交给两个并行的协程进行处理, 那么我们可以把数据放进Channel, 其他的协程从这个Channel进行数据读取.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">launch &#123;</span><br><span class="line">    for (o in data) &#123; channel.send(o) &#125;</span><br><span class="line">    channel.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">launch(One) &#123;</span><br><span class="line">    for (o in channel) &#123;</span><br><span class="line">        xxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">launch(Two) &#123;</span><br><span class="line">    for (o in channel) &#123;</span><br><span class="line">        xxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一定要记得关闭channel, 否则从channel读取数据的协程都将会无限挂起等待数据传过来.</p><p>由于Channel本身实现了<code>iterator</code>, 所以直接通过<code>in</code>就可以挨个取出内部的数据.</p><h3 id="ReceiveChannel与SendChannel"><a href="#ReceiveChannel与SendChannel" class="headerlink" title="ReceiveChannel与SendChannel"></a>ReceiveChannel与SendChannel</h3><p>上一个环节提到的协程之间是通过Channel来进行通信, 而Channel本身却是实现了接收管道与发送管道两个接口.</p><p>我们可以通过<code>producer</code>函数来进行生成数据, 提供给别的协程, 因为它的返回值是一个ReceiveChannel.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val channel = produce&lt;XXX&gt;() &#123;</span><br><span class="line">    for (o in data) send(o)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且produce自己会做channel close的处理, 省去我们发送完毕还要掉close的烦恼.</p><p>如果我们多个协程需要发送请求并集中处理, 或者可以叫数据整合, 那么我们可能需要用到<code>actor</code>这个函数, 它的返回值是一个SendChannel.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">val channel = actor&lt;XXX&gt;() &#123;</span><br><span class="line">                consumeEach &#123;</span><br><span class="line">                   xxx     </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">launch(One) &#123;</span><br><span class="line">    channel.send(xxx)</span><br><span class="line">&#125;</span><br><span class="line">launch(Two) &#123;</span><br><span class="line">    channel.send(xxx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>actor</code>返回的SendChannel有点像是一个邮箱, 它会不断的接收数据, 所以必须手动关闭才会停止.</p><h3 id="多个Channel之间数据如何进行选择"><a href="#多个Channel之间数据如何进行选择" class="headerlink" title="多个Channel之间数据如何进行选择"></a>多个Channel之间数据如何进行选择</h3><p>Coroutines推出一个仍在Experiment阶段的关键字<code>select</code>来在多个suspend function中进行选择第一个到达available的, 其实有点像RxJava的concat+first.</p><p>比如我有两个接收Channel, 但是每一个Channel接收到数据的频率不得而知, 我想分别从中得到数据, 这里就需要使用select.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select&lt;Unit&gt; &#123;</span><br><span class="line">    channel1.onReceive &#123;&#125;</span><br><span class="line">    channel2.onReceive &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在配合外围的循环, 就可以做到不断的去接收两个Channel的数据.</p><p>再比如有两个发送Channel都可以处理我的需求, 我也不知道这个时候谁是空闲的, 那也可以通过select来解决.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select&lt;Unit&gt; &#123;</span><br><span class="line">    channel1.onSend(xxx) &#123;&#125;</span><br><span class="line">    channel2.onSend(xxx) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候两个Channel是嵌套使用的.</p><p>比如一个咖啡店, 他们会不断的收到Oder, 只有两个打咖啡的服务员, 咖啡机也只有两个口,  如果我们对这个咖啡店进行抽象. 将Oder存在于一个Channel里, 服务员接收Order并不断的把咖啡递出来, 这也是一个Channel, 咖啡机会不断接收到服务员需要打咖啡的操作, 也这是一个Channel.</p><p>而在这个过程中, 两个服务员会有一个选择, 咖啡机的两个出口也会有一个选择的过程.</p><p>如果抽象成我们的Coroutines代码, 或许会是这个样子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">val orderChannel = producer &#123;</span><br><span class="line">    for (o in orders) send(o)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val waiter1 = producer &#123;</span><br><span class="line">    for (o in orderChannel) &#123; </span><br><span class="line">        pullCoffee(o)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// waiter2 is the same as 1</span><br><span class="line"></span><br><span class="line">val coffeePort1 = actor &#123;</span><br><span class="line">    consumeEach &#123; </span><br><span class="line">        //pass coffee through channel inside order</span><br><span class="line">        it.channel.send(Coffee)</span><br><span class="line">        it.channel.close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// coffeePort2 is the same as 2</span><br><span class="line"></span><br><span class="line">pullCoffee &#123;</span><br><span class="line">    select&lt;Coffee&gt; &#123;</span><br><span class="line">        coffeePort1.onSend(Request(channel)) &#123;</span><br><span class="line">            //get coffee from coffeePort</span><br><span class="line">            channel.recevie()</span><br><span class="line">        &#125;</span><br><span class="line">        coffeePort2.onSend ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while(someCondition) &#123;</span><br><span class="line">    select&lt;Coffee&gt; &#123;</span><br><span class="line">        waiter1.onReceiveOrNull &#123;</span><br><span class="line">            //上菜了</span><br><span class="line">        &#125;</span><br><span class="line">        waiter2.onReceiveOrNull &#123;</span><br><span class="line">            //上菜了</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>协程作为未来non blocking编程的方向, 需要大家花时间去理解, 花时间去尝试, 在此特别推荐这个咖啡小程序帮助大家学习.</p><p><a href="https://medium.com/@jagsaund/kotlin-coroutines-channels-csp-android-db441400965f" target="_blank" rel="noopener">https://medium.com/@jagsaund/kotlin-coroutines-channels-csp-android-db441400965f</a></p><p>以及官方的Overview</p><p><a href="https://kotlinlang.org/docs/reference/coroutines-overview.html" target="_blank" rel="noopener">https://kotlinlang.org/docs/reference/coroutines-overview.html</a></p><p>还有个CheatSheet可以参考</p><p><a href="https://blog.kotlin-academy.com/kotlin-coroutines-cheat-sheet-8cf1e284dc35" target="_blank" rel="noopener">https://blog.kotlin-academy.com/kotlin-coroutines-cheat-sheet-8cf1e284dc35</a></p>]]></content>
    
    <summary type="html">
    
      深入解析Kotlin Coroutines 协程
    
    </summary>
    
      <category term="Kotlin" scheme="http://talentprince.github.io/categories/Kotlin/"/>
    
    
      <category term="Android" scheme="http://talentprince.github.io/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://talentprince.github.io/tags/Kotlin/"/>
    
      <category term="Kotlin Coroutines" scheme="http://talentprince.github.io/tags/Kotlin-Coroutines/"/>
    
  </entry>
  
  <entry>
    <title>The year that was 2018</title>
    <link href="http://talentprince.github.io/2018/12/28/The-year-that-was-2018/"/>
    <id>http://talentprince.github.io/2018/12/28/The-year-that-was-2018/</id>
    <published>2018-12-28T02:13:42.000Z</published>
    <updated>2020-06-22T09:44:59.478Z</updated>
    
    <content type="html"><![CDATA[<p>昨天天空飘起了大雪, 今天便又艳阳高照, 空气中透着阵阵寒意, 似乎意味着冬天真的来了, 而且是大摇大摆, 万众瞩目.</p><p>四季分明, 或许不是文明泵发的必要条件, 但一年四季, 朝夕交替, 却的确是我们生活, 成长, 喜怒哀乐的必要条件.</p><p>2018年已余额不足, 恍惚间已迈入而立, 然常常并不曾觉察, 思绪也会偶然停留在学校, 停留在实验室, 停留在北京, 停留在年少轻狂的时代. 或许, 这也就是所说的老了吗?</p><p>在这即将过去的一年中, 发生了太多的改变, 虽然已经过去, 沉积在大脑中的余晖, 依旧令我久久不能平息. 我心痛过, 庆幸过, 欢喜过, 也期待着未来美好的事情会发生.</p> <a id="more"></a><ul><li>心痛:</li></ul><p>自宝宝出生后, 孩儿的娘便病魔缠身, 接二连三, 这对生活质量本已下降的整个家庭来说, 仿佛是异常噩梦, 似乎一切都是设定好的那样, 每次都是离希望的出口就差一步, 便又掉了进去, 肉体上的痛苦夹杂着无形的社会压力, 至今回想起来依旧胆战心惊.</p><p>命运的坎坷似乎也有延续与扩散之意, 老婆刚刚康复上班, 五岁的皮皮却在小区被二把刀熟人女司机杀害, 可惜之余, 大家都讲皮皮完成了它的使命, 现在有小小呆来取代它的位置了, 为了防止这段没好的回忆被遗忘, 我将所有与它有关的记忆记录下来, 来缅怀在特殊时期贡献过欢乐的小动物.</p><ul><li>庆幸:</li></ul><p>曾经有讲过, 这些年来没有什么太值得雀跃的事情, 唯独庆幸的是能把老婆从某邪恶组织解脱出来, 而又不伤毫发. 然而似乎这一年需要感谢上苍的事情不少, 小小呆是一个很乖很可爱很健康的宝宝; 老婆的病也终于康复, 生活中诸多与之相关不悦之事都渐渐烟消云散.</p><ul><li>欢喜:</li></ul><p>说道欢喜, 必定是在不断成长的小小呆, 看着从只会呆呆的躺着到现在到处乱跑, 爬上爬下, 模仿大人, 捉迷藏, 似乎一切都发生的太快了, 回头想想去年他还在妈妈的肚子里呢, 不禁感叹大自然与妈妈的伟大, 生命的美好, 以及未来的无限可期.</p><ul><li>期待:</li></ul><p>期待总会有太多, 然成者去半, 顺利达成者去之又半. 对于现在略显枯燥, 疲敝的生活, 应当宽心面对, 已经苦尽, 何愁甘不来呢. 计划一直都在队列里排着, 所有不顺的节点必将随着小小呆的长大而一一打开, 欢乐不会缺席, 只是有时不被觉察, 又或是感叹太过短暂罢了.</p><p>愿一切趋于美好, 顺利过冬.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天天空飘起了大雪, 今天便又艳阳高照, 空气中透着阵阵寒意, 似乎意味着冬天真的来了, 而且是大摇大摆, 万众瞩目.&lt;/p&gt;
&lt;p&gt;四季分明, 或许不是文明泵发的必要条件, 但一年四季, 朝夕交替, 却的确是我们生活, 成长, 喜怒哀乐的必要条件.&lt;/p&gt;
&lt;p&gt;2018年已余额不足, 恍惚间已迈入而立, 然常常并不曾觉察, 思绪也会偶然停留在学校, 停留在实验室, 停留在北京, 停留在年少轻狂的时代. 或许, 这也就是所说的老了吗?&lt;/p&gt;
&lt;p&gt;在这即将过去的一年中, 发生了太多的改变, 虽然已经过去, 沉积在大脑中的余晖, 依旧令我久久不能平息. 我心痛过, 庆幸过, 欢喜过, 也期待着未来美好的事情会发生.&lt;/p&gt;
    
    </summary>
    
      <category term="nonsense" scheme="http://talentprince.github.io/categories/nonsense/"/>
    
    
  </entry>
  
  <entry>
    <title>Android程序员的Flutter学习笔记</title>
    <link href="http://talentprince.github.io/2018/11/08/Flutter-self-learning-notes-as-an-android-developer/"/>
    <id>http://talentprince.github.io/2018/11/08/Flutter-self-learning-notes-as-an-android-developer/</id>
    <published>2018-11-08T03:17:10.000Z</published>
    <updated>2020-06-22T09:44:59.477Z</updated>
    
    <content type="html"><![CDATA[<p>作为忠实与较资深的Android汪, 最近抽出了一些时间研究了一下Google的亲儿子Flutter, 尚属皮毛, 只能算是个简单的记录吧.</p><p>Google自2017年第一次提出Flutter, 到2018年Beta, 再加之RN的各种风波与问题, 使得Flutter的热度不断上升, 国内不少公司都公布Flutter在其产品中的应用, 如美团, 闲鱼等.</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Flutter作为跨平台框架, 常常被人拿出来与React Native, 以及Xamarin进行对比, 除了大家都是跨平台框架之外且能达到近乎Native的体验之外, Flutter与这两者的原理大不相同.</p><p>让我们来看看这三者的结构图吧.</p><p><img src="/images/react_native.png" alt="React Native"></p><p><img src="/images/xamarin.png" alt="Xamarin"></p><p><img src="/images/flutter.png" alt="Flutter"></p><p>可能有一些复杂, 咱大致解释一下.</p><p>React Native跟Xamarin都是基于mapping native代码来实现所谓的Native体验的框架, 只是RN基于JS引擎 + Bridge与native打交道, 并且在运行时进行绑定, 而Xamarin是基于微软的基于Linux的C#虚拟机mono + JNI与native进行通信.</p><p>这里Android与iOS还是有差别的, 如RN在iOS上JS引擎不支持JIT, 会一定程度影响效率, Xamarin在iOS上可以直接编译成iOS平台可以执行的程序, 所以在实际运行起来的性能是一样的, 唯一的差别就是微软得更快的支持API同步.</p><p>对于Flutter来说, 由于他的渲染引擎使用了Skia直绘, 加上基于C++的Dart引擎, 所以在不同平台上没有差别, 加之其实现了Android Material Design与iOS Cupertino两套UI组件, 所以即便是自绘组件, 看起来还是跟原生的一个样子.</p><p>通过对三种跨平台引擎的大致了解, 我们可以看出来, 他们都达到了一定程度的Native体验, 然则各自都有一定的性能损耗, 比如RN的JS引擎加载JS, 以及Bridge通信的损耗, Xamarin Mono虚拟机与Java通信的损耗, 以及Flutter Skia渲染与Native Android渲染的差异等.</p><h2 id="Flutter笔记"><a href="#Flutter笔记" class="headerlink" title="Flutter笔记"></a>Flutter笔记</h2><h3 id="如何启动一个app"><a href="#如何启动一个app" class="headerlink" title="如何启动一个app"></a>如何启动一个app</h3><p>Android需要在Manfest里面指定带有MAIN action与LAUNCHER category的Activity声明, 而Flutter只需要一行.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void main() =&gt; runApp(MyApp());</span><br></pre></td></tr></table></figure><p>其中MyApp就是一个普通的Widgets(View).</p><h3 id="View-vs-Widgets"><a href="#View-vs-Widgets" class="headerlink" title="View vs Widgets"></a>View vs Widgets</h3><p>Flutter没有View, 与之对应的是Widget, 并且分为StatelessWidgets与StatefulWidgets, 前者是个静态View, 后者是动态通过Data来更新的View.</p><ul><li>Stateless</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">  &apos;I like Flutter!&apos;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>Stateful</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class StatefulText extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  State&lt;StatefulWidget&gt; createState() =&gt; _TextState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _TextState extends State&lt;StatefulText&gt; &#123;</span><br><span class="line">  // Default placeholder text</span><br><span class="line">  String textToShow = &quot;I Like Flutter&quot;;</span><br><span class="line"></span><br><span class="line">  void _updateText() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      // update the text</span><br><span class="line">      textToShow = &quot;Flutter is Awesome!&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">      ...invoke _updateText</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上是因为StatefulWidgets通过调用<code>State</code>的<code>setState</code>方法来触发整个Widgets树的重绘, 并且在重绘之前会调用传进去的<code>(){ ... }</code>block.</p><h3 id="怎么写Layout-XML到哪里去了"><a href="#怎么写Layout-XML到哪里去了" class="headerlink" title="怎么写Layout, XML到哪里去了."></a>怎么写Layout, XML到哪里去了.</h3><p>实际上Flutter没有xml了, 并且是通过Widgets的嵌套来实现一个布局的.</p><p>如:</p><ul><li><code>Center</code>是一个可以把子View放置在中央的容器.</li><li><code>Row</code>对应的就是LinearLayout + Horizontal, <code>Column</code>对应的就是LinearLayout + Vertical, 他们都具备一个属性叫做<code>crossAxisAlignment</code>, 有点类似<code>gravity</code>, 来控制子View相对于父View的位置.</li><li><code>Expanded</code>支持一个类似weight的属性, 叫<code>flex</code>. </li><li><code>Container</code>是一个具有<code>decoration</code>属性的容器, 可以用来控制背景色, border, margin等等.</li><li><code>Stack</code>有点像是一个特殊的RelatetiveLayout或者ConstraintLayout, <code>children</code>属性指定了它的子View, 第一个是Base View, <code>alignment</code>属性指定了后面的子View相对于BaseView的位置, 如<code>alignment: const Alignment(0.6, 0.6)</code>指定了位于BaseView右下角的位置.</li><li><code>ListTile</code>是一个特殊的ListItem, 有三个属性, 分别是左边的Icon (leading), 文字 (title), 以及右边的Icon (trailing).</li><li>还有诸如<code>ListView</code>, <code>GridView</code>, <code>Card</code>等等比较熟悉的Widgets.</li></ul><p>另外有一个类似于我们Activity的Widgets:</p><ul><li>叫做<code>MaterialApp</code>, 可以指定<code>theme</code>, <code>title</code>, 以及子View <code>home</code>, 还有更重要的页面跳转<code>routes</code>.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">      title: &apos;Welcome to Flutter&apos;,</span><br><span class="line">      home: ...,</span><br><span class="line">      routes: &lt;String, WidgetBuilder&gt; ...,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primaryColor: Colors.white</span><br><span class="line">      ),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>还有一个类似于Fragment的:</p><ul><li>叫做<code>Scaffold</code>, 中文意思是<code>脚手架</code>, 它包含一个appBar (ActionBar)与一个body, appBar可以指定title与actions (类似于action button的点击事件).</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(widget.title),</span><br><span class="line">        actions: &lt;Widget&gt;[...],</span><br><span class="line">      ),</span><br><span class="line">      body: ...,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h3 id="如何从父View中Remove一个元素"><a href="#如何从父View中Remove一个元素" class="headerlink" title="如何从父View中Remove一个元素"></a>如何从父View中Remove一个元素</h3><p>答案是没有… 因为在Flutter看来, Widgets的树结构是不可以被更改的, 但是如果想更改, 则是通过StatefulWidgets的方法, 通过setState来更改Data, 触发Widgets重绘, 从而替换掉之前的Widgets.</p><h3 id="喜欢画Canvas的同学怎么办"><a href="#喜欢画Canvas的同学怎么办" class="headerlink" title="喜欢画Canvas的同学怎么办?"></a>喜欢画Canvas的同学怎么办?</h3><p>Flutter同样支持, <code>CustomPaint</code>作为一个 Widgets就支持传入一个实现<code>CustomPainter</code>抽象类的参数, 而<code>CustomPainter</code>的抽象方法也类似于Android View的<code>onDraw</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void paint(Canvas canvas, Size size)</span><br><span class="line"></span><br><span class="line">bool shouldRepaint(CustomPainter oldDelegate)</span><br></pre></td></tr></table></figure><h3 id="如何自定义View"><a href="#如何自定义View" class="headerlink" title="如何自定义View"></a>如何自定义View</h3><p>不用继承, 而使用类似Android ViewGroup的办法, 通过组合(composing)与封装的方法来实现, 通过小Widgets组合成需要的新Widgets.</p><h3 id="页面跳转怎么办-四大组件之一的Intent跑哪里去了"><a href="#页面跳转怎么办-四大组件之一的Intent跑哪里去了" class="headerlink" title="页面跳转怎么办, 四大组件之一的Intent跑哪里去了"></a>页面跳转怎么办, 四大组件之一的Intent跑哪里去了</h3><p>貌似在讲类似于Activity的<code>MaterialApp</code>的时候剧透了… </p><p>就是使用<code>Navigator</code>与<code>Routes</code>来实现界面跳转, 实际上是整个Widgets的替换.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">routes: &lt;String, WidgetBuilder&gt; &#123;</span><br><span class="line">      &apos;/a&apos;: (BuildContext context) =&gt; MyPage(title: &apos;page A&apos;),</span><br><span class="line">      &apos;/b&apos;: (BuildContext context) =&gt; MyPage(title: &apos;page B&apos;),</span><br><span class="line">      &apos;/c&apos;: (BuildContext context) =&gt; MyPage(title: &apos;page C&apos;),</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">Navigator.of(context).pushNamed(&apos;/b&apos;);</span><br></pre></td></tr></table></figure><h3 id="如何处理外部的Intent"><a href="#如何处理外部的Intent" class="headerlink" title="如何处理外部的Intent"></a>如何处理外部的Intent</h3><p>实际上还是需要在Flutter App的Android壳子中注册这个filter, 然后在FlutterActivity中拿到存下来, </p><p>FlutterView初始化后再通过Bridge, 官方叫<code>MethodChannel</code>从Java里获取,进行下一步逻辑.</p><p>可以看个简单的例子.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">new MethodChannel(getFlutterView(), &quot;app.channel.shared.data&quot;).setMethodCallHandler(</span><br><span class="line">      new MethodCallHandler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onMethodCall(MethodCall call, MethodChannel.Result result) &#123;</span><br><span class="line">          if (call.method.contentEquals(&quot;getSharedText&quot;)) &#123;</span><br><span class="line">            result.success(sharedText);</span><br><span class="line">            sharedText = null;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">getSharedText() async &#123;</span><br><span class="line">    var sharedData = await platform.invokeMethod(&quot;getSharedText&quot;);</span><br><span class="line">    if (sharedData != null) &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        dataShared = sharedData;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="常用的startActivityForResult怎么办"><a href="#常用的startActivityForResult怎么办" class="headerlink" title="常用的startActivityForResult怎么办."></a>常用的startActivityForResult怎么办.</h3><p>这个Flutter有完全对应的办法, 而且用起来很方便, 结合之前说的页面跳转:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map xxx = await Navigator.of(context).pushNamed(&apos;/xxx&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Navigator.of(context).pop(&#123;xxx&#125;);</span><br></pre></td></tr></table></figure><h3 id="异步怎么办-runOnUiThread-哪里去了"><a href="#异步怎么办-runOnUiThread-哪里去了" class="headerlink" title="异步怎么办, runOnUiThread()哪里去了"></a>异步怎么办, runOnUiThread()哪里去了</h3><p>Flutter有点像JS, 是一个单线程模式, 所以只是通过模拟来构建简单的异步, 关键字就是类似于kotlin coroutines一样, 通过<code>await</code>+<code>async</code>来处理.</p><p>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loadData() async &#123;</span><br><span class="line">    response = await http.get(xxx);</span><br><span class="line">    setState(() &#123;xxx&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是由于它的单线程, 所以无法做很长的阻塞操作, 像http请求的延迟正常情况可能都是毫秒级的, 但是数据的处理等, 可能就得秒级了.</p><p>这也是RN在线程方面的做android程序的一个痛点, Flutter采用了比较容易想到的曲线救国的办法, 提供了一个叫<code>Isolate</code>的对象, 它实际是一个基于socket的数据通道, 相当于把数据放在一个独立的进程进行处理, 然后再通过socket发送回程序进程, 还记得进程间通信办法之一的<code>管道</code>吗…</p><p>具体API可以参考文档<a href="https://flutter.io/docs/get-started/flutter-for/android-devs" target="_blank" rel="noopener">1…</a>,<a href="https://docs.flutter.io/flutter/dart-isolate/Isolate-class.html" target="_blank" rel="noopener">2…</a>.</p><h3 id="Flutter-替代OkHttp的网络库"><a href="#Flutter-替代OkHttp的网络库" class="headerlink" title="Flutter 替代OkHttp的网络库"></a>Flutter 替代OkHttp的网络库</h3><p>自带了http库, 直接<code>http.get(url)</code>, 在线程部分的代码实例里也有涉及.</p><p>通过类似gradle的文件<code>pubspec.yaml</code>引入.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  ...</span><br><span class="line">  http: ^0.12</span><br></pre></td></tr></table></figure><p><code>^</code>表示不升大版本, 并取最新版本, 比gradle的+要范围更小.</p><h3 id="常见的LCE-Loading-Content-Error-里面的Loading怎么show"><a href="#常见的LCE-Loading-Content-Error-里面的Loading怎么show" class="headerlink" title="常见的LCE(Loading Content Error)里面的Loading怎么show"></a>常见的LCE(Loading Content Error)里面的Loading怎么show</h3><p>Flutter有一个widget叫做<code>ProgressIndicator</code>, 比如我们期望有一个转圈圈的Loading界面在数据加载出来之前.</p><p>我们就可以通过StatefulWidgets, 根据数据, 或者List Widgets的个数 (如果是显示一个List的话)来判断是否显示Loading, 使用子类<code>CircularProgressIndicator</code>, 来替换页面的Widgets.</p><p>当然也是通过setState(() {…})来触发界面刷新的, 可以在initState()内触发加载数据的异步操作.</p><h3 id="不同分辨率的图片资源怎么放"><a href="#不同分辨率的图片资源怎么放" class="headerlink" title="不同分辨率的图片资源怎么放"></a>不同分辨率的图片资源怎么放</h3><p>这个有点像iOS了, 即有1x,2x,3x:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">images/my_icon.png       // Base: 1.0x image</span><br><span class="line">images/2.0x/my_icon.png  // 2.0x image</span><br><span class="line">images/3.0x/my_icon.png  // 3.0x image</span><br></pre></td></tr></table></figure><p>不一样的一点还需要添加到类似gradle的文件<code>pubspec.yaml</code>里.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assets:</span><br><span class="line"> - images/my_icon.jpeg</span><br></pre></td></tr></table></figure><h3 id="字符串怎么存储"><a href="#字符串怎么存储" class="headerlink" title="字符串怎么存储"></a>字符串怎么存储</h3><p>Flutter没有像Android的<code>string.xml</code>的东西, 目前来说最好的就就是存成静态字符串.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Strings &#123;</span><br><span class="line">  static String welcomeMessage = &quot;Welcome To Flutter&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Text(Strings.welcomeMessage)</span><br></pre></td></tr></table></figure><h3 id="Gradle变成什么了"><a href="#Gradle变成什么了" class="headerlink" title="Gradle变成什么了"></a>Gradle变成什么了</h3><p>前面说网络库, 图片资源的时候提到过, 提供了一个叫<code>pubspec.yaml</code>的文件, 具体支持的规则可以查看<a href="https://www.dartlang.org/tools/pub/pubspec" target="_blank" rel="noopener">这个文档</a>.</p><h3 id="Fragment与Activity呢"><a href="#Fragment与Activity呢" class="headerlink" title="Fragment与Activity呢?"></a>Fragment与Activity呢?</h3><p>之前做过类比, 如<code>MaterialApp</code>有点类似于Activity, 而<code>Scaffold</code>都点类似Fragment, 实际上他们两个都是Flutter的Widgets, 也就是说其实只有View的概念了.</p><h3 id="还有生命周期吗"><a href="#还有生命周期吗" class="headerlink" title="还有生命周期吗?"></a>还有生命周期吗?</h3><p>Flutter有一个叫做<code>WidgetsBinding</code>的可以提供类似生命周期的回调.</p><p>四种状态<code>inactive</code> (iOS专用), <code>paused</code>(相当于onPause, 退后台), <code>resumed</code>(相当于onPostResume, 到前台), <code>suspending</code>(android专用, 相当于onStop).</p><p>一般在StatefulWidgets的State中注册与反注册.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line"> void initState() &#123;</span><br><span class="line">   super.initState();</span><br><span class="line">   WidgetsBinding.instance.addObserver(this);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> void dispose() &#123;</span><br><span class="line">   WidgetsBinding.instance.removeObserver(this);</span><br><span class="line">   super.dispose();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="ScrollView-vs-ListView"><a href="#ScrollView-vs-ListView" class="headerlink" title="ScrollView vs ListView"></a>ScrollView vs ListView</h3><p>Flutter没有ScrollView, 合并到了ListView, 通过ListView.builder创建的ListView提供了View复用的逻辑.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ListView.builder(</span><br><span class="line">          itemCount: widgets.length,</span><br><span class="line">          itemBuilder: (BuildContext context, int position) &#123;</span><br><span class="line">            return Text(xxx);</span><br><span class="line">          &#125;))</span><br></pre></td></tr></table></figure><p>其中itemBuilder有点像Android ListView的getView, 官方文档说它会自动回收Element给你, 但是事实上每次你都需要根据position生成新的Widgets, 所以呢应该是Flutter在内部回收了之前的Widgets并在你重新创建的时候又用上了.</p><p>BTW, 通过ListView构造来显示就不具备这种特性, 所以大量数据需要用Builder.</p><h3 id="Flutter横竖屏怎么玩"><a href="#Flutter横竖屏怎么玩" class="headerlink" title="Flutter横竖屏怎么玩."></a>Flutter横竖屏怎么玩.</h3><p>因为它实际上还是借助了Android程序的壳子, 所以如果AndroidManifect定义了<code>android:configChanges=&quot;orientation|screenSize&quot;</code>, 则Flutter会自己hanlde.</p><h3 id="怎么处理Gesture"><a href="#怎么处理Gesture" class="headerlink" title="怎么处理Gesture"></a>怎么处理Gesture</h3><p>Flutter提供了<code>GestureDetector</code>, 它相当于一个Container, 将我们期望接收手势的Widgets放进去, 再实现事件回调就行了.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GestureDetector(</span><br><span class="line">        child: FlutterLogo(</span><br><span class="line">          size: 200.0,</span><br><span class="line">        ),</span><br><span class="line">        onTap: () &#123;</span><br><span class="line">          print(&quot;tap&quot;);</span><br><span class="line">        &#125;,</span><br><span class="line">      )</span><br></pre></td></tr></table></figure><p>它同样支持其他的手势, 如<code>onDoubleTap</code>等等等.</p><h3 id="字体怎么弄"><a href="#字体怎么弄" class="headerlink" title="字体怎么弄"></a>字体怎么弄</h3><p>首先需要在<code>pubspec.yaml</code>里面配置需要的字体库:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fonts:</span><br><span class="line">   - family: MyCustomFont</span><br><span class="line">     fonts:</span><br><span class="line">       - asset: fonts/MyCustomFont.ttf</span><br><span class="line">       - style: italic</span><br></pre></td></tr></table></figure><p>然后在Text的<code>style</code>属性进行配置.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">        &apos;This is a custom font text&apos;,</span><br><span class="line">        style: TextStyle(fontFamily: &apos;MyCustomFont&apos;),</span><br><span class="line">      )</span><br></pre></td></tr></table></figure><h3 id="Hint哪里去了-错误信息怎么输出"><a href="#Hint哪里去了-错误信息怎么输出" class="headerlink" title="Hint哪里去了, 错误信息怎么输出"></a>Hint哪里去了, 错误信息怎么输出</h3><p>对于输入框的Hint基本一致, 可能就是换了个名字, 一看便知.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">    decoration: InputDecoration(hintText: &quot;This is a hint&quot;, errorText: _getErrorText()),</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Flutter在视图渲染上另辟蹊径, 性能优势凸显, 在跨平台框架属于一匹黑马, 又有Google撑腰, 值得在Mobile勤耕多年的同学入手. </p><p>由于作者曾经从事过2年的Webkit开发工作, 拜读了Flutter的渲染模式, 很像是Webkit/Chrome/Blink的思路, 通过查证, 起草者确实有大批同样的人, 如果你还没有入坑RN, 或许Flutter可以作为跨平台方案学习的首选哦. </p><p>同样Google自己也有很多Plugin去支持更多扩展功能, 如GPS, Camera, SharePreference, Database. 还例如Firebase这种亲儿子级的服务也是全面支持Flutter. 这些都可以通过<a href="https://pub.dartlang.org" target="_blank" rel="noopener">Dartlang</a>来查询.</p><p>当然也可以自己去开发需要的Plugin来适配需要的功能, 基于的技术就是上面有提的<code>MethodChannel</code>, NDK的支持也是同样的道理.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://flutter.io/docs/get-started/flutter-for/android-devs" target="_blank" rel="noopener">https://flutter.io/docs/get-started/flutter-for/android-devs</a></p>]]></content>
    
    <summary type="html">
    
      Android程序员 Flutter学习笔记 Flutter self-learning notes as an android developer
    
    </summary>
    
      <category term="Flutter" scheme="http://talentprince.github.io/categories/Flutter/"/>
    
    
      <category term="Android" scheme="http://talentprince.github.io/tags/Android/"/>
    
      <category term="Flutter" scheme="http://talentprince.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>如何正确使用Espresso来测试你的Android程序</title>
    <link href="http://talentprince.github.io/2018/09/30/How-to-correctly-use-android-espresso-to-test-your-UI/"/>
    <id>http://talentprince.github.io/2018/09/30/How-to-correctly-use-android-espresso-to-test-your-UI/</id>
    <published>2018-09-30T02:12:48.000Z</published>
    <updated>2020-06-22T09:44:59.477Z</updated>
    
    <content type="html"><![CDATA[<p>UI测试在Android平台上一直都是一个令人头痛的事情, 由于大家平时用的很少, 加之很多文档的缺失, 如果很多东西从头摸索,势必踩坑无数.</p><p>自Android24正式淘汰掉了<a href="https://developer.android.com/reference/android/test/InstrumentationTestCase" target="_blank" rel="noopener">InstrumentationTestCase</a>(位于android.test包), 推出<a href="https://developer.android.com/training/testing/espresso/" target="_blank" rel="noopener">Espresso</a>(位于android.support.test包), Google一直致力于降低UI测试的门槛.</p><p>了解测试金字塔的同学可能知道,UI测试属于功能测试(Functional Test), 或者按照其他的划分也属于集成测试(Integration Test), Google推出了<a href="https://developer.android.com/training/testing/ui-automator" target="_blank" rel="noopener">UIAutomator</a>与<a href="https://developer.android.com/training/testing/espresso" target="_blank" rel="noopener">Espresso</a>来分别处理跨App间的测试(<a href="https://zh.wikipedia.org/wiki/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">黑盒测试</a>)以及App内的测试(<a href="https://zh.wikipedia.org/wiki/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">白盒测试</a>).</p><p>测试步骤类似,分为:</p><ul><li>查找元素</li><li>触发行为</li><li>检测结果</li></ul><p>本文分为三部分, 第一部分简单介绍如何使用Espresso, 第二部分分析如何处理诸如异步, 依赖注入, 程序结构对UI测试的影响以及提供解决办法, 第三部分提供源码以及一些Reference的地址.</p><a id="more"></a><h2 id="Part-I"><a href="#Part-I" class="headerlink" title="Part I"></a>Part I</h2><h3 id="如何配置"><a href="#如何配置" class="headerlink" title="如何配置"></a>如何配置</h3><p>1.需要在gradle的dependencies里添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.2&apos;</span><br><span class="line">androidTestImplementation &apos;com.android.support.test:runner:1.0.2&apos;</span><br><span class="line">androidTestImplementation &apos;com.android.support.test:rules:1.0.2&apos;</span><br></pre></td></tr></table></figure><p>2.在gradle的android.defaultConfig里指定TestRunner</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br></pre></td></tr></table></figure><p>3.书写测试文件,通过<code>AndroidJUnit4</code>来跑即可,使用Activity Rule来启动你的Activity.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Rule</span><br><span class="line">@JvmField</span><br><span class="line">var activityTestRule: ActivityTestRule&lt;MainActivity&gt; = ActivityTestRule&lt;MainActivity&gt;()</span><br></pre></td></tr></table></figure><p>4.添加测试.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onView(withText(&quot;Hello world!&quot;)).check(matches(isDisplayed()));</span><br></pre></td></tr></table></figure><p>5.运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew connectedAndroidTest</span><br></pre></td></tr></table></figure><p>或在IDE中进行运行.</p><p>以上步骤写的比较简略, 如果第一次使用, 可参考<a href="https://developer.android.com/training/testing/espresso/setup" target="_blank" rel="noopener">官方文档</a>.</p><h2 id="Part-II"><a href="#Part-II" class="headerlink" title="Part II"></a>Part II</h2><h3 id="貌似已经会了-打钩-x"><a href="#貌似已经会了-打钩-x" class="headerlink" title="貌似已经会了, 打钩[x]?"></a>貌似已经会了, 打钩[x]?</h3><p>对于简单的UI其实上面的5步已经完全足够,  这也是Espresso好用的地方,  将UI测试写的跟普通的Unit Test一样简单.</p><p>但是随着你的UI变得复杂, 很多问题接踵而至.</p><p>其根本原因在于, Espresso系统在处理内置UI渲染(包括WebView)的异步操作都没有问题, 它会等待页面的渲染与加载, 而你自己如果有异步逻辑, 可能测试进程不会等待其完成而结束, 导致测试失败.</p><p>而采用Unit Test将无论是RxJava的Scheduler或者是Excutor替换成同一个线程的方法没法在UI Test中使用. 原因是UI操作只能在创建它的线程使用(UI 线程), 而如果你用了网络或者Room之类的数据库, 它又无法在UI线程使用, 相互矛盾, 进退两难.</p><p>所以这个时候就需要使用Espresso提供的<a href="https://developer.android.com/training/testing/espresso/idling-resource" target="_blank" rel="noopener">IdleResource</a>, 来通知系统是否Idle或者Busy.</p><h3 id="什么时候该使用IdleResource"><a href="#什么时候该使用IdleResource" class="headerlink" title="什么时候该使用IdleResource"></a>什么时候该使用IdleResource</h3><p>其实IdleResource的官方文档里面有指出, 如果你的测试里有使用:</p><ul><li>Thread.sleep()</li><li>Retry</li><li>CountDown …</li></ul><p>来保证你的测试工作正常, 那么意味着你应该使用IdleResource了.</p><p>或许刚刚接触Espresso的你可能还没有意识到问题所在, 还没有使用Work Around的方法来解决问题, 换个角度来说可能更好理解.</p><p>如果你所测试程序里有使用:</p><ul><li>Databinding</li><li>LiveData</li><li>通过非AsyncTask实现的异步操作</li><li>Fragment跳转</li><li>等等…</li></ul><p>那么就意味着你需要使用IdleResource来保证你的测试能顺利进行, 否则Test Case可能在程序异步操作未执行时就已经关闭了.</p><h3 id="如何使用IdleResource"><a href="#如何使用IdleResource" class="headerlink" title="如何使用IdleResource"></a>如何使用IdleResource</h3><p><a href="https://developer.android.com/training/testing/espresso/idling-resource" target="_blank" rel="noopener">IdleResource</a>的三个关键接口都非常Straigtforward.</p><p>1.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun getName(): String</span><br></pre></td></tr></table></figure></p><p>每一个IdleResource都应该有唯一的Name来注册到系统里, 不能重复.</p><p>2.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun isIdleNow(): Boolean</span><br></pre></td></tr></table></figure></p><p>Espresso会从UI线程调用, 通过这个方法来获得是否进入Idle状态.</p><p>3.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun registerIdleTransitionCallback(callback: IdlingResource.ResourceCallback)</span><br></pre></td></tr></table></figure></p><p>当该IdleResource被使用时, Espresso会注册该callback, 当background job执行完毕后, 需要调用callback.onTransitionToIdle()通知(<strong>如果已经是Idle状态, 调用也不影响, 所以很多简单的实现都是将这个调用放在isIdleNow中, 判断已经idle就调用, 虽然google的best practice里说不要这样</strong>), 该调用会通知UI线程, 并可以在任何线程调用.</p><p>在使用IdleResource的时候, 通常是通过注册Rule来驱动的, 这个就需要继承<code>TestWatcher</code>.</p><p>复写它的starting与finished方法, 通过<code>IdlingRegistry.getInstance().register</code>与<code>IdlingRegistry.getInstance().unregister</code>来注册/反注册IdleReource, 当然可能需要在finished的时候drain掉所有在运行的Task.</p><p>给一个简单的例子把.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class SampleIdleResourceRule : TestWatcher() &#123;</span><br><span class="line">    private val idlingResource: IdlingResource = xxx</span><br><span class="line">    </span><br><span class="line">    override fun starting(description: Description?) &#123;</span><br><span class="line">        IdlingRegistry.getInstance().register(idlingResource)</span><br><span class="line">        super.starting(description)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override fun finished(description: Description?) &#123;</span><br><span class="line">        //drain all the pending task here if needed.</span><br><span class="line">        IdlingRegistry.getInstance().unregister(idlingResource)</span><br><span class="line">        super.finished(description)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="举个IdleResource的例子吧"><a href="#举个IdleResource的例子吧" class="headerlink" title="举个IdleResource的例子吧."></a>举个IdleResource的例子吧.</h3><p>1.使用LiveData等Archtecture Component组件</p><p>我们知道LiveData是一个订阅系统, 是必涉及后台线程, 比较方便的是它自己内部已经调用了IdleResource来增加/减少后台job, 所以直接使用系统提供的<a href="https://developer.android.com/reference/android/support/test/espresso/idling/CountingIdlingResource" target="_blank" rel="noopener">CountingTaskExecutorRule</a>.</p><p>由于Resource name不能重复, 所以为了绕过这个检测, 需要继承<code>CountingTaskExecutorRule</code>来复写getName.</p><p>具体可以参考google的<a href="https://github.com/googlesamples/android-architecture-components/blob/1c91038b55d52fe1006b3b4c6436003f4da29c4f/GithubBrowserSample/app/src/androidTest/java/com/android/example/github/util/TaskExecutorWithIdlingResourceRule.kt#L31" target="_blank" rel="noopener">TaskExecutorWithIdlingResourceRule</a>.</p><p>Google还提供了Databinding的Rule, 可以参考.</p><p>2.等待弹框结束</p><p>一般情况下我们使用DialogFragment来弹框, 如果我们去check一些text被dialog遮挡, 就必须等待其消失后在进行检查.</p><p>这时我们可以通过<code>findFragmentByTag</code>来检测该弹框是否dismiss.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class DialogIdlingResource(</span><br><span class="line">        private val manager: FragmentManager, </span><br><span class="line">        private val tag: String) : IdlingResource &#123;</span><br><span class="line">    private var resourceCallback: IdlingResource.ResourceCallback? = null</span><br><span class="line"></span><br><span class="line">    override fun getName(): String = &quot;xxx&quot;</span><br><span class="line"></span><br><span class="line">    override fun registerIdleTransitionCallback(callback: IdlingResource.ResourceCallback?) &#123;</span><br><span class="line">        resourceCallback = callback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun isIdleNow(): Boolean &#123;</span><br><span class="line">        val idle = manager.findFragmentByTag(tag) == null</span><br><span class="line">        if (idle) &#123;</span><br><span class="line">            resourceCallback?.onTransitionToIdle()</span><br><span class="line">        &#125;</span><br><span class="line">        return idle</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.Delegate Executors/Scheduler</p><p>如果有异步处理逻辑, 大多都位于Repository/ViewModel层, 这部分会被Mock, 但也有一些UI逻辑可能会用到Excecutor. 如RecyclerView的DiffUtil, 需要传入一个Executor来做异步Diff, 这时我们就需要一个Excecutor的IdlingResource, 并把它里面的Delegate赋值给UI.</p><p>这部分可以参考Google GithubBrowser Sample的<a href="https://github.com/googlesamples/android-architecture-components/blob/1c91038b55d52fe1006b3b4c6436003f4da29c4f/GithubBrowserSample/app/src/androidTest/java/com/android/example/github/util/CountingAppExecutorsRule.kt#L32" target="_blank" rel="noopener">CountingAppExecutorsRule</a>.</p><h3 id="应该怎么测试-需要测试什么"><a href="#应该怎么测试-需要测试什么" class="headerlink" title="应该怎么测试, 需要测试什么?"></a>应该怎么测试, 需要测试什么?</h3><p>虽然Espresso测试是集成测试,  但是由于涉及到异步逻辑导致Test Case无法按照预期进行的问题时而存在, 且有时候无法通过IdlingResource来解决.</p><p>比如涉及到多个Fragment的跳转, 就会发生在Fragment未打开时Test Case就挂掉的情况.</p><p>再比如使用RxJava, 在Espresso3.x + RxJava2.x的情况下, 即便将Scheduler代理给IdlingResource也无法保证整个业务流程完整走下来, 异步操作仍无法完整运行, 具体问题可参考Jake大神RxIdler的<a href="https://github.com/square/RxIdler" target="_blank" rel="noopener">Issue</a>.</p><p>所以测试起来就有一些原则需要遵守, 才能保证整个流程的可测性.</p><ul><li>最好对每一个Fragment进行单独测试, Mock所依赖的部分, 如网络, 数据模块, 如果涉及Fragment跳转逻辑, 通过继承来复写进行测试.</li><li>如果使用了RxJava, 需要将其封装在Repository或者Presenter/ViewModel中进行整体的Mock.</li><li>如果使用了Dagger2.android进行自动注入, 最好对测试部分自定义TestRunner提供一个空的Application来Disable注入, 对所测试Fragment注入对象进行手动赋值.</li><li>如果Activity有注入逻辑, 最好将其解耦到Fragment, 因为Espresso的Activity是通过ActivityRule来启动, 无法进行直接手动注入.</li><li>如果无法Move到Fragment, 或者不想… 那就需要在测试里构建自己的Dagger Component, 对于使用Dagger2.android自动注入的, 还需要手动创建Fake的DispatchingAndroidInjector完成手动注入.</li><li>如果未使用Dagger2.android, 通过AndroidInjector来注入的, 可以忽略与注入相关的item.</li></ul><h3 id="能再讲的仔细一些吗"><a href="#能再讲的仔细一些吗" class="headerlink" title="能再讲的仔细一些吗?"></a>能再讲的仔细一些吗?</h3><p>1.单独测试Fragment的好处是可以解耦Fragment之间的跳转, 往往Fragment都是UI流程中的一个环节, 当逻辑完成时会跳向下一Fragment. 可以创建一个空Activity来专门用于显示该Fragment, 并且在测试的setUp里commit该Fragment.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class TestActivity &#123;</span><br><span class="line">    fun showFragment()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RunWith(AndroidJUnit4::class)</span><br><span class="line">class XXXFragmentTest &#123;</span><br><span class="line">    @Rule</span><br><span class="line">    @JvmField</span><br><span class="line">    val activityRule = ActivityTestRule(XXXFragment::class.java)</span><br><span class="line">    </span><br><span class="line">    @Before</span><br><span class="line">    fun init() &#123;</span><br><span class="line">        //1. init fragment</span><br><span class="line">        //2. assign mock data</span><br><span class="line">        activityRule.showFragment(xxx)  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    fun testXXX() &#123;</span><br><span class="line">        xxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.由于常常会需要继承需要测试的Fragment来复写一些类, 对于使用Dagger.android自动注入的, 该子Fragment又未通过<code>@ContributesAndroidInjector</code>进行注册, 往往需要自定义TestRunner, 然后手动注入Fragment.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class CustomTestRunner : AndroidJUnitRunner() &#123;</span><br><span class="line">    override fun newApplication(...) &#123;</span><br><span class="line">        return ...TestApp:class...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        testInstrumentationRunner &quot;xxx.CustomTestRunner&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestApp : Application() &#123;&#125;</span><br><span class="line"></span><br><span class="line">@RunWith(AndroidJUnit4::class)</span><br><span class="line">class XXXFragmentTest &#123;</span><br><span class="line">    //activity rule</span><br><span class="line">    ...</span><br><span class="line">    val testFragment = TestFragment()</span><br><span class="line">    </span><br><span class="line">    @Before</span><br><span class="line">    fun init() &#123;</span><br><span class="line">        testFragment.xxx = mockXXX</span><br><span class="line">        ...</span><br><span class="line">        activityRule.activity.showFragment(testFragment)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    fun testXXX() &#123;</span><br><span class="line">        onView...check(...)</span><br><span class="line">        assertTrue(testFragment.isXXXShow)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class TestFragment : XXXFragment() &#123;</span><br><span class="line">        var isXXXShow = false</span><br><span class="line">        override fun showXXX() &#123;</span><br><span class="line">            isXXXShow = true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.如果Activity有注入逻辑与业务逻辑, 并且不想抽到Fragment中去, 则需要创建Fake的Injector保证可以完成注入, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun createFakeInjector(block: T.() -&gt; Unit): DispatchingAndroidInjector&lt;Activity&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RunWith(AndroidJUnit4::class)</span><br><span class="line">class XXXActivityTest &#123;</span><br><span class="line">    @Rule</span><br><span class="line">    @JvmField</span><br><span class="line">    var activityRule = object : ActivityTestRule&lt;XXX&gt;(XXX::class.java) &#123;</span><br><span class="line">       val app = ...get application</span><br><span class="line">       app.dispatchingAndroidInjector = createFakeInjector&lt;XXX&gt;() &#123;</span><br><span class="line">           //手动注入</span><br><span class="line">           xxx =  mockXXX</span><br><span class="line">           `when`(xxx).thenReturn(xxx)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.为了支持需要通过继承Fragment来完成测试的Case, 还需要对测试模块创建自己的Component来注册从而进行Fake Injector的创建 (类似3, 只是Application/Activity可能为Test版本).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Grale</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    kaptAndroidTest &apos;com.google.dagger:dagger-android-processor:2.X&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Component(modules = [</span><br><span class="line">    AndroidInjectionModule::class,</span><br><span class="line">    AndroidSupportInjectionModule::class,</span><br><span class="line">    ...主App所注册的所有Module,</span><br><span class="line">    TestActivityModule::class])</span><br><span class="line">interface TestCompnent &#123;</span><br><span class="line">    fun inject(xxx: XXX)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Module</span><br><span class="line">abstract class TestActivityModule &#123;</span><br><span class="line">  //通过`ContributesAndroidInjector`注册你的TestActivity, 以及TestFragment  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestApp : Application(), HasActivityInjector &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    lateinit var injector: DispatchingAndroidInjector&lt;Activity&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestActivity : Activity(), HasSupportFragmentInjector &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    lateinit var injector: DispatchingAndroidInjector&lt;Fragment&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Part-III"><a href="#Part-III" class="headerlink" title="Part III"></a>Part III</h2><h3 id="如果还不是很明白可以查看代码"><a href="#如果还不是很明白可以查看代码" class="headerlink" title="如果还不是很明白可以查看代码"></a>如果还不是很明白可以查看代码</h3><p>Disable注入的在这里:<br><a href="https://github.com/googlesamples/android-architecture-components/tree/master/GithubBrowserSample" target="_blank" rel="noopener">Google的Demo GithubBrowser</a></p><p>跟注入相关的在这里:<br><a href="https://github.com/mengdd/DribbbleClient" target="_blank" rel="noopener">自己的Demo</a></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://proandroiddev.com/activity-espresso-test-with-daggers-android-injector-82f3ee564aa4" target="_blank" rel="noopener">https://proandroiddev.com/activity-espresso-test-with-daggers-android-injector-82f3ee564aa4</a></li><li><a href="https://github.com/SabagRonen/dagger-activity-test-sample" target="_blank" rel="noopener">https://github.com/SabagRonen/dagger-activity-test-sample</a></li><li><a href="https://github.com/googlesamples/android-architecture-components/tree/master/GithubBrowserSample" target="_blank" rel="noopener">https://github.com/googlesamples/android-architecture-components/tree/master/GithubBrowserSample</a></li><li><a href="https://developer.android.com/training/testing/espresso/idling-resource" target="_blank" rel="noopener">https://developer.android.com/training/testing/espresso/idling-resource</a></li><li><a href="http://blog.sqisland.com/2015/07/espresso-wait-for-dialog-to-dismiss.html" target="_blank" rel="noopener">http://blog.sqisland.com/2015/07/espresso-wait-for-dialog-to-dismiss.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      如何使用Android Espresso测试UI
    
    </summary>
    
      <category term="Android" scheme="http://talentprince.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://talentprince.github.io/tags/Android/"/>
    
      <category term="Espresso" scheme="http://talentprince.github.io/tags/Espresso/"/>
    
      <category term="UI Automation Test" scheme="http://talentprince.github.io/tags/UI-Automation-Test/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #319</title>
    <link href="http://talentprince.github.io/2018/07/27/Android-Weekly-Issue-319/"/>
    <id>http://talentprince.github.io/2018/07/27/Android-Weekly-Issue-319/</id>
    <published>2018-07-27T01:00:01.000Z</published>
    <updated>2020-06-22T09:44:59.475Z</updated>
    
    <content type="html"><![CDATA[<p>July 22nd, 2018</p><h2 id="Android-Weekly-Issue-319"><a href="#Android-Weekly-Issue-319" class="headerlink" title="Android Weekly Issue #319"></a><a href="http://androidweekly.net/issues/issue-319" target="_blank" rel="noopener">Android Weekly Issue #319</a></h2><p>本期内容包括MotionLayout如何做动画的介绍,Kotlin when完备性的实现,以及如何Move一些Gradle的东西到Kotlin,还包括一个比较好的Kotlin Test库,以及如何用LiveData整合不同数据源,还有一个轻量级的Kotlin Eventbus的推荐.</p><p>Lib部分有Jake大神的Android与Chrome Extension的android sdk查看器,还有一个android黄瓜测试生成工具等…</p><a id="more"></a><h1 id="NOTES"><a href="#NOTES" class="headerlink" title="NOTES"></a>NOTES</h1><h2 id="Creating-Animations-With-MotionLayout-for-Android"><a href="#Creating-Animations-With-MotionLayout-for-Android" class="headerlink" title="Creating Animations With MotionLayout for Android "></a><a href="https://code.tutsplus.com/tutorials/creating-animations-with-motionlayout-for-android--cms-31497" target="_blank" rel="noopener">Creating Animations With MotionLayout for Android </a></h2><p>通过定义MotionLayout布局xml,指定定义好的MotionScene就可以完成动画.</p><p>MotionScene内可以定义ConstraintSet指定位置,然后定义Transition指定起始Constraint,也可以指定KeyFrameSet包含多个KeyPostion,或者KeyCircle.</p><p>还可以绑定事件,OnClick,OnSwipe来启动动画.</p><h2 id="When-is-“when”-exhaustive"><a href="#When-is-“when”-exhaustive" class="headerlink" title="When is “when” exhaustive? "></a><a href="https://medium.com/@ataulm/til-when-is-when-exhaustive-31d69f630a8b" target="_blank" rel="noopener">When is “when” exhaustive? </a></h2><p>为了防止大家写when的时候忘记写else导致问题,作者想出来了一些好办法.</p><p>如when {}.let{}或者扩展方法返回自己.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val &lt;T&gt; T.exhaustive: T</span><br><span class="line">    get() = this</span><br></pre></td></tr></table></figure><h2 id="Android-Studio-Taming-the-interface"><a href="#Android-Studio-Taming-the-interface" class="headerlink" title="Android Studio - Taming the interface "></a><a href="https://jeroenmols.com/blog/2018/07/16/androidstudioshortcuts3/" target="_blank" rel="noopener">Android Studio - Taming the interface </a></h2><p>AS的一些快捷键,有一些很多人没注意到的,如小窗口的大小调整,等等.配有动图.</p><h2 id="Becoming-Google-Certified-Associate-Android-Developer"><a href="#Becoming-Google-Certified-Associate-Android-Developer" class="headerlink" title="Becoming Google Certified Associate Android Developer "></a><a href="https://medium.com/@sodiqOladeni/becoming-google-certified-associate-android-developer-907bdb61d79f" target="_blank" rel="noopener">Becoming Google Certified Associate Android Developer </a></h2><p>Google推出了149美元考助理安卓工程师的认证,24小时完成一个project并提交,如果通过在线10分钟回答5个问题,就可以轻松通过…</p><p>如果不通过可以免费补考,如果还不过那就得交钱了…</p><p>只考安卓四大组件,不考语言知识,因为安卓更重要的是框架组件..</p><h2 id="Maintainable-Architecture-–-Daily-Forecast"><a href="#Maintainable-Architecture-–-Daily-Forecast" class="headerlink" title="Maintainable Architecture – Daily Forecast "></a><a href="https://blog.stylingandroid.com/maintainable-architecture-daily-forecast/" target="_blank" rel="noopener">Maintainable Architecture – Daily Forecast </a></h2><p>系列最后一节,主要讲了如何注入你的ViewModel,还给出了demo地址.</p><h2 id="Cloud-Continuous-Integration-on-Android-with-Kotlin-Project"><a href="#Cloud-Continuous-Integration-on-Android-with-Kotlin-Project" class="headerlink" title="Cloud Continuous Integration on Android with Kotlin Project "></a><a href="https://proandroiddev.com/cloud-continuous-integration-on-android-with-kotlin-project-8d6f12cbf0c4" target="_blank" rel="noopener">Cloud Continuous Integration on Android with Kotlin Project </a></h2><p>文章介绍了如何大家CI,本篇作者使用的是Travis,并且添加了Jacoco生成覆盖率报告,并且push到Codecov.io上.</p><p>最后当然不要忘记加高大上的badge到你的README…</p><h2 id="Moving-Your-Gradle-Build-Scripts-to-Kotlin"><a href="#Moving-Your-Gradle-Build-Scripts-to-Kotlin" class="headerlink" title="Moving Your Gradle Build Scripts to Kotlin "></a><a href="https://pspdfkit.com/blog/2018/moving-your-gradle-build-scripts-to-kotlin/" target="_blank" rel="noopener">Moving Your Gradle Build Scripts to Kotlin </a></h2><p>本篇文章实际上是个标题党,与之前介绍的用Kotlin DSL写gradle的<a href="https://antonioleiva.com/kotlin-dsl-gradle/" target="_blank" rel="noopener">文章</a>不太一样.</p><p>这篇文章只是自己定义了一个plugin,并且可以在自己的buildSrc里面用kotlin声明一些变量, 然后在gradle里面去调用,比如说dependencies的版本.</p><p>之前的那篇文章使用了gradle 4.5.1以上的新特性,然后将gradle后面加上后缀kts即可,当然在buildSrc里面声明变量的同时还需要引用<code>kotlin-dsl</code>插件.这样你的kts文件里就可以写成kotlin dsl风格了.这是题外话…可以查看#283的文章.</p><h2 id="Data-Driven-Testing-with-KotlinTest"><a href="#Data-Driven-Testing-with-KotlinTest" class="headerlink" title="Data Driven Testing with KotlinTest "></a><a href="https://proandroiddev.com/data-driven-testing-with-kotlintest-a07ac60e70fc" target="_blank" rel="noopener">Data Driven Testing with KotlinTest </a></h2><p>作者推荐一个叫<a href="https://github.com/kotlintest/kotlintest" target="_blank" rel="noopener">KotlinTest</a>的库可以提供很多有趣的assert方法.</p><p>来支持他自己的Data driven test的理念,来做数据的对比.</p><p>如forAll可以添加很多组数据,然后通过shouldBe进行判断.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">forAll(</span><br><span class="line">    row(...)</span><br><span class="line">) &#123; ... -&gt;</span><br><span class="line">   ... shouldBe ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reactive-patterns-using-Transformations-and-MediatorLiveData"><a href="#Reactive-patterns-using-Transformations-and-MediatorLiveData" class="headerlink" title="Reactive patterns using Transformations and MediatorLiveData "></a><a href="https://medium.com/google-developers/livedata-beyond-the-viewmodel-reactive-patterns-using-transformations-and-mediatorlivedata-fda520ba00b7" target="_blank" rel="noopener">Reactive patterns using Transformations and MediatorLiveData </a></h2><p>作者介绍了如何用MediatorLiveData+Transformations来实现RxJava类似于zip的功能来进行combine不同的DataSource.</p><p>在这之前作者介绍了使用LiveData过程中的一些注意事项以及解决办法.</p><p>如是否去Share一个LiveData需要值得考虑它会导致的问题,使用MediatorLiveData添加外部source会导致泄露,使用switchMap去解决问题的时候也一定注意需要在构造的时候用,因为map/switchMap都会创建新的LiveData,等等.</p><p>最后一句话写到,如果使用了AutoDisposal的Rxjava第三方控件,就没必须这么用LiveData了.</p><h2 id="Delegate-your-Lifecycle-to-Kotlin"><a href="#Delegate-your-Lifecycle-to-Kotlin" class="headerlink" title="Delegate your Lifecycle to Kotlin "></a><a href="https://blog.blueapron.io/delegate-your-lifecycle-to-kotlin-17c1d0d876c9" target="_blank" rel="noopener">Delegate your Lifecycle to Kotlin </a></h2><p>为了防止一些Activity或者Fragment的变量有跟生命周期同等的初始化与销毁,使用Kotlin的<code>by</code>来交给代理来改变它的Value,代理通过很多方式都可以监听生命周期,如LifecycleObserver,或者RxLifeCycle,来实现setValue.</p><h2 id="KDispatcher-simple-and-light-weight-event-bus-for-Kotlin"><a href="#KDispatcher-simple-and-light-weight-event-bus-for-Kotlin" class="headerlink" title="KDispatcher simple and light-weight event bus for Kotlin "></a><a href="https://medium.com/@sphc/kdispatcher-simple-and-light-weight-event-bus-for-kotlin-e0fa4aaea1c7" target="_blank" rel="noopener">KDispatcher simple and light-weight event bus for Kotlin </a></h2><p>一个Kotlin的轻量EventBus,而且是与平台无关的,backend也可以用.</p><h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="wearfaceutils"><a href="#wearfaceutils" class="headerlink" title="wearfaceutils "></a><a href="https://github.com/purposebakery/wearfaceutils" target="_blank" rel="noopener">wearfaceutils </a></h2><p>Android Wear 表盘</p><h2 id="pickle"><a href="#pickle" class="headerlink" title="pickle "></a><a href="https://github.com/fourlastor/pickle" target="_blank" rel="noopener">pickle </a></h2><p>Android 黄瓜测试代码生成器.</p><h2 id="kotlintest"><a href="#kotlintest" class="headerlink" title="kotlintest "></a><a href="https://github.com/kotlintest/kotlintest" target="_blank" rel="noopener">kotlintest </a></h2><p>一个kotlin test framework, 可以写出 shouldBe should之类的assert.</p><h2 id="SdkSearch"><a href="#SdkSearch" class="headerlink" title="SdkSearch "></a><a href="https://github.com/JakeWharton/SDKSearch" target="_blank" rel="noopener">SdkSearch </a></h2><p>Jake Wharton大哥的android app跟chrome扩展,查询android sdk的.</p><h2 id="ketro"><a href="#ketro" class="headerlink" title="ketro "></a><a href="https://smilecs.github.io/ketro/" target="_blank" rel="noopener">ketro </a></h2><p>Retrofit + LiveData的组合.</p><h2 id="KDispatcher"><a href="#KDispatcher" class="headerlink" title="KDispatcher "></a><a href="https://github.com/Rasalexman/KDispatcher" target="_blank" rel="noopener">KDispatcher </a></h2><p>Kotlin轻量级Event Bus</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Kotlin" scheme="http://talentprince.github.io/tags/Kotlin/"/>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin Delegate" scheme="http://talentprince.github.io/tags/Kotlin-Delegate/"/>
    
      <category term="Kotlin Test" scheme="http://talentprince.github.io/tags/Kotlin-Test/"/>
    
      <category term="Gradle" scheme="http://talentprince.github.io/tags/Gradle/"/>
    
      <category term="LiveData" scheme="http://talentprince.github.io/tags/LiveData/"/>
    
      <category term="MotionLayout" scheme="http://talentprince.github.io/tags/MotionLayout/"/>
    
      <category term="Shortcut" scheme="http://talentprince.github.io/tags/Shortcut/"/>
    
      <category term="Kotlin Eventbus" scheme="http://talentprince.github.io/tags/Kotlin-Eventbus/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #318</title>
    <link href="http://talentprince.github.io/2018/07/15/Android-Weekly-Issue-318/"/>
    <id>http://talentprince.github.io/2018/07/15/Android-Weekly-Issue-318/</id>
    <published>2018-07-15T01:00:01.000Z</published>
    <updated>2020-06-22T09:44:59.474Z</updated>
    
    <content type="html"><![CDATA[<p>July 15th, 2018</p><h2 id="Android-Weekly-Issue-318"><a href="#Android-Weekly-Issue-318" class="headerlink" title="Android Weekly Issue #318"></a><a href="http://androidweekly.net/issues/issue-318" target="_blank" rel="noopener">Android Weekly Issue #318</a></h2><p>本期内容包括Jetpack NavigationUI的介绍, FAT AAR的讨论, Realm迁移到Kotlin的方案,以及如何通过MVI+DataBinding来写程序.还包含DSL改造Android Dialog以及Kotlin scope function的详细解读.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="Android-Jetpack-NavigationUI"><a href="#Android-Jetpack-NavigationUI" class="headerlink" title="Android Jetpack - NavigationUI "></a><a href="https://proandroiddev.com/android-jetpack-navigationui-a7c9f17c510e" target="_blank" rel="noopener">Android Jetpack - NavigationUI </a></h2><p>文章简单介绍了如何将NavigationView或者BottomNavigation与JetPack提供的Navigation控件连起来,通过定义<navigation> xml来实现自动跳转.</navigation></p><h2 id="Why-We-Need-“fat”-AARs-for-Android-Libraries"><a href="#Why-We-Need-“fat”-AARs-for-Android-Libraries" class="headerlink" title="Why We Need “fat” AARs for Android Libraries "></a><a href="https://handstandsam.com/2018/07/13/why-we-need-fat-aars-for-android-libraries/" target="_blank" rel="noopener">Why We Need “fat” AARs for Android Libraries </a></h2><p>Gradle aar不支持打包所有依赖,一般情况下可以使用一个叫做FAT aar的插件,但是已经不更新了.</p><p>还可以通过transitive来让gradle下载依赖,但是作者的疑问在于如果依赖也是不公开的就没办法了.</p><p>Google已经表示3.3会考虑加这个功能.</p><h2 id="Maintainable-Architecture-–-UI-Layer"><a href="#Maintainable-Architecture-–-UI-Layer" class="headerlink" title="Maintainable Architecture – UI Layer "></a><a href="https://blog.stylingandroid.com/maintainable-architecture-five-day-forecast-ui-layer/" target="_blank" rel="noopener">Maintainable Architecture – UI Layer </a></h2><p>继上次介绍数据层,这篇文章介绍了一个Weather App如何使用MVVM实现UI Layer.</p><h2 id="Migrating-your-Realm-to-Kotlin-–-Blue-Apron-Engineering"><a href="#Migrating-your-Realm-to-Kotlin-–-Blue-Apron-Engineering" class="headerlink" title="Migrating your Realm to Kotlin – Blue Apron Engineering "></a><a href="https://blog.blueapron.io/migrating-your-realm-to-kotlin-ee0fa5fc29b" target="_blank" rel="noopener">Migrating your Realm to Kotlin – Blue Apron Engineering </a></h2><p>文章介绍了如何将Realm迁移到Kotlin.</p><ul><li>为了不想让主键为空导致Kotlin nullable变量使用起来需要进行let之类的null check,所以给与初始化值,但是一定要加Migration逻辑保证数据库迁移正确.</li><li>可以通过一些Helper function加!!来避免Null check</li><li>Extension function包装关键字<code>in</code>,因为它是kotlin的关键字.</li></ul><h2 id="Model-View-Intent-amp-Data-Binding"><a href="#Model-View-Intent-amp-Data-Binding" class="headerlink" title="Model-View-Intent &amp; Data Binding "></a><a href="https://proandroiddev.com/model-view-intent-data-binding-39c7a6a6512f" target="_blank" rel="noopener">Model-View-Intent &amp; Data Binding </a></h2><p>作者通过一个登陆页面介绍了如何使用了MVI+DataBinding,适合初步了解MVI的机制以及Reducer的思想.</p><h2 id="Social-Network-Integration-on-Android"><a href="#Social-Network-Integration-on-Android" class="headerlink" title="Social Network Integration on Android "></a><a href="https://www.raywenderlich.com/191933/social-network-integration-on-android" target="_blank" rel="noopener">Social Network Integration on Android </a></h2><p>作者介绍了如何使用诸如FB Twitter这样的social media sdk来实现自己app内的登录与分享.</p><h2 id="Kotlin-Demystified-What-are-‘scope-functions’-and-why-are-they-special"><a href="#Kotlin-Demystified-What-are-‘scope-functions’-and-why-are-they-special" class="headerlink" title="Kotlin Demystified: What are ‘scope functions’ and why are they special? "></a><a href="https://medium.com/google-developers/kotlin-demystified-scope-functions-57ca522895b1" target="_blank" rel="noopener">Kotlin Demystified: What are ‘scope functions’ and why are they special? </a></h2><p>作者介绍了Kotlin里面的scope functions,其实就是let/run/with/apply/also.</p><p>作者的总结比较复杂,其实有一个比较简单的图可以清楚了解之间的关系.</p><p>如果你需要返回本身,就使用apply或者also,其区别就是使用this或者it.</p><p>如果你不需要返回本身,又想要做null判断,那就是用T.run或者let,当然区别也是this或者it.</p><p>如果你即不需要返回本身,又不用判断null,那就用with或者run,区别也是this或者it.</p><h2 id="Seedbank-—-discover-machine-learning-examples"><a href="#Seedbank-—-discover-machine-learning-examples" class="headerlink" title="Seedbank — discover machine learning examples "></a><a href="https://medium.com/tensorflow/seedbank-discover-machine-learning-examples-2ff894542b57" target="_blank" rel="noopener">Seedbank — discover machine learning examples </a></h2><p>可以在线的试一试Machine Learning</p><h2 id="From-Java-Builders-to-Kotlin-DSLs"><a href="#From-Java-Builders-to-Kotlin-DSLs" class="headerlink" title="From Java Builders to Kotlin DSLs "></a><a href="https://kotlinexpertise.com/java-builders-kotlin-dsls/" target="_blank" rel="noopener">From Java Builders to Kotlin DSLs </a></h2><p>教大家如何把Dialog Builder改造成Kotlin DSL,使用起来非常炫酷.</p><p>其实大家也都清楚了,就是通过Extension Function.</p><p>具体可以去看看作者的对比,DSL化后使用起来跟CSS一样,花括号套起来就实现了Dialog.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">draw &#123;</span><br><span class="line">    drawerLayout = xxxx</span><br><span class="line">    onItemClick &#123;</span><br><span class="line">        xxxxx</span><br><span class="line">    &#125;</span><br><span class="line">    onOpen &#123;</span><br><span class="line">        Toast.xxxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="android-face-detector"><a href="#android-face-detector" class="headerlink" title="android-face-detector "></a><a href="https://github.com/husaynhakeem/android-face-detector" target="_blank" rel="noopener">android-face-detector </a></h2><p>实时面部识别的lib,使用的Firebase ML kit.</p><h2 id="UnderlinePageIndicator"><a href="#UnderlinePageIndicator" class="headerlink" title="UnderlinePageIndicator "></a><a href="https://github.com/dcampogiani/UnderlinePageIndicator" target="_blank" rel="noopener">UnderlinePageIndicator </a></h2><p>类似于系统design的TabLayout那种效果.</p><h2 id="Seedbank"><a href="#Seedbank" class="headerlink" title="Seedbank "></a><a href="https://tools.google.com/seedbank/" target="_blank" rel="noopener">Seedbank </a></h2><p>在线测试ML的.</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="Realm" scheme="http://talentprince.github.io/tags/Realm/"/>
    
      <category term="Kotlin DSL" scheme="http://talentprince.github.io/tags/Kotlin-DSL/"/>
    
      <category term="MVI" scheme="http://talentprince.github.io/tags/MVI/"/>
    
      <category term="DataBinding" scheme="http://talentprince.github.io/tags/DataBinding/"/>
    
      <category term="Jetpack" scheme="http://talentprince.github.io/tags/Jetpack/"/>
    
      <category term="Navigation" scheme="http://talentprince.github.io/tags/Navigation/"/>
    
      <category term="AAR" scheme="http://talentprince.github.io/tags/AAR/"/>
    
      <category term="Scope Functions" scheme="http://talentprince.github.io/tags/Scope-Functions/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #317</title>
    <link href="http://talentprince.github.io/2018/07/08/Android-Weekly-Issue-317/"/>
    <id>http://talentprince.github.io/2018/07/08/Android-Weekly-Issue-317/</id>
    <published>2018-07-08T11:00:01.000Z</published>
    <updated>2020-06-22T09:44:59.474Z</updated>
    
    <content type="html"><![CDATA[<p>July 8th, 2018</p><h2 id="Android-Weekly-Issue-317"><a href="#Android-Weekly-Issue-317" class="headerlink" title="Android Weekly Issue #317"></a><a href="http://androidweekly.net/issues/issue-317" target="_blank" rel="noopener">Android Weekly Issue #317</a></h2><p>本期主要内容包括”重磅”的Udacity放弃RN(其实是因为他们RN写的那个Feature不要了),还包括如七部使用Google Page Lib,如何用Room设计与创建可维护的数据库等Code Guide的文章,以及Android P字体渲染,放大镜,Google新版Universal Music Play Sample,还有Retrofit如何工作,如何通过Kotlin Extension Generation来改善Dagger Butterknife使用体验,等等.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="State-of-Kotlin"><a href="#State-of-Kotlin" class="headerlink" title="State of Kotlin "></a><a href="https://pusher.com/state-of-kotlin" target="_blank" rel="noopener">State of Kotlin </a></h2><p>Kotlin状态的一些列数据,包括它的使用率,渗透率,在项目中的应用率等多种多样的数据,并且可以订阅.</p><p>一切数据表明,Kotlin在过去的一年中发展迅速,使用量Double,并且好评如潮.</p><h2 id="How-does-Retrofit-work"><a href="#How-does-Retrofit-work" class="headerlink" title="How does Retrofit work "></a><a href="https://medium.com/@theneckmaster/how-does-retrofit-work-6ecad1bb683b" target="_blank" rel="noopener">How does Retrofit work </a></h2><p>文章讲述了Retrofit如何工作,实际上是通过Proxy而非Processor去生成代码来实现的.文章表示在运行速度与编译速度上的Compromise是一个值得思考的问题.</p><h2 id="Exploring-Android-P-Magnifier"><a href="#Exploring-Android-P-Magnifier" class="headerlink" title="Exploring Android P: Magnifier "></a><a href="https://medium.com/@hitherejoe/exploring-android-p-magnifier-ddfd06bdecbe" target="_blank" rel="noopener">Exploring Android P: Magnifier </a></h2><p>Android P提供了放大镜功能,并且TextView默认就实现了.<br>国内用户应该不是很陌生,几年前国内的一些大Android浏览器厂商在WebView里面也有类似的功能,不过主要是Android copy了 iOS的默认属性…</p><h2 id="Tracking-Android-app-metrics"><a href="#Tracking-Android-app-metrics" class="headerlink" title="Tracking Android app metrics "></a><a href="https://medium.com/@emmaguy/tracking-android-app-metrics-431cbea2113d" target="_blank" rel="noopener">Tracking Android app metrics </a></h2><p>文章介绍了CI上使用<a href="http://www.stathat.com/manual/start" target="_blank" rel="noopener">StatHat</a>上传APK的一些数据,比如size等,然后发现问题后通过<a href="http://danger.systems/ruby/" target="_blank" rel="noopener">Danger</a>给Github的PR上面发出报警.</p><p>这两个都是Ruby的应用.</p><h2 id="Kotlin-extension-function-generation"><a href="#Kotlin-extension-function-generation" class="headerlink" title="Kotlin extension function generation "></a><a href="https://medium.com/the-fabulous/kotlin-extension-methods-generation-15b5e6499dc8" target="_blank" rel="noopener">Kotlin extension function generation </a></h2><p>文章介绍了自己给Dagger与Butterknife写的ktx.</p><p>由于Dagger使用了生成文件进行注入,所以必须先编译一边才能通过Compiler生成文件,使用起来不便.</p><p>而ButterKnife使用了反射通过类名将自己Generate的辅助类在运行时创建,我们想消除这个反射.</p><p>这些原因都因为Processor只能生成文件,而无法改变已有文件.</p><p>所以作者使用了Kotlin Extension,首先在Lib里定义了一些Mock的接口,所以编译之前可以调用这些空实现.而在编译过程中,Compiler会生成对应的扩展方法,这样Dagger与Butterknife的问题都得以解决.</p><h2 id="What’s-new-for-text-in-Android-P"><a href="#What’s-new-for-text-in-Android-P" class="headerlink" title="What’s new for text in Android P "></a><a href="https://android-developers.googleblog.com/2018/07/whats-new-for-text-in-android-p.html?linkId=53827942" target="_blank" rel="noopener">What’s new for text in Android P </a></h2><p>Android P在TextView上下了狠功夫,增加了很多功能.</p><ul><li>PrecomputedText</li></ul><p>复杂字体Font在显示的时候实际上90%的时间都耗费在Measure计算上, 可以在后台线程通过<code>PrecomputedText</code>计算,然后在UI线程set</p><ul><li>Magnifier</li></ul><p>放大镜,上篇有提到.TextView自己默认实现了.</p><ul><li>Smart Linkify</li></ul><p>TextView方按选中可以通过Google的ML处理解析,提供可能相关的应用显示在Copy Cut Paste旁边,这一切都是通过<code>TextClassifier</code>实现的.</p><ul><li>Line Height &amp; Baseline Alignment</li></ul><p>提供了几个Attribute控制文字行高,以及baseline的top与bottom margin.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app:lineHeight</span><br><span class="line">app:firstBaselineToTopHeight</span><br><span class="line">app:lastBaselineToBottomHeight</span><br></pre></td></tr></table></figure><h2 id="React-Native-A-retrospective-from-the-mobile-engineering-team-at-Udacity"><a href="#React-Native-A-retrospective-from-the-mobile-engineering-team-at-Udacity" class="headerlink" title="React Native: A retrospective from the mobile-engineering team at Udacity"></a><a href="https://engineering.udacity.com/react-native-a-retrospective-from-the-mobile-engineering-team-at-udacity-89975d6a8102" target="_blank" rel="noopener">React Native: A retrospective from the mobile-engineering team at Udacity</a></h2><p>Udacity也放弃了RN,看了整片博客,感觉是他们可能只是为了凑个热度.</p><p>首先他们放弃的最主要原因是他们就一个Feature用了RN,而且当时也是因为它很独立,然后尝试了RN,现在这个Feature不用了,就删掉了.</p><p>然后他们的Android Dev细数了RN的十宗罪,但是都是我们大概能想到的.</p><p>比如实际上两个平台尤其android还是需要通过改code来修bug或者特殊需求,RN与native互通麻烦,RN导致CI编译长,包增大,启动变慢,RN文档欠缺,代码变更太快,自身bug多,不同设备不同表现,遇到问题常常需要改源码等等等等.</p><p>而之所以当初要使用,主要原因是为了省事,可惜后来发现还是费事了,所以以后再也不会考虑RN了.</p><h2 id="Automated-testing-will-set-your-engineering-team-free"><a href="#Automated-testing-will-set-your-engineering-team-free" class="headerlink" title="Automated testing will set your engineering team free "></a><a href="https://medium.com/azimolabs/automated-testing-will-set-your-engineering-team-free-a89467c40731" target="_blank" rel="noopener">Automated testing will set your engineering team free </a></h2><p>作者介绍了他们的应用是如何保证质量的,答案就是写测试,一般feature手工只测一遍,剩下就得自动化测试.</p><p>测试他们分为三类, UT是开发来写, 基本覆盖每一个函数,集成测试用Robolectric是QA负责来写,End to End test使用Espresso,Instrument Test等,整个跑下来不能超过三小时.</p><h2 id="Compiler-based-security-mitigations-in-Android-P"><a href="#Compiler-based-security-mitigations-in-Android-P" class="headerlink" title="Compiler-based security mitigations in Android P "></a><a href="https://android-developers.googleblog.com/2018/06/compiler-based-security-mitigations-in.html?linkId=53786461" target="_blank" rel="noopener">Compiler-based security mitigations in Android P </a></h2><p>从Android P开始基于Clang编译器做了很多优化,提升了稳定性,降低了被攻击的风险.</p><p>如CFI (Control Flow Integrity<br>) 技术,主要是增加了虚函数指针偏移指向地址的检查,如果发现指向非法地址就会终止编译.</p><p>IOS (Integer Overflow Sanitization<br>) 技术会检测有符号或者无符号的Integer在算法中溢出的问题,并且优化后运用到了一些库的编译中,如libui, libnl,libexif等…</p><h2 id="7-steps-to-implement-Paging-library-in-Android"><a href="#7-steps-to-implement-Paging-library-in-Android" class="headerlink" title="7 steps to implement Paging library in Android "></a><a href="https://proandroiddev.com/8-steps-to-implement-paging-library-in-android-d02500f7fffe" target="_blank" rel="noopener">7 steps to implement Paging library in Android </a></h2><p>文章介绍了如何使用Google Architecture Component里面的Page来实现分页加载.</p><p>总共有七步,关键是实现PageKeyedDataSource接口封装MutableLiveData. 实现DataSource.Factory将DataSource封装成Factory.</p><p>然后就可以通过LivePagedListBuilder来生成数据了.</p><h2 id="A-New-Universal-Music-Player"><a href="#A-New-Universal-Music-Player" class="headerlink" title="A New Universal Music Player "></a><a href="https://android-developers.googleblog.com/2018/06/a-new-universal-music-player.html?linkId=53783436" target="_blank" rel="noopener">A New Universal Music Player </a></h2><p>鉴于大家对Google的Universal Music Player的喜爱,推出V2版,采用Kotlin与MVVM的架构,但是还有一些小功能没有加进来.</p><h2 id="Publishing-your-library-to-jCenter-from-Android-Studio"><a href="#Publishing-your-library-to-jCenter-from-Android-Studio" class="headerlink" title="Publishing your library to jCenter from Android Studio "></a><a href="https://android.jlelse.eu/publishing-your-android-kotlin-or-java-library-to-jcenter-from-android-studio-1b24977fe450" target="_blank" rel="noopener">Publishing your library to jCenter from Android Studio </a></h2><p>作者在网上找如何上传jcenter,找了很多说法不一的,所以一怒之下自己写了一篇.</p><h2 id="Maintainable-Architecture-–-Five-Day-Forecast-Data-Layer"><a href="#Maintainable-Architecture-–-Five-Day-Forecast-Data-Layer" class="headerlink" title="Maintainable Architecture – Five Day Forecast Data Layer "></a><a href="https://blog.stylingandroid.com/maintainable-architecture-five-day-forecast-data-layer/" target="_blank" rel="noopener">Maintainable Architecture – Five Day Forecast Data Layer </a></h2><p>作者通过实现一个天气预报软件的数据库,来介绍如何设计以及使用正确的方案来确保软件架构正确与维护的成本.</p><p>PS:使用的是Room.</p><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="RecyclerView-FastScroller"><a href="#RecyclerView-FastScroller" class="headerlink" title="RecyclerView-FastScroller "></a><a href="https://github.com/quiph/RecyclerView-FastScroller" target="_blank" rel="noopener">RecyclerView-FastScroller </a></h2><p>Kotlin写的快速滑动的滚动条,按照首字母.</p><h2 id="vector-analog-clock"><a href="#vector-analog-clock" class="headerlink" title="vector-analog-clock "></a><a href="https://github.com/TurkiTAK/vector-analog-clock" target="_blank" rel="noopener">vector-analog-clock </a></h2><p>Vector实现的石英表,适配各种屏幕.</p><h2 id="androme"><a href="#androme" class="headerlink" title="androme "></a><a href="https://github.com/anpham6/androme" target="_blank" rel="noopener">androme </a></h2><p>可以将带JS的HTML5页面转换为多个Android Layout.</p><h2 id="android-UniversalMusicPlayer"><a href="#android-UniversalMusicPlayer" class="headerlink" title="android-UniversalMusicPlayer "></a><a href="https://github.com/googlesamples/android-UniversalMusicPlayer" target="_blank" rel="noopener">android-UniversalMusicPlayer </a></h2><p>Google重写的UAMP</p><h2 id="LazyDatePicker"><a href="#LazyDatePicker" class="headerlink" title="LazyDatePicker. "></a><a href="https://github.com/lopspower/LazyDatePicker" target="_blank" rel="noopener">LazyDatePicker. </a></h2><p>替代系统DatePicker的一个第三方组件.</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="Jetpack" scheme="http://talentprince.github.io/tags/Jetpack/"/>
    
      <category term="Page" scheme="http://talentprince.github.io/tags/Page/"/>
    
      <category term="React Native" scheme="http://talentprince.github.io/tags/React-Native/"/>
    
      <category term="Kotlin Extension" scheme="http://talentprince.github.io/tags/Kotlin-Extension/"/>
    
      <category term="Android P" scheme="http://talentprince.github.io/tags/Android-P/"/>
    
      <category term="Universal Music Player" scheme="http://talentprince.github.io/tags/Universal-Music-Player/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #316</title>
    <link href="http://talentprince.github.io/2018/07/01/Android-Weekly-Issue-316/"/>
    <id>http://talentprince.github.io/2018/07/01/Android-Weekly-Issue-316/</id>
    <published>2018-07-01T11:00:01.000Z</published>
    <updated>2020-06-22T09:44:59.474Z</updated>
    
    <content type="html"><![CDATA[<p>July 1st, 2018</p><h2 id="Android-Weekly-Issue-316"><a href="#Android-Weekly-Issue-316" class="headerlink" title="Android Weekly Issue #316"></a><a href="http://androidweekly.net/issues/issue-316" target="_blank" rel="noopener">Android Weekly Issue #316</a></h2><p>本期内容包含教你使用Kotlin通过Annotation Processor生成代码文件, JetPack中的Android KTX, 以及升级到Target26所需要注意的东西,还包含如何使用KTX简化AndroidX里面的Slice的Build,以及如何通过MotionLayout方便实现动画的系列,还有MLKit中扫条形码的Lib介绍,以及一些譬如Kotlin MVVM, Koin依赖注入做Test, UI Test去除动画,入行一年感受,DialogFLow来做面试机器人等等的有趣内容.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="Generating-Code-via-Annotations-in-Kotlin"><a href="#Generating-Code-via-Annotations-in-Kotlin" class="headerlink" title="Generating Code via Annotations in Kotlin "></a><a href="https://willowtreeapps.com/ideas/generating-code-via-annotations-in-kotlin" target="_blank" rel="noopener">Generating Code via Annotations in Kotlin </a></h2><p>文章介绍了如果用Kotlin来写Annotation Processor生成代码.</p><p>两个关键的Lib</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\\ Code generation library for kotlin, highly recommended</span><br><span class="line">implementation &apos;com.squareup:kotlinpoet:0.7.0&apos;</span><br><span class="line"></span><br><span class="line">\\ configuration generator for service providers</span><br><span class="line">implementation &quot;com.google.auto.service:auto-service:1.0-rc4&quot;</span><br><span class="line">kapt &quot;com.google.auto.service:auto-service:1.0-rc4&quot;</span><br></pre></td></tr></table></figure><ul><li>首先需要通过<code>annotation class</code>定义自己的Annotation.</li><li>其实继承<code>AbstractProcessor</code>实现自己的Processor, 通过<code>@AutoService</code>注册到系统的<code>Processor.class</code>上去.复写<code>process</code>方法生成代码.</li></ul><h2 id="Android-KTX-Android-development-with-Kotlin"><a href="#Android-KTX-Android-development-with-Kotlin" class="headerlink" title="Android KTX - Android development with Kotlin "></a><a href="https://kotlinexpertise.com/android-ktx-kotlin/" target="_blank" rel="noopener">Android KTX - Android development with Kotlin </a></h2><p>之前已经有不少Kotlin的语法糖了,这次JetPack推出的是Android官方的KTX,其主要实现原理就是通过给已有的Framework添加很多方法或者变量的Extension.</p><p>类似于Anko, 支持的列表在<a href="https://developer.android.com/kotlin/ktx" target="_blank" rel="noopener">这里</a>,当然对于类似的Project, 学习是一个过程.</p><h2 id="Remember-remember…-to-target-API-26-on-November"><a href="#Remember-remember…-to-target-API-26-on-November" class="headerlink" title="Remember, remember… to target API 26 on November! "></a><a href="https://medium.com/@fabionegri/remember-remember-to-target-api-26-on-november-7ce4fdde2c08" target="_blank" rel="noopener">Remember, remember… to target API 26 on November! </a></h2><p>文章列举了要逐步将Target升级到26所需要注意的东西.</p><p>Marshmallow 6.0 Level 23</p><ul><li>Runtime Permission</li><li>删除了Apache Http Client</li><li>从OpenSSL到BoringSSL</li><li>删除<code>Notification.setLatestEventInfo()</code></li></ul><p>Nougat 7.0 Level 24</p><ul><li>限制后台网络,删除了<code>CONNECTIVITY_ACTION</code>广播通知,以及Intent中的 <code>ACTION_NEW_PICTURE</code>与<code>ACTION_NEW_VIDEO</code>.</li><li>App外无法通过<code>file://</code>访问私有文件.</li><li>链接非NDK的Lib不行了.</li></ul><p>Nougat 7.1 Level 25</p><ul><li>App Shortcuts</li><li>支持Image到Keyboard里,通过<a href="https://developer.android.com/guide/topics/text/image-keyboard" target="_blank" rel="noopener">Commit Content API</a>.</li><li>添加了<code>android:roundIcon</code></li></ul><p>Oreo 8.0 Leve26</p><ul><li>必须通过<code>startForeground</code>和<code>startForegroundService</code>来启动前台的服务,无法启动后台服务.</li><li>移除了几乎所有的隐式广播,除了<a href="https://developer.android.com/guide/components/broadcast-exceptions" target="_blank" rel="noopener">部分</a>.</li><li>后台位置信息收到限制,推荐使用GCM的<code>FusedLocationProviderClient</code>或者<code>Geofencing</code>.</li><li>必须制定Notification Channel,否则收不到通知.</li></ul><h2 id="My-first-weeks-as-an-Android-Dev"><a href="#My-first-weeks-as-an-Android-Dev" class="headerlink" title="My first weeks as an Android Dev "></a><a href="https://engineering.udacity.com/my-first-weeks-as-an-android-dev-e956ee49418d" target="_blank" rel="noopener">My first weeks as an Android Dev </a></h2><p>介绍了自己第一周做Android开发的经历,面对自己的任务,接触到了譬如<code>Design</code>,<code>ConstraintLayout</code>,<code>Data Binding &amp; ViewModel</code>, <code>DI</code>,以及<code>Kotlin</code>的东西,有点应接不暇.</p><h2 id="Espresso-animations-disabled-flag"><a href="#Espresso-animations-disabled-flag" class="headerlink" title="Espresso animations disabled flag "></a><a href="https://github.com/ghostbuster91/espresso-animations-disabled-test" target="_blank" rel="noopener">Espresso animations disabled flag </a></h2><p>通过设置flag来禁止测试中动画, 方便测试.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testOptions &#123;</span><br><span class="line">    animationsDisabled = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exploring-Firebase-MLKit-on-Android-Barcode-Scanning-Part-Three"><a href="#Exploring-Firebase-MLKit-on-Android-Barcode-Scanning-Part-Three" class="headerlink" title="Exploring Firebase MLKit on Android: Barcode Scanning (Part Three) "></a><a href="https://medium.com/@hitherejoe/exploring-firebase-mlkit-on-android-barcode-scanning-part-three-cc6f5921a108" target="_blank" rel="noopener">Exploring Firebase MLKit on Android: Barcode Scanning (Part Three) </a></h2><p>文章介绍了用Firebase的VisionBarcode来扫条形码.</p><h2 id="Introducing-Slice-Builders-KTX"><a href="#Introducing-Slice-Builders-KTX" class="headerlink" title="Introducing Slice Builders KTX "></a><a href="https://medium.com/google-developers/introducing-slice-builders-ktx-2218ebde356" target="_blank" rel="noopener">Introducing Slice Builders KTX </a></h2><p>Android Slice是最新推出的AndroidX里面的控件,主要是给Google Search App来提供一些类似Google Assistant的那种UI,支持静态与动态的布局.</p><p>KTX也推出了对该组件的支持,以便通过Kotlin来简化Slice Build使用过程.</p><p>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list(context, sliceUri, ListBuilder.INFINITY) &#123;</span><br><span class="line">        row &#123;</span><br><span class="line">           setTitle(&quot;Hello world&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Building-an-Action-to-Solve-a-Real-World-Problem-Part-1-Plan-amp-Design"><a href="#Building-an-Action-to-Solve-a-Real-World-Problem-Part-1-Plan-amp-Design" class="headerlink" title="Building an Action to Solve a Real World Problem: Part 1, Plan &amp; Design "></a><a href="https://medium.com/google-developers/building-an-action-to-solve-a-real-world-problem-part-1-plan-design-2a701fa004c8" target="_blank" rel="noopener">Building an Action to Solve a Real World Problem: Part 1, Plan &amp; Design </a></h2><p>通过Dialogflow等一系列技术搭建了一个给面试者出题的训练系统,根据对话提供不同的题目.</p><h2 id="Introduction-to-MotionLayout-part-I"><a href="#Introduction-to-MotionLayout-part-I" class="headerlink" title="Introduction to MotionLayout (part I) "></a><a href="https://medium.com/google-developers/introduction-to-motionlayout-part-i-29208674b10d" target="_blank" rel="noopener">Introduction to MotionLayout (part I) </a></h2><p>介绍了Google最新的ConstraintLayout 2.0的子类<code>MotionLayout</code>的使用,它可以通过在xml文件里定义的<code>MotionScene</code>来指定一些动画.</p><p>这些都是通过<code>TransitionManager</code>完成的,它会自己计算开始与结束之间的位置,完成动画,有点像Activity之间的SharedElement Transition Animation.</p><h2 id="Testing-with-Koin"><a href="#Testing-with-Koin" class="headerlink" title="Testing with Koin "></a><a href="https://proandroiddev.com/testing-with-koin-ade8a46eb4d" target="_blank" rel="noopener">Testing with Koin </a></h2><p>通过Koin依赖注入框架来简化Kotlin Test里面的mock注入.</p><h2 id="MVVM-with-Kotlin"><a href="#MVVM-with-Kotlin" class="headerlink" title="MVVM with Kotlin "></a><a href="https://proandroiddev.com/mvvm-with-kotlin-android-architecture-components-dagger-2-retrofit-and-rxandroid-1a4ebb38c699" target="_blank" rel="noopener">MVVM with Kotlin </a></h2><p>介绍了Kotlin下Android的MVVM的全套实践,包含了DataBinding, Retrofit, Dagger等等.</p><h2 id="Introducing-adb-enhanced-A-swiss-army-knife-for-Android-development"><a href="#Introducing-adb-enhanced-A-swiss-army-knife-for-Android-development" class="headerlink" title="Introducing adb-enhanced: A swiss army knife for Android development "></a><a href="https://ashishb.net/tech/introducing-adb-enhanced-a-swiss-army-knife-for-android-development/" target="_blank" rel="noopener">Introducing adb-enhanced: A swiss army knife for Android development </a></h2><p>一个Python的应用, enhance的adb,可以方便的进行clean安装,节能模式,doze模式的调试等等.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install adb-enhanced</span><br></pre></td></tr></table></figure><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="ColorPickerView"><a href="#ColorPickerView" class="headerlink" title="ColorPickerView "></a><a href="https://github.com/skydoves/ColorPickerView" target="_blank" rel="noopener">ColorPickerView </a></h2><p>一个选择颜色的picker view</p><h2 id="adb-enhanced"><a href="#adb-enhanced" class="headerlink" title="adb-enhanced "></a><a href="https://github.com/ashishb/adb-enhanced" target="_blank" rel="noopener">adb-enhanced </a></h2><p>上面介绍的加强型Adb</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="Google IO" scheme="http://talentprince.github.io/tags/Google-IO/"/>
    
      <category term="Kotlin Espresso" scheme="http://talentprince.github.io/tags/Kotlin-Espresso/"/>
    
      <category term="Navigation Architecture Component" scheme="http://talentprince.github.io/tags/Navigation-Architecture-Component/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #315</title>
    <link href="http://talentprince.github.io/2018/06/24/Android-Weekly-Issue-315/"/>
    <id>http://talentprince.github.io/2018/06/24/Android-Weekly-Issue-315/</id>
    <published>2018-06-24T07:00:01.000Z</published>
    <updated>2020-06-22T09:44:59.474Z</updated>
    
    <content type="html"><![CDATA[<p>June 24th, 2018</p><h2 id="Android-Weekly-Issue-315"><a href="#Android-Weekly-Issue-315" class="headerlink" title="Android Weekly Issue #315"></a><a href="http://androidweekly.net/issues/issue-315" target="_blank" rel="noopener">Android Weekly Issue #315</a></h2><p>本篇内容包括,Android P的优先级队列管理,Yelp性能测试系列最后一篇帧率监控,以及近期比较火的Airbnb下一步移动战略,还包含连接Clould IoT Core的Library介绍,ML Kit文字识别,与如何从AndroidJob迁移到WorkManager.还有一篇如何搭建面试机器人的介绍,以及尚在早期的Kotlin Native跨平台数据库的概况等.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="Exploring-Android-P-Priority-Buckets"><a href="#Exploring-Android-P-Priority-Buckets" class="headerlink" title="Exploring Android P: Priority Buckets "></a><a href="https://medium.com/google-developer-experts/exploring-android-p-priority-buckets-d34d12059d36" target="_blank" rel="noopener">Exploring Android P: Priority Buckets </a></h2><p>这次Google IO Android P推出了Priority Buckets来提供更好的电池管理.</p><p>通过使用频率,将App分为<code>Active</code>,<code>Working Set</code>,<code>Frequent</code>,<code>Rare</code>,<code>Never</code>几个级别, 不同级别会对Jobs还有Alarms有不同的最大延时.</p><p>分组是动态改变的.</p><h2 id="My-checklist-for-fixing-build-issues"><a href="#My-checklist-for-fixing-build-issues" class="headerlink" title="My checklist for fixing build issues "></a><a href="https://medium.com/@mikewolfson/android-studio-is-borked-my-checklist-for-fixing-build-issues-e41a9dd8cba8" target="_blank" rel="noopener">My checklist for fixing build issues </a></h2><p>作者的AndroidTest里面Import都无法识别了,提示<code>Cannot find symbol</code>,解决办法是清掉一些缓存.</p><p>包括本地Gradle,Project idea与gradle,以及AS的Cache…而后解决了.</p><h2 id="Understanding-the-emotions-of-users-through-NLP"><a href="#Understanding-the-emotions-of-users-through-NLP" class="headerlink" title="Understanding the emotions of users through NLP "></a><a href="https://medium.com/azimolabs/understanding-the-emotions-of-users-through-natural-language-processing-4535ff90f50b" target="_blank" rel="noopener">Understanding the emotions of users through NLP </a></h2><p>作者讲解了通过Firebase functions platform + Google Cloud Natural搭建一个App的客服系统.</p><h2 id="Introducing-Billingx"><a href="#Introducing-Billingx" class="headerlink" title="Introducing Billingx "></a><a href="https://ryanharter.com/blog/introducing-billingx/" target="_blank" rel="noopener">Introducing Billingx </a></h2><p>Google唯一渠道实现App内购买的API就是Billing Library,但是对于测试者来说使用起来很麻烦,而且直到2018 Google I/O也没有新的动作.</p><p>之前也分享过一个叫做<a href="https://github.com/NYTimes/Register" target="_blank" rel="noopener">Register</a>,通过Mock,实现了本地的测试,但是会在Production Apk中引入没必要的代码.</p><p>作者自己封装了一个叫<a href="https://github.com/pixiteapps/billingx" target="_blank" rel="noopener">BillingX</a>的库,提供了空实现给Production版,通过<code>releaseImplementation</code>引入.</p><h2 id="Text-Recognition-with-ML-Kit"><a href="#Text-Recognition-with-ML-Kit" class="headerlink" title="Text Recognition with ML Kit "></a><a href="https://www.raywenderlich.com/197292/text-recognition-with-ml-kit" target="_blank" rel="noopener">Text Recognition with ML Kit </a></h2><p>介绍了这次ML Kit中的云端文字识别API,通过Firebase服务Enable,可以实现图片中文字的<code>in-cloud text recognition</code>,不想掏钱可以试用哦,选择Blaze Plan按需缴费,头1000次请求免费的.</p><h2 id="Publishing-your-Android-Kotlin-or-Java-library-to-mavenCentral"><a href="#Publishing-your-Android-Kotlin-or-Java-library-to-mavenCentral" class="headerlink" title="Publishing your Android, Kotlin or Java library to mavenCentral "></a><a href="https://medium.com/@vanniktech/publishing-your-android-kotlin-or-java-library-to-mavencentral-e22f343b9659" target="_blank" rel="noopener">Publishing your Android, Kotlin or Java library to mavenCentral </a></h2><p>大家平时常用的<a href="https://github.com/chrisbanes/gradle-mvn-push" target="_blank" rel="noopener">Chris Banes</a>的脚本要迁移到Kotlin上还要做一些改动,作者自己弄了一份,并且把它做成了plugin,只需要加到自己的plugin dependencies里面就行了.</p><h2 id="Performance-Improvements-for-Search-on-The-Yelp-Android-App-Part-3"><a href="#Performance-Improvements-for-Search-on-The-Yelp-Android-App-Part-3" class="headerlink" title="Performance Improvements for Search on The Yelp Android App - Part 3 "></a><a href="https://engineeringblog.yelp.com/2018/06/android-search-perf-improvements-part-3.html" target="_blank" rel="noopener">Performance Improvements for Search on The Yelp Android App - Part 3 </a></h2><p>本篇为系列文章的最后一部分,主要介绍了CI上面的Performance如何检测系统帧率变化.</p><p>Yelp通过<a href="https://developer.android.com/reference/android/view/FrameMetrics.html" target="_blank" rel="noopener">FrameMetrics API</a>来获取帧率信息,低于16ms就是快帧,高于就是慢帧,他们会对装有信息的JSON进行分析,其中dopped frame会列出各个部分所消耗的时间.</p><p>最后又总结了整个性能提升过程中所采取的措施,除去这节的Performance Monitoring来防止Regression导致的问题,还包括之前的减少主线程工作,异步inflating layout,对搜索结果view model的caching等.</p><h2 id="Android-Things-client-library-for-Google-Cloud-IoT-Core"><a href="#Android-Things-client-library-for-Google-Cloud-IoT-Core" class="headerlink" title="Android Things client library for Google Cloud IoT Core "></a><a href="https://android-developers.googleblog.com/2018/06/android-things-client-library-for.html?linkId=53347194" target="_blank" rel="noopener">Android Things client library for Google Cloud IoT Core </a></h2><p>为广大IoT爱好者带来福音,client library提供了硬件设备轻松连接google Cloud IoT Core,通过几行代码,便可以轻松的上传传感器信息到云端进行控制.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.google.android.things:cloud-iot-core:1.0.0&apos;</span><br></pre></td></tr></table></figure><p>由于硬件设备所在的环境多变,library还提供了很多错误处理机制,数据信息缓存等.</p><h2 id="How-to-Migrate-from-Android-Job-to-WorkManager"><a href="#How-to-Migrate-from-Android-Job-to-WorkManager" class="headerlink" title="How to Migrate from Android-Job to WorkManager "></a><a href="https://articles.caster.io/android/how-to-migrate-from-android-job-to-workmanager/" target="_blank" rel="noopener">How to Migrate from Android-Job to WorkManager </a></h2><p>作者以前用的是Evernote搞的AndroidJob,本篇介绍了他如何迁移到google最新的WorkManager上面.</p><p>基本使用方法跟AndroidJob类似,Woker通过<code>OneTimeWorkRequestBuilder</code>去build单发事件,通过<code>PeriodicWorkRequestBuilder</code>去build周期性事件,通过<code>setInputData</code>可以添加一些数据,通过<code>setConstraints</code>添加约束,如网络要求等,通过<code>WorkManager.getInstance().enqueue</code>讲Work加入队列.</p><p>Work触发时会执行<code>doWork</code>方法, 返回值<code>Worker.Result.SUCCESS</code>表示成功,类对象<code>inputData</code>可以获取传进来的数据.</p><h2 id="What’s-Next-for-Mobile-at-Airbnb"><a href="#What’s-Next-for-Mobile-at-Airbnb" class="headerlink" title="What’s Next for Mobile at Airbnb "></a><a href="https://medium.com/airbnb-engineering/whats-next-for-mobile-at-airbnb-5e71618576ab" target="_blank" rel="noopener">What’s Next for Mobile at Airbnb </a></h2><p>作者介绍了在Airbnb放弃RN之后下一步要走的路线.</p><ul><li>通过<a href="https://airbnb.design/building-a-visual-language/" target="_blank" rel="noopener">DSL</a>定义跨平台统一的设计语言,实现<code>Server-Driven Rendering</code>,通过自己开发的基于Sketch的设计软件<a href="https://github.com/airbnb/Lona/" target="_blank" rel="noopener">Lona</a>做到一套设计生成不同平台的代码.当然这一切都是在Build的时候做的.</li><li>基于之前的<a href="https://github.com/airbnb/epoxy" target="_blank" rel="noopener">Epoxy</a>,推出新的<code>MvRx</code>,并且支持Android与iOS,Android上是对RecyclerView的封装,可以更方便的实现复杂List的渲染.</li><li>通过<a href="https://developer.android.com/studio/build/build-variants#product-flavors" target="_blank" rel="noopener">gradle product flavors</a>来实现编译速度的提升,只去下载自己关心的Module.</li></ul><h2 id="SQLite-on-Kotlin-Native"><a href="#SQLite-on-Kotlin-Native" class="headerlink" title="SQLite on Kotlin/Native "></a><a href="https://medium.com/@kpgalligan/sqlite-on-kotlin-native-9bcf47854cae" target="_blank" rel="noopener">SQLite on Kotlin/Native </a></h2><p><a href="https://github.com/touchlab/knarch.db/tree/96bb6a2e370bd90d2b42d46b23ba1b2e74b0d4ff" target="_blank" rel="noopener">Knarch</a>, Kotlin跨平台数据库的一个非常早起的版本.很多地方还不成熟,尤其是对Android的支持,如何架构还在讨论总,在使用过程中,多线程也是个问题.</p><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="SaveState"><a href="#SaveState" class="headerlink" title="SaveState "></a><a href="https://github.com/PrototypeZ/SaveState" target="_blank" rel="noopener">SaveState </a></h2><p>保存状态的一个库,相较于Icepick支持Kotlin.</p><h2 id="morph-bottom-navigation"><a href="#morph-bottom-navigation" class="headerlink" title="morph-bottom-navigation "></a><a href="https://github.com/tommybuonomo/morph-bottom-navigation" target="_blank" rel="noopener">morph-bottom-navigation </a></h2><p>基于Bottom Navigation的一个库,有比较好看的动画效果.</p><h2 id="gradle-maven-publish-plugin"><a href="#gradle-maven-publish-plugin" class="headerlink" title="gradle-maven-publish-plugin "></a><a href="https://github.com/vanniktech/gradle-maven-publish-plugin" target="_blank" rel="noopener">gradle-maven-publish-plugin </a></h2><p>支持kotlin的maven发布插件.</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="Priority Bucket" scheme="http://talentprince.github.io/tags/Priority-Bucket/"/>
    
      <category term="Cloud IoT Core" scheme="http://talentprince.github.io/tags/Cloud-IoT-Core/"/>
    
      <category term="ML Kit" scheme="http://talentprince.github.io/tags/ML-Kit/"/>
    
      <category term="WorkManager" scheme="http://talentprince.github.io/tags/WorkManager/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #310</title>
    <link href="http://talentprince.github.io/2018/06/13/Android-Weekly-Issue-310/"/>
    <id>http://talentprince.github.io/2018/06/13/Android-Weekly-Issue-310/</id>
    <published>2018-06-13T01:00:01.000Z</published>
    <updated>2020-06-22T09:44:59.474Z</updated>
    
    <content type="html"><![CDATA[<p>May 20th, 2018</p><h2 id="Android-Weekly-Issue-290"><a href="#Android-Weekly-Issue-290" class="headerlink" title="Android Weekly Issue #290"></a><a href="http://androidweekly.net/issues/issue-310" target="_blank" rel="noopener">Android Weekly Issue #290</a></h2><p>本期既有本次Google IO对于Play Console的更新简介, 又有数篇对于简化UI Test的工具与方法的介绍,还有JetPack Worker Manager的推介,以及如何仅仅通过Firebase快速搭建一个自己的Instgram小App,当然还有一篇关于Google最新的Navigation Architecture Component的介绍,精彩内容不容错过.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="Rxify-The-startWith-MVI-pitfall"><a href="#Rxify-The-startWith-MVI-pitfall" class="headerlink" title="Rxify : The startWith { MVI } pitfall "></a><a href="https://medium.com/@ragdroid/rxify-the-startwith-mvi-pitfall-68764ae8946d" target="_blank" rel="noopener">Rxify : The startWith { MVI } pitfall </a></h2><p>在实现MVI返回State Intent的时候, 可以通过startWith可以添加一些初始化状态,它就类似于concat,将一个新的Observable与之结合,再通过onErrorReturn返回一个错误的状态,保证我们的chain的完备性.</p><h2 id="Discover-everything-new-in-the-Google-Play-Console"><a href="#Discover-everything-new-in-the-Google-Play-Console" class="headerlink" title="Discover everything new in the Google Play Console "></a><a href="https://android-developers.googleblog.com/2018/05/io-2018-everything-new-in-google-play.html" target="_blank" rel="noopener">Discover everything new in the Google Play Console </a></h2><p>最新的GoogleIO更新了Play Console的新功能,有一些还是挺厉害的.</p><ul><li>App Bundle, 就是你的res可以根据设备加载,比如图片资源,对于xxxdpi的设备就下载一份,语言包也类似.</li><li>提升了质量检测过程, 通过100个内部测试机运行你upload的程序,还有各种report与analysis帮助你分析潜在问题.</li><li>dashboard以及一些数据呈现更加优化,还可以通过acquisition report获得更多信息,如用户从哪里得到的你的app等等.</li><li>提升用户订阅服务,通过Billing Library可以轻松实现订阅服务,在Subscriptions Center可以轻松管理用户的订阅订单,还有详细的report帮你分析多种订阅之间的时间,地点等等因素的关系.</li><li>八月份之前必须得Target到26了.</li></ul><h2 id="Kakao-how-to-make-UI-testing-great-again"><a href="#Kakao-how-to-make-UI-testing-great-again" class="headerlink" title="Kakao - how to make UI testing great again "></a><a href="https://medium.com/@ilyalim/kakao-how-to-make-ui-testing-great-again-19972cf13740" target="_blank" rel="noopener">Kakao - how to make UI testing great again </a></h2><p>Kakao是一个kotlin的UI测试框架,基于Espresso,可以大幅度简化使用Espresso的过程,通过Lambda以及Kakao内置的一些操作符,完成测试.</p><p>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> screen &#123;</span><br><span class="line">      content &#123; isVisible() &#125;</span><br><span class="line"></span><br><span class="line">      textViewSmall &#123;</span><br><span class="line">          isVisible()</span><br><span class="line">          hasAnyText()</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Best-Practices-for-Unit-Testing-in-Kotlin"><a href="#Best-Practices-for-Unit-Testing-in-Kotlin" class="headerlink" title="Best Practices for Unit Testing in Kotlin "></a><a href="https://blog.philipphauer.de/best-practices-unit-testing-kotlin/" target="_blank" rel="noopener">Best Practices for Unit Testing in Kotlin </a></h2><p>作者提了好几条建议来提升Kotlin测试的体验</p><ul><li>使用JUnit5的<code>@TestInstance(Lifecycle.PER_CLASS)</code>来避免出现一些静态field,这些静态field主要是为了保证在整个测试类中只初始化一次,而JUnit4每一个Test都会重新创建新的Class.取而代之的是可以使用<code>init{}</code>加<code>@BeforeEach</code>.</li><li>使用JUnit5的<code>@Nested</code>包装测试类中一些特殊的模块,使之更加清晰.</li><li>使用<code></code>(backticks)去自定义方法名.</li><li><a href="http://joel-costigliola.github.io/assertj/" target="_blank" rel="noopener">AssertJ</a>依旧好使.</li><li>使用<a href="https://github.com/nhaarman/mockito-kotlin" target="_blank" rel="noopener">Mokito-Kotlin</a>跟<a href="http://mockk.io/" target="_blank" rel="noopener">MockK</a>来做mock</li></ul><h2 id="Exploring-Moshi’s-Kotlin-Code-Gen"><a href="#Exploring-Moshi’s-Kotlin-Code-Gen" class="headerlink" title="Exploring Moshi’s Kotlin Code Gen "></a><a href="https://medium.com/@sweers/exploring-moshis-kotlin-code-gen-dec09d72de5e" target="_blank" rel="noopener">Exploring Moshi’s Kotlin Code Gen </a></h2><p>Moshi是一个JSON解析库,文章介绍了1.6版本使用了新的Kotlin代码生成器,更好的处理了类似<code>Mutablility</code>,<code>Nullability</code>,<code>in/out</code>等等的问题,感兴趣可以自己看一下.</p><h2 id="Life-with-without-services-and-WorkManager"><a href="#Life-with-without-services-and-WorkManager" class="headerlink" title="Life with/without services and WorkManager "></a><a href="https://medium.com/google-developer-experts/services-the-life-with-without-and-worker-6933111d62a6" target="_blank" rel="noopener">Life with/without services and WorkManager </a></h2><p>随着Android对于内存管理的越来越严格,首先是26以上Service无法在后台<code>startService</code>被限制,而系统提供的<code>JobScheduler</code>在23以下有问题,而<code>JobDispatcher</code>又需要Google Service…让人甚是苦恼.</p><p>值得高兴的是,Google最近推出的强大的JetPack里面的<code>WorkerManager</code>将解决这个问题.</p><p>它内部融合了<code>JobScheduer</code>,<code>JobDispather</code>,<code>AlarmManager</code>等等,并提供了两种Woker,<code>OneTime</code>跟<code>Periodic</code>.让后台操作变得非常轻松.</p><h2 id="A-year-as-Android-Engineer"><a href="#A-year-as-Android-Engineer" class="headerlink" title="A year as Android Engineer "></a><a href="https://proandroiddev.com/a-year-as-android-engineer-55e2a428dfc8" target="_blank" rel="noopener">A year as Android Engineer </a></h2><p>文章介绍了作者从一个QA转型为一个Android Dev,并找到新工作的经历,可以当故事看看…</p><h2 id="The-missing-migration-guide-to-the-Gradle-Kotlin-DSL"><a href="#The-missing-migration-guide-to-the-Gradle-Kotlin-DSL" class="headerlink" title="The missing migration guide to the Gradle Kotlin DSL "></a><a href="https://github.com/jnizet/gradle-kotlin-dsl-migration-guide" target="_blank" rel="noopener">The missing migration guide to the Gradle Kotlin DSL </a></h2><p>一个REAMME,介绍了如何从Gradle迁移到Kotlin DSL,喜欢Kotlin的朋友们可以对照着迁移了,一步两步.</p><h2 id="Build-an-Instagram-Like-Android-App-Using-Google-Firebase"><a href="#Build-an-Instagram-Like-Android-App-Using-Google-Firebase" class="headerlink" title="Build an Instagram-Like Android App Using Google Firebase "></a><a href="https://dragosholban.com/2018/05/13/build-an-instagram-like-android-app-using-google-firebase/" target="_blank" rel="noopener">Build an Instagram-Like Android App Using Google Firebase </a></h2><p>通过Firebase搭建一个类似Instgram的App.</p><p>通过Firebase Authenicate来实现登录认证,通过Firebase Storage来实现图片上传,通过Firebase Database来实现数据存储.</p><p>自己只需要实现简单的UI,便可以完成简易化的Ins,是不是很开森.</p><h2 id="A-problem-like-Navigation"><a href="#A-problem-like-Navigation" class="headerlink" title="A problem like Navigation "></a><a href="https://medium.com/a-problem-like-maria/a-problem-like-navigation-e9821625a70e" target="_blank" rel="noopener">A problem like Navigation </a></h2><p>介绍了Google最新推出的Navigation Archtecture Component,来处理Fragment之间的跳转,通过定义xml中的<code>action</code>,就可以完成跳转,通过定义<code>argument</code>就可以完成值传递,以及定义<code>deepLink</code>,可以轻松支持Deeplink.</p><h2 id="Pleasant-fun-painless-delightful-Espresso-testing-with-Kotlin"><a href="#Pleasant-fun-painless-delightful-Espresso-testing-with-Kotlin" class="headerlink" title="Pleasant fun painless delightful Espresso testing with Kotlin "></a><a href="https://medium.com/@Zhuinden/pleasant-fun-painless-delightful-espresso-testing-with-kotlin-3ffeda58d45c" target="_blank" rel="noopener">Pleasant fun painless delightful Espresso testing with Kotlin </a></h2><p>一个基于Kakao(Kotlin DSL for Espresso)的Kotlin Espresso库,用于简化UI test的书写.</p><p>如可以直接通过Id来索引View直接perform操作,而不必在通过<code>onView</code>…<code>withId</code>…<code>perform</code>来搞的很长.</p><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="MockK"><a href="#MockK" class="headerlink" title="MockK "></a><a href="http://mockk.io/ANDROID" target="_blank" rel="noopener">MockK </a></h2><p>kotlin的Mock lib</p><h2 id="espresso-helper"><a href="#espresso-helper" class="headerlink" title="espresso-helper "></a><a href="https://github.com/Zhuinden/espresso-helper" target="_blank" rel="noopener">espresso-helper </a></h2><p>Espresso的Kotlin封装</p><h2 id="Kakao"><a href="#Kakao" class="headerlink" title="Kakao "></a><a href="https://github.com/agoda-com/Kakao" target="_blank" rel="noopener">Kakao </a></h2><p>上面那个库基于的,也是对于Espresso的封装.</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="Google IO" scheme="http://talentprince.github.io/tags/Google-IO/"/>
    
      <category term="Kotlin Espresso" scheme="http://talentprince.github.io/tags/Kotlin-Espresso/"/>
    
      <category term="Navigation Architecture Component" scheme="http://talentprince.github.io/tags/Navigation-Architecture-Component/"/>
    
  </entry>
  
  <entry>
    <title>如何从RxJava升级到RxJava2</title>
    <link href="http://talentprince.github.io/2018/04/02/From-RxJava-to-RxJava2/"/>
    <id>http://talentprince.github.io/2018/04/02/From-RxJava-to-RxJava2/</id>
    <published>2018-04-02T02:29:31.000Z</published>
    <updated>2020-06-22T09:44:59.477Z</updated>
    
    <content type="html"><![CDATA[<p>RxJava2已经推出有一年半的时间,由于之前RxJava已经在现有项目中广泛使用,而RxJava2在除了很多命名外并没有太多革新,所以相信有很多人跟我一样都还没有升级.</p><p>随着老版本渐渐的失去维护,更重要的是有一定时间允许我来做这个迁移,其实弃老从新一直都是程序员的喜好.</p><p>虽然官方提供了<a href="https://github.com/ReactiveX/RxJava/wiki/What&#39;s-different-in-2.0" target="_blank" rel="noopener">文档</a>详尽的介绍了区别,但是文章之长,可能很多人读不下去,却有想快速的迁移过来,我将除了命名改变之外有用的地方总结成了几点,供大家参考.</p><a id="more"></a><h2 id="不能再发射Null了"><a href="#不能再发射Null了" class="headerlink" title="不能再发射Null了"></a>不能再发射Null了</h2><p>RxJava2的最大改变就是不能再流里发射Null了,有人会问发射了就怎么了,答案是你的流会因为<code>NPE</code>断开.</p><p>比如以前我们会写出这样的代码(详见RxPermission):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(null).compose....</span><br></pre></td></tr></table></figure><p>在RxJava二中我们需要将它改为(详见RxPermission2):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TRIGGER = new Object()</span><br><span class="line">Observer.just(TRIGGER).compose(xxx)</span><br></pre></td></tr></table></figure><p>还有我们常常完成某个工作而不需要返回值,或者根本不关心返回值,将返回的Observable定义为Observable<void>, 如:</void></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xxx.flatMap &#123;</span><br><span class="line">   ....</span><br><span class="line">   return null;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在不能这么写了,对于不需要返回值的,我们应该使用Completable,当然这个在RxJava的时候也已经存在了.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.flatMapCompletable &#123; Completable.fromAction&#123; &#125; &#125;</span><br></pre></td></tr></table></figure><p>还有我们在实现Local Cache与Remote Cache的时候常用的办法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localObservable = just(localReference);</span><br><span class="line"></span><br><span class="line">concat(localObservable, remoteObservable).filter&#123; i != null &#125;.first()...</span><br></pre></td></tr></table></figure><p>会因为在没有Local Cache的时候出错,所以应该改成:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localObservable = just(Optional.fromNullable(localReference));</span><br><span class="line"></span><br><span class="line">concat(localObservable, remoteObservable).filter&#123; i.isPresent() &#125;.firstElement()/.first(defaultValue)...</span><br></pre></td></tr></table></figure><h2 id="flatMap方法多了"><a href="#flatMap方法多了" class="headerlink" title="flatMap方法多了"></a>flatMap方法多了</h2><p>在上面的介绍中可能已经发现了,老版本只有同类型的flatMap,即Observable <-> Observable, Single <-> Single, 而RxJava2除了同类型的flatMap,还增添了flatMapCompletable,flatMapSingle,flatMapObservable帮助你任意切换.</-></-></p><h2 id="订阅与反订阅"><a href="#订阅与反订阅" class="headerlink" title="订阅与反订阅"></a>订阅与反订阅</h2><p>我们有时候需要在必要的时刻手动的将订阅取消,而防止产生我们不想要的问题,如在跳出定位页面时取消订阅,防止位置信息后面回来造成程序崩溃.</p><p>而在RxJava中,我们一般是这么做的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Subscription subscription = xxxx.subscribe(xxxSubscriber);</span><br><span class="line"></span><br><span class="line">subscription.unsubscribe();</span><br></pre></td></tr></table></figure><p>在RxJava2中,这个发生了变化,因为你会发现<code>subscribe</code>方法基本上都返回void的,如果你需要手动取消的话,需要使用<code>T subscribeWith(T extends Disposal)</code>方法.</p><p>其实我们可以看到,新版的<code>Subscriber</code>或者<code>Observer</code>都多了一个方法<code>void onSubscribe(Subscription s)</code>或者<code>void onSubscribe(Disposable d)</code>, 也就是说以前的<code>Subscription</code>是通过订阅后通过回调返回了.</p><p>这里RxJava2统一接口到<code>Disposable</code>,提供<code>dispose</code>方法进行反订阅,并且还提供了<code>DisposableObservable</code>,<code>DisposableSingle</code>,<code>DisposableCompletable</code>已经帮我们处理了回调返回的Disposable对象.</p><p>所以需要做的改动不大:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Disposable disposable = xxx.subscribeWith(xxxDisposableObserver);</span><br><span class="line"></span><br><span class="line">disposable.dispose();</span><br></pre></td></tr></table></figure><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>错误处理最棒的一点是之前必须实现onError来handle错误,如果不实现,就会抛出<code>OnErrorNotImplement</code>,导致程序崩溃,根据最新的Doc,在RxJava2中,可以轻松Handle未处理的错误.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RxJavaPlugins.setErrorHandler(xxx);</span><br></pre></td></tr></table></figure><p>还有一点变化需要注意是的是,当你有并行任务的时候,如果一个线程出错,将会导致整个流中断,其他线程可能会抛出<code>IOInterupedException</code>并且onError无法Handle,这时候必须有上面讲到的ErrorHandler来处理这一类<code>UnDeliveriedException</code>,否则程序会Crash.</p><h2 id="Flowable"><a href="#Flowable" class="headerlink" title="Flowable"></a>Flowable</h2><p>RxJava2将处理背压(BackPressure)的部分抽出来弄了一个新的对象,叫做<code>Flowable</code>.</p><p>以前我们处理背压可能直接通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.onBackpressureXXXStrategy()...</span><br></pre></td></tr></table></figure><p>就可以了.</p><p>现在我们得通过Flowable来处理.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.toFlowable(XXXStrategy)...</span><br></pre></td></tr></table></figure><p>当然Flowable还提供比较强大的新方法,来处理并发.</p><p>比如之前我们需要实现并发,得通过flatMap来实现.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.from(urls).flatMap &#123; </span><br><span class="line">       v -&gt; Observable.just(v).subscribeOn(io()).....</span><br><span class="line">&#125;.subscribe(...)</span><br></pre></td></tr></table></figure><p>使用Flowable,可以简化为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flowable.fromIterable(listingIds)</span><br><span class="line">    .parallel().runOn(io())</span><br><span class="line">    .map &#123; v -&gt; xxx &#125;</span><br><span class="line">    .sequential()</span><br></pre></td></tr></table></figure><p>看起来是不是有点炫酷…</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>对于RxJava2,任何一个Observable都可以转化为一个<code>TestObservable</code>, 通过<code>...test()</code>来进行转换.</p><p>而TestObservable提供很多与测试相关的方法,就不用我们亲自去判断.</p><p>如<code>assertResult</code>,<code>assertError</code>,<code>assertSubscribed</code>.</p><h2 id="其他改动"><a href="#其他改动" class="headerlink" title="其他改动"></a>其他改动</h2><p>关于名字的变化,这里都不一一论述,包含<code>Func1</code> -&gt; <code>Function</code>, <code>Action</code> -&gt; <code>Consumer</code>, <code>Observable.Transformer</code> -&gt; <code>ObservableTransformer</code>等等. </p>]]></content>
    
    <summary type="html">
    
      RxJava 升级 RxJava2
    
    </summary>
    
      <category term="Android" scheme="http://talentprince.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://talentprince.github.io/tags/Android/"/>
    
      <category term="RxJava" scheme="http://talentprince.github.io/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #290</title>
    <link href="http://talentprince.github.io/2018/04/01/Android-Weekly-Issue-290/"/>
    <id>http://talentprince.github.io/2018/04/01/Android-Weekly-Issue-290/</id>
    <published>2018-04-01T02:37:28.000Z</published>
    <updated>2020-06-22T09:44:59.473Z</updated>
    
    <content type="html"><![CDATA[<p>December 31st, 2017</p><h2 id="Android-Weekly-Issue-290"><a href="#Android-Weekly-Issue-290" class="headerlink" title="Android Weekly Issue #290"></a><a href="http://androidweekly.net/issues/issue-290" target="_blank" rel="noopener">Android Weekly Issue #290</a></h2><p>本期内容包括介绍Kotlin逆变协变的一篇(虽然没说清楚,但我补充了),IoT相关制作MIDI Controler的Part two,以及比较炫酷的Shared Element Reveal动画,以及LiveData与DataBinding相关,Kotlin扩展Fragment/Activity方法做测试,Rx逐条打Log等等.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="Lessons-learned-implementing-Redux-on-Android"><a href="#Lessons-learned-implementing-Redux-on-Android" class="headerlink" title="Lessons learned implementing Redux on Android "></a><a href="https://blog.pusher.com/lessons-learned-implementing-redux-on-android/" target="_blank" rel="noopener">Lessons learned implementing Redux on Android </a></h2><p>文章介绍了模仿Web的Redux,实现其kotlin版本,实现<code>Reducer</code>,通过<code>State</code>与<code>Action</code>来驱动状态的转换.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">State -&gt; UI -&gt; Action -&gt; Reducer -&gt; Store.</span><br></pre></td></tr></table></figure><h2 id="In-and-out-type-variant-of-Kotlin"><a href="#In-and-out-type-variant-of-Kotlin" class="headerlink" title="In and out type variant of Kotlin "></a><a href="https://android.jlelse.eu/in-and-out-type-variant-of-kotlin-587e4fa2944c" target="_blank" rel="noopener">In and out type variant of Kotlin </a></h2><p>文章介绍了Kotlin中泛型添加<code>in</code>与<code>out</code>的意义.</p><p>实际上<code>in</code>作为参数表示的是consume方,可以将super type可以赋值给sub type.类似于Java里面的<code>&lt;? super X&gt;</code>,其作为泛型的Collection只能add数据,无法get访问内部成员.</p><p>而<code>out</code>作为返回值表示producer,与in相反,它可以将sub type赋值给super type.类似于Java中的&lt;? extends X&gt;,其作为反省的Collection<out t>只能get访问,不能add数据.</out></p><h2 id="Building-a-distributed-MIDI-Controller-with-Android-Things-and-Nearby-API-2"><a href="#Building-a-distributed-MIDI-Controller-with-Android-Things-and-Nearby-API-2" class="headerlink" title="Building a distributed MIDI Controller with Android Things and Nearby API #2 "></a><a href="https://proandroiddev.com/building-a-distributed-midi-controller-with-android-things-and-nearby-api-2-b4b0531d645e" target="_blank" rel="noopener">Building a distributed MIDI Controller with Android Things and Nearby API #2 </a></h2><p>IoT的MIDI播放器第二篇,感兴趣的可以仔细看.</p><h2 id="Meaningful-Motion-Circular-Reveal-amp-Shared-Elements"><a href="#Meaningful-Motion-Circular-Reveal-amp-Shared-Elements" class="headerlink" title="Meaningful Motion: Circular Reveal &amp; Shared Elements "></a><a href="https://medium.com/@jossiwolf/meaningful-motion-circular-reveal-shared-elements-ea495b99adf4" target="_blank" rel="noopener">Meaningful Motion: Circular Reveal &amp; Shared Elements </a></h2><p>在Shared Element Transaction Animation的基础上加上了<code>ViewAnimationUtils#createCircularReveal</code>实现Reveal效果. 即Activity/Fragment跳转过程中Shared Element先移动再充满Container.</p><h2 id="RxAndroid-Handle-Interrupt-With-“switchMap”"><a href="#RxAndroid-Handle-Interrupt-With-“switchMap”" class="headerlink" title="RxAndroid: Handle Interrupt With “switchMap” "></a><a href="https://tech.pic-collage.com/rxandroid-handle-interrupt-with-switchmap-3a650393299f" target="_blank" rel="noopener">RxAndroid: Handle Interrupt With “switchMap” </a></h2><p>通过switchMap将Happy与Unhappy的pass都加进来(Observer.merge)进行处理,switchMap与flatMap的区别是它内部只有一个active的observer,简单的来说,它不会对转换后的Observable进行merge,而是在新的来到的时候cancel之前的.</p><h2 id="The-curious-case-of-haunting-fragments"><a href="#The-curious-case-of-haunting-fragments" class="headerlink" title="The curious case of haunting fragments "></a><a href="https://jeroenmols.com/blog/2017/12/18/fragmentback/" target="_blank" rel="noopener">The curious case of haunting fragments </a></h2><p>作者研究Fragment addToBackStack以及pop之间的事情,但是作者貌似没用对…</p><p>所以之后他居然推荐用Activity了,说Fragment太难用…</p><h2 id="Unit-testing-protected-lifecycle-methods-with-Kotlin"><a href="#Unit-testing-protected-lifecycle-methods-with-Kotlin" class="headerlink" title="Unit testing protected lifecycle methods with Kotlin "></a><a href="https://medium.com/@dpreussler/unit-testing-activity-lifecycle-4e740f71e68a" target="_blank" rel="noopener">Unit testing protected lifecycle methods with Kotlin </a></h2><p>作者写了个工具库,给Activity的生命周期方法都写了扩展,这样就可以直接通过对象调用了…可以用来写Activity的单元测试.</p><h2 id="Kotlin-Coding-Conventions"><a href="#Kotlin-Coding-Conventions" class="headerlink" title="Kotlin Coding Conventions "></a><a href="http://kotlinlang.org/docs/reference/coding-conventions.html" target="_blank" rel="noopener">Kotlin Coding Conventions </a></h2><p>Kotlin最新的code style,基本跟Java类似,但这里比较详细,包括什么时候换行,什么时候single line等等.</p><h2 id="Lessons-from-my-first-multi-platform-Kotlin-project"><a href="#Lessons-from-my-first-multi-platform-Kotlin-project" class="headerlink" title="Lessons from my first multi-platform Kotlin project "></a><a href="https://blog.kotlin-academy.com/lessons-from-my-first-multiplatform-kotlin-project-d4e311f15874" target="_blank" rel="noopener">Lessons from my first multi-platform Kotlin project </a></h2><p>作者对Kotlin Multiple Platform进行总结,首先platform层应该根据js/jvm/native进行划分,而不是操作系统,操作系统的划分应该属于之下的regular层,而最上层为common层.</p><p>MVP的应用非常重要,其次是下层可以访问上层的一切,上层需要访问下层应该通过expected与actual来实现.</p><h2 id="Android-Architecture-Components-LiveData-with-Data-Binding"><a href="#Android-Architecture-Components-LiveData-with-Data-Binding" class="headerlink" title="Android Architecture Components LiveData with Data Binding "></a><a href="https://android.jlelse.eu/android-architecture-components-livedata-with-data-binding-7bf85871bbd8" target="_blank" rel="noopener">Android Architecture Components LiveData with Data Binding </a></h2><p>Google最新的Databinding已经支持LiveData了,通过与LiveData进行绑定,可以保证UI在后台的时候不会因为数据变化而刷新,避免了没有必要的操作.</p><h2 id="Briefly-about-RxJava-Logging"><a href="#Briefly-about-RxJava-Logging" class="headerlink" title="Briefly about RxJava Logging "></a><a href="https://proandroiddev.com/briefly-about-rxjava-logging-20308b013e6d" target="_blank" rel="noopener">Briefly about RxJava Logging </a></h2><p>作者介绍了通过<code>doOnEach</code> (Flowable)以及<code>doOnEvent</code>(others)来了解Observable的状态,帮助你添加新的feature中debug遇到的问题,不至于整个Rx Chains出现问题而不知道问题处在哪里.</p><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="TableView"><a href="#TableView" class="headerlink" title="TableView "></a><a href="https://github.com/evrencoskun/TableView" target="_blank" rel="noopener">TableView </a></h2><p>很项强大TableView,基于RecyclerView,用来显示复杂数据.有点类似数据库表格.</p><h2 id="retrofit2-kotlin-coroutines-adapter"><a href="#retrofit2-kotlin-coroutines-adapter" class="headerlink" title="retrofit2-kotlin-coroutines-adapter "></a><a href="https://github.com/JakeWharton/retrofit2-kotlin-coroutines-adapter" target="_blank" rel="noopener">retrofit2-kotlin-coroutines-adapter </a></h2><p>Jake Warthon写的支持Kotlin Coroutine的Retrofit2, 返回<code>Deferred</code>类型.</p><h2 id="RxTest"><a href="#RxTest" class="headerlink" title="RxTest "></a><a href="https://github.com/RubyLichtenstein/RxTest" target="_blank" rel="noopener">RxTest </a></h2><p>像这个来测Rx的Observable,是不是很牛.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(&quot;Hello RxTest!&quot;)</span><br><span class="line">    .test &#123;</span><br><span class="line">        it shouldEmit &quot;Hello RxTest!&quot;</span><br><span class="line">        it should complete()</span><br><span class="line">        it shouldHave noErrors()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="MockK"><a href="#MockK" class="headerlink" title="MockK "></a><a href="http://mockk.io/" target="_blank" rel="noopener">MockK </a></h2><p>支持Koltin DSL的mock库, 叫mockk….</p><h2 id="KotlinAndroidViewBindings"><a href="#KotlinAndroidViewBindings" class="headerlink" title="KotlinAndroidViewBindings "></a><a href="https://github.com/MarcinMoskala/KotlinAndroidViewBindings" target="_blank" rel="noopener">KotlinAndroidViewBindings </a></h2><p>其实感觉跟ViewBinding没多大关系, 主要是实现了Delegate,可以取代<code>findViewById</code>,<code>Butterknife</code>以及<code>Kotlin Android Extension</code>.</p><p>直接通过<code>by bindWithXX()</code>来找到View.</p><h2 id="litho-kotlin"><a href="#litho-kotlin" class="headerlink" title="litho-kotlin "></a><a href="https://github.com/vinc3m1/litho-kotlin" target="_blank" rel="noopener">litho-kotlin </a></h2><p>Facebook litho的kotlin dsl support.</p><h2 id="kotlin-math"><a href="#kotlin-math" class="headerlink" title="kotlin-math "></a><a href="https://github.com/romainguy/kotlin-math" target="_blank" rel="noopener">kotlin-math </a></h2><p>支持很多vector计算的lib,帮助简化graphic math.</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://talentprince.github.io/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://talentprince.github.io/tags/Kotlin/"/>
    
      <category term="IoT" scheme="http://talentprince.github.io/tags/IoT/"/>
    
      <category term="Animation" scheme="http://talentprince.github.io/tags/Animation/"/>
    
      <category term="LiveData" scheme="http://talentprince.github.io/tags/LiveData/"/>
    
      <category term="DataBinding" scheme="http://talentprince.github.io/tags/DataBinding/"/>
    
      <category term="RxLog" scheme="http://talentprince.github.io/tags/RxLog/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #289</title>
    <link href="http://talentprince.github.io/2017/12/31/Android-Weekly-Issue-289/"/>
    <id>http://talentprince.github.io/2017/12/31/Android-Weekly-Issue-289/</id>
    <published>2017-12-31T03:36:24.000Z</published>
    <updated>2020-06-22T09:44:59.473Z</updated>
    
    <content type="html"><![CDATA[<p>December 24th, 2017</p><h2 id="Android-Weekly-Issue-289"><a href="#Android-Weekly-Issue-289" class="headerlink" title="Android Weekly Issue #289"></a><a href="http://androidweekly.net/issues/issue-289" target="_blank" rel="noopener">Android Weekly Issue #289</a></h2><p>今年最后一篇, 包含了可以上传log记录的HyperLog,以及Android的面试技巧,还有Model的分层,以及如何迁移到Room.<br>还有比较炫酷的一个Path动画的实现方法值得去看.剩下的多是一些入门介绍,如kotlin,firebase messaging,contraintset animation等.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="HyperLog-Android-Remote-Logger-Library-for-Debugging"><a href="#HyperLog-Android-Remote-Logger-Library-for-Debugging" class="headerlink" title="HyperLog: Android Remote Logger Library for Debugging "></a><a href="https://android.jlelse.eu/android-remote-logger-library-for-debugging-343443bd38b7" target="_blank" rel="noopener">HyperLog: Android Remote Logger Library for Debugging </a></h2><p>作者讲了很多人苦恼有时候插线数据线Logcat给清掉了,也看不到日志信息,而Timber活着Logger也没法支持Production环境,推荐了<code>HyperLog</code>,可以上传日志文件到远端服务器,可以设定一些schedular定时上传.</p><h2 id="Bring-life-to-your-custom-view"><a href="#Bring-life-to-your-custom-view" class="headerlink" title="Bring life to your custom view "></a><a href="https://medium.com/@romandanylyk96/android-bring-life-to-your-custom-view-8604ab3967b3" target="_blank" rel="noopener">Bring life to your custom view </a></h2><p>文章介绍了通过动画来绘制一个自定义View,原理是通用的,就是首先分析你的图形构成的元素,需要哪些变量的变化,然后通过<code>ValueAnimator</code>控制这些变量的变化,再通过<code>invalidate</code>触发onDraw依照变量的值进行绘制.</p><h2 id="Interviewing-Tips-for-Android-Engineers"><a href="#Interviewing-Tips-for-Android-Engineers" class="headerlink" title="Interviewing Tips for Android Engineers "></a><a href="https://eng.lyft.com/interviewing-tips-for-android-engineers-f01ce7fba163" target="_blank" rel="noopener">Interviewing Tips for Android Engineers </a></h2><p>作者作为Lyfy的一员,作者很高兴的分享自己的一些新的帮助面试者,介绍了Android面试的一些tips,包含从开始的电话初面或者作业,到后来的Java面,Android UI相关技能面,Android Infrastructure面,以及Design与Background的面所应该注意的点以及准备的方法.</p><h2 id="Using-Architecture-Components-with-Firebase-Database-Part-3"><a href="#Using-Architecture-Components-with-Firebase-Database-Part-3" class="headerlink" title="Using Architecture Components with Firebase Database - Part 3 "></a><a href="https://firebase.googleblog.com/2017/12/using-android-architecture-components_22.html" target="_blank" rel="noopener">Using Architecture Components with Firebase Database - Part 3 </a></h2><p>文章继续之前通过LiveData封装FirebaseDatabase,与ViewModel结合实现MVVM的工作.</p><p>这是第三部分,主要介绍如何优化没有必要的query,Activity有可能因为转屏导致configuration changed,从而引起LiveData瞬间切换到Inactive又变成Active,导致数据库重复的query.</p><p>解决方案是将销毁操作封装到延迟的Runnable里面,发送给Handler,并设置标记位.在onActive中检测标记为,如果发现仍然在pending状态,就<code>removeCallbacks</code>,清楚消息…</p><h2 id="Data-model-mapping-in-Android-Apps"><a href="#Data-model-mapping-in-Android-Apps" class="headerlink" title="Data model mapping in Android Apps "></a><a href="https://overflow.buffer.com/2017/12/21/even-map-though-data-model-mapping-android-apps/" target="_blank" rel="noopener">Data model mapping in Android Apps </a></h2><p>文章一步一步介绍了我们应该如何处理我们的Model,其实是希望我们应该对我们的Model进行分层.</p><p>API与Cache的原始数据,以及与我们核心业务相关的Domain层,再者就是包含UI state等信息的Presentation层了.</p><p>其实就是我们常说的Model-&gt;Domain-&gt;Presentation.</p><p>当然在我们所谓BFF(backends for frontends)理论下(简单来说就是Server为Mobile加一层转换,直接输出显示内容相关数据),可以省去Model与Domain层,但一些UI的state我们仍需想办法维护.</p><h2 id="Incrementally-migrate-from-SQLite-to-Room"><a href="#Incrementally-migrate-from-SQLite-to-Room" class="headerlink" title="Incrementally migrate from SQLite to Room "></a><a href="https://medium.com/google-developers/incrementally-migrate-from-sqlite-to-room-66c2f655b377" target="_blank" rel="noopener">Incrementally migrate from SQLite to Room </a></h2><p>介绍了如何逐步将你的db迁移到room.</p><ul><li>首先根据你的table定义<code>Entity</code>.</li><li>其次实现<code>RoomDatabase</code>,增加版本号并加上空的Migration逻辑.</li><li>使用<code>SupportSQLiteOpenHelper</code>替换原有的SQLiteOpenHelper,如果你之前没有使用raw的sql语句,需要用使用<code>SupportSQLiteQuery</code>拼出query条件.</li><li>写自己的<code>DAO</code>,替换掉Cusor的操作.</li></ul><h2 id="Boost-your-app-reviews-with-Firebase-Predictions"><a href="#Boost-your-app-reviews-with-Firebase-Predictions" class="headerlink" title="Boost your app reviews with Firebase Predictions! "></a><a href="https://medium.com/@Tajchert/boost-your-app-reviews-with-firebase-predictions-19aff4001f27" target="_blank" rel="noopener">Boost your app reviews with Firebase Predictions! </a></h2><p>介绍了利用Firebase正在测试阶段的<code>Predictions</code>帮助我们决定何时弹提醒用户评分的框框.</p><h2 id="Playing-with-Paths"><a href="#Playing-with-Paths" class="headerlink" title="Playing with Paths "></a><a href="https://medium.com/@crafty/playing-with-paths-3fbc679a6f77" target="_blank" rel="noopener">Playing with Paths </a></h2><p>介绍了如何绘制轨迹动画,挺炫酷的,主要使用到了<code>PathDashPathEffect</code>.</p><h2 id="How-to-add-Push-Notification-capability-to-your-Android-app"><a href="#How-to-add-Push-Notification-capability-to-your-Android-app" class="headerlink" title="How to add Push Notification capability to your Android app "></a><a href="https://medium.com/@nileshsingh/how-to-add-push-notification-capability-to-your-android-app-a3cac745e56e" target="_blank" rel="noopener">How to add Push Notification capability to your Android app </a></h2><p>文章介绍了如何通过Firebase Messaging来做推送,包含了详细的Client端的配置,以及Server端的Initialize.</p><h2 id="Animations-with-ConstraintLayout-and-ConstraintSet"><a href="#Animations-with-ConstraintLayout-and-ConstraintSet" class="headerlink" title="Animations with ConstraintLayout and ConstraintSet "></a><a href="https://hellsoft.se/animations-with-constraintlayout-and-constraintset-b4634d38981f" target="_blank" rel="noopener">Animations with ConstraintLayout and ConstraintSet </a></h2><p>文章介绍了通过<code>ConstraintSet</code>对<code>ConstraintLayout</code>添加一些如<code>ChangeBounds</code>的动画.</p><h2 id="Getting-started-with-Kotlin-on-Android"><a href="#Getting-started-with-Kotlin-on-Android" class="headerlink" title="Getting started with Kotlin on Android "></a><a href="https://blog.sourcerer.io/getting-started-with-kotlin-on-android-6242a5f6fd57" target="_blank" rel="noopener">Getting started with Kotlin on Android </a></h2><p>Kotlin简单的入门教程,包含IDE的配置,以及几个Kotlin的特点,如when等等.非常初级,想入门的可以多看看…呵呵…</p><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="hyperlog-android"><a href="#hyperlog-android" class="headerlink" title="hyperlog-android "></a><a href="https://github.com/hypertrack/hyperlog-android" target="_blank" rel="noopener">hyperlog-android </a></h2><p>可以将log记录发到后台的一个库.</p><h2 id="android-clean-architecture-mvi-boilerplate"><a href="#android-clean-architecture-mvi-boilerplate" class="headerlink" title="android-clean-architecture-mvi-boilerplate "></a><a href="https://github.com/bufferapp/android-clean-architecture-mvi-boilerplate" target="_blank" rel="noopener">android-clean-architecture-mvi-boilerplate </a></h2><p>所谓基于MVI的Clean Architecture.</p><h2 id="ReactiveNetwork"><a href="#ReactiveNetwork" class="headerlink" title="ReactiveNetwork "></a><a href="https://github.com/pwittchen/ReactiveNetwork" target="_blank" rel="noopener">ReactiveNetwork </a></h2><p>基于RxJava监听网络状态的库.</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Kotlin" scheme="http://talentprince.github.io/tags/Kotlin/"/>
    
      <category term="Room" scheme="http://talentprince.github.io/tags/Room/"/>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="Clean Architecture" scheme="http://talentprince.github.io/tags/Clean-Architecture/"/>
    
      <category term="Android Notification" scheme="http://talentprince.github.io/tags/Android-Notification/"/>
    
      <category term="Path Animation" scheme="http://talentprince.github.io/tags/Path-Animation/"/>
    
      <category term="ConstraintSet Animation" scheme="http://talentprince.github.io/tags/ConstraintSet-Animation/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #288</title>
    <link href="http://talentprince.github.io/2017/12/31/Android-Weekly-Issue-288/"/>
    <id>http://talentprince.github.io/2017/12/31/Android-Weekly-Issue-288/</id>
    <published>2017-12-31T03:35:55.000Z</published>
    <updated>2020-06-22T09:44:59.473Z</updated>
    
    <content type="html"><![CDATA[<p>December 17th, 2017</p><h2 id="Android-Weekly-Issue-288"><a href="#Android-Weekly-Issue-288" class="headerlink" title="Android Weekly Issue #288"></a><a href="http://androidweekly.net/issues/issue-288" target="_blank" rel="noopener">Android Weekly Issue #288</a></h2><p>本期内容主要包括介绍Kotlin DSL使用kotlin来写gradle,如何组织Session,以及MVP如何通过LifeCycler来简化,如何让多个presenter之间相互交互.<br>特别推荐的有如何使用kotlin优化多方法的接口,有多达四种方法,是学习kotlin lambda优化的好机会,以及如何使用kotlin架构跨平台应用.</p><p>代码部分有趣的是一个可以画dagger依赖关系的库,但还支持的不完善,以及西班牙人封装Espresso的一个库,叫<code>Barista</code>.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="How-to-develop-image-gallery-app-in-Android-using-Kotlin"><a href="#How-to-develop-image-gallery-app-in-Android-using-Kotlin" class="headerlink" title="How to develop image gallery app in Android using Kotlin "></a><a href="http://developine.com/develop-android-image-gallery-app-kotlin-with-source-code/" target="_blank" rel="noopener">How to develop image gallery app in Android using Kotlin </a></h2><p>作者分析了自己用kotlin写的一个相册应用,里面用了很多kotlin相关的知识.</p><h2 id="The-Power-of-Gradle-Kotlin-DSL"><a href="#The-Power-of-Gradle-Kotlin-DSL" class="headerlink" title="The Power of Gradle Kotlin DSL "></a><a href="https://blog.simon-wirtz.de/the-power-of-gradle-kotlin-dsl/" target="_blank" rel="noopener">The Power of Gradle Kotlin DSL </a></h2><p>文章介绍了作者将本来<code>groovy</code>的gradle.build改成了使用<code>kotlin.dsl</code>写的gradle.build.kts,做到用kotlin来写gradle,是不是很嗨森.</p><h2 id="How-to-host-a-conference-within-your-team"><a href="#How-to-host-a-conference-within-your-team" class="headerlink" title="How to host a conference within your team "></a><a href="https://medium.com/car2godevs/how-to-host-a-conference-within-your-team-2540f8df10d7" target="_blank" rel="noopener">How to host a conference within your team </a></h2><p>教你如何组织公司内部的session,首先通过表单收集话题,然后对话题进行投票,然后根据话题的多少指定break,呵呵,感觉外国人真的是很天真烂漫~~~</p><h2 id="Using-Architecture-Components-with-Firebase-part-1"><a href="#Using-Architecture-Components-with-Firebase-part-1" class="headerlink" title="Using Architecture Components with Firebase (part 1) "></a><a href="https://firebase.googleblog.com/2017/12/using-android-architecture-components.html" target="_blank" rel="noopener">Using Architecture Components with Firebase (part 1) </a></h2><p>文章用<code>Firebase Realtime</code>来讲解如何通过<code>Architecture Component</code>将程序重构成成MVVM架构,将Firebase数据库封装成<code>LiveData</code>并放在<code>ViewModel</code>里,这样生命周期与activity绑定,也利于测试.</p><h2 id="Task-Stack"><a href="#Task-Stack" class="headerlink" title="Task Stack "></a><a href="https://blog.stylingandroid.com/task-stack/" target="_blank" rel="noopener">Task Stack </a></h2><p>文章介绍了通过解决通过Notification打开某activity,但后退直接退出而不是回到上一级的用户体验问题.<br>即通过<code>TaskStackBuilder</code>来创建具有parent activity的pending intent.<br>具体可以看代码,作者没有提到,如果在manifest里面声明了,还可以使用<code>NavUtils</code>来简化一些流程.</p><h2 id="MVP-amp-Lifecycles-amp-Dispatchers-Oh-My"><a href="#MVP-amp-Lifecycles-amp-Dispatchers-Oh-My" class="headerlink" title="MVP &amp; Lifecycles &amp; Dispatchers Oh My! "></a><a href="https://medium.com/s23nyc-tech/mvp-lifecycles-dispatchers-oh-my-19eda37a1a52" target="_blank" rel="noopener">MVP &amp; Lifecycles &amp; Dispatchers Oh My! </a></h2><p>文章介绍了MVP的实际应用,我觉得除了大家所熟知的一些基本思路,这里有两点值得说道说道.</p><p>一是通过Presenter订阅<code>Lifecycle</code>,可以自动实现onAttach与onDetach.</p><p>二是实现一个<code>Dispatcher</code>,为所有presenter持有.内部是一个<code>PublishSubject</code>,不同presenter的方法通过<code>ofType</code>监听自己关注的的<code>state</code>,不同模块的presenter之间通过<code>publish state</code>相互通信.</p><h2 id="Listeners-with-several-functions-in-Kotlin"><a href="#Listeners-with-several-functions-in-Kotlin" class="headerlink" title="Listeners with several functions in Kotlin "></a><a href="https://antonioleiva.com/listeners-several-functions-kotlin/" target="_blank" rel="noopener">Listeners with several functions in Kotlin </a></h2><p>文章介绍了如何使用好的方法在kotlin里处理多方法的接口.并以大家熟知的Animator.Listener举例子.</p><p>这个四个方法的接口,如果我们只希望实现一个,最直接的方法就是使用<code>AnimatorListenerAdapter</code>,但是它是一个抽象类,继承该类就不能继承别的类了.</p><p>第一种解决方法就是kotlin的interface支持写code,所以自定义的没必要是一个抽象类而还是一个接口,所有的方法赋值<code>= Unit</code>即可.</p><p>第二种方法是使用Exstension,给<code>ViewPropertyAnimator</code>写扩展,参数是<code>(Animator)-&gt;Unit</code>,而在内部实现<code>AnimatorListnerAdapter</code>,然后将其回调中的参数通过我们扩展方法的Lambda返回,由于内部套用回调,为了实现整体扩展方法的inline,参数<code>(Animator)-&gt;Unit</code>需要加<code>crossinline</code>标识.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inline fun ViewPropertyAnimator.onAnimationEnd(crossinline continuation: (Animator) -&gt; Unit) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>第三种方法是基于第二种,传入四个lambda参数(<code>(Animator)-&gt;Unit</code>),使用了<code>named argument</code>特性,并都赋默认值<code>{}</code>,这样想实现哪个,就指定名字即可.</p><p>第四种使用了<code>Lambda with Receiver</code>,或者交<code>Extension function lambda</code>,最kotlin的一种封装,扩展方法setListener的参数是<code>AnimListenerHelper.() -&gt; Unit</code>,而AnimLisnerHelper本身实现了所有Animator接口的四个方法,并提供四个方法将<code>(Animator)-&gt;Unit</code>作为参数保存在Helper类内,代理给之前override Animator的四个回调.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">view.animate()</span><br><span class="line">        .setListener &#123;</span><br><span class="line">            onAnimationStart &#123;...&#125;</span><br><span class="line">            onAnimationEnd &#123;...&#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="Architecture-for-Multiplatform-native-development-in-Kotlin"><a href="#Architecture-for-Multiplatform-native-development-in-Kotlin" class="headerlink" title="Architecture for Multiplatform native development in Kotlin "></a><a href="https://blog.kotlin-academy.com/architecture-for-multiplatform-development-in-kotlin-cc770f4abdfd" target="_blank" rel="noopener">Architecture for Multiplatform native development in Kotlin </a></h2><p>文章介绍了使用kotlin实现跨平台应用的架构思想,通过Kotlin/Jvm,Kotlin/JS,以及正在beta研发阶段的Kotlin/Native,可以实现横跨backend到所有前端设备的庞大系统,而整体又基于MVP的思想.</p><p>由上之下大概的分层是</p><p>common (DataModel)</p><p>common-platform (平台相关DomainModel, 使用Kotlin Multiplatform的<code>require/actual</code>)</p><p>common-client (MVP抽象)</p><p>common-client-repo-platform (平台相关的Repo)</p><p>views (不同平台的view实现)</p><p>对于iOS与Android,又会在view之上抽象出来一层为<code>watch</code>,<code>tv</code>,<code>car</code>,<code>phone</code>等公用.叫做<code>Common Android/iOS Elements</code>.</p><p>是不是很六百~.</p><h2 id="Testing-RxJava-code-made-easy"><a href="#Testing-RxJava-code-made-easy" class="headerlink" title="Testing RxJava code made easy "></a><a href="https://medium.com/@vanniktech/testing-rxjava-code-made-easy-4cc32450fc9a" target="_blank" rel="noopener">Testing RxJava code made easy </a></h2><p>RxJava2提供了test observable,可以通过<code>Observable.test</code>进行各种assert.</p><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="daggraph"><a href="#daggraph" class="headerlink" title="daggraph "></a><a href="https://github.com/dvdciri/daggraph" target="_blank" rel="noopener">daggraph </a></h2><p>画dagger依赖图的,但是还有不少不支持的,如<code>Construtor Inject</code>等等.在开发中.</p><h2 id="Cipher-so"><a href="#Cipher-so" class="headerlink" title="Cipher.so "></a><a href="https://github.com/MEiDIK/Cipher.so" target="_blank" rel="noopener">Cipher.so </a></h2><p>很好用的native加密库.</p><h2 id="Barista"><a href="#Barista" class="headerlink" title="Barista "></a><a href="https://github.com/SchibstedSpain/Barista" target="_blank" rel="noopener">Barista </a></h2><p>封装了Espresso,简化了很多API的使用.</p><h2 id="artist"><a href="#artist" class="headerlink" title="artist "></a><a href="https://github.com/uber/artist" target="_blank" rel="noopener">artist </a></h2><p>可以给View里面添加方法的一个插件,如添加一些判断Visibility的方法.</p><h2 id="TimeLineView"><a href="#TimeLineView" class="headerlink" title="TimeLineView "></a><a href="https://github.com/po10cio/TimeLineView" target="_blank" rel="noopener">TimeLineView </a></h2><p>一个基于<code>ConstraintLayout</code>与<code>RecyclerView</code>显示时间线的View.</p><h2 id="Kotshi"><a href="#Kotshi" class="headerlink" title="Kotshi "></a><a href="https://github.com/ansman/kotshi" target="_blank" rel="noopener">Kotshi </a></h2><p>给JSON解析库Moshi写的支持Kotlin的库,不过我查了一下,Moshi已经有自己的了,叫<code>moshi-kotlin</code>.</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin DSL" scheme="http://talentprince.github.io/tags/Kotlin-DSL/"/>
    
      <category term="Kotlin Lambda" scheme="http://talentprince.github.io/tags/Kotlin-Lambda/"/>
    
      <category term="Lifecycle" scheme="http://talentprince.github.io/tags/Lifecycle/"/>
    
      <category term="Multi-platform Architecture" scheme="http://talentprince.github.io/tags/Multi-platform-Architecture/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #287</title>
    <link href="http://talentprince.github.io/2017/12/17/Android-Weekly-Issue-287/"/>
    <id>http://talentprince.github.io/2017/12/17/Android-Weekly-Issue-287/</id>
    <published>2017-12-17T06:49:48.000Z</published>
    <updated>2020-06-22T09:44:59.473Z</updated>
    
    <content type="html"><![CDATA[<p>December 10th, 2017</p><h2 id="Android-Weekly-Issue-287"><a href="#Android-Weekly-Issue-287" class="headerlink" title="Android Weekly Issue #287"></a><a href="http://androidweekly.net/issues/issue-287" target="_blank" rel="noopener">Android Weekly Issue #287</a></h2><p>圣诞节快要来了,小编也偷懒了,本期内容包括如何通过AS添加网络字体库,以及如何使用Dagger.Android等实现Clean Architecture,还包含一篇Android安全系列的文章,介绍如何实现长数据的加密.</p><p>关于Kotlin的技巧以及系统数据库的替代品,也有各有两篇系列文章,值得一看.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="The-Android-Developer’s-Guide-to-Better-Typography"><a href="#The-Android-Developer’s-Guide-to-Better-Typography" class="headerlink" title="The Android Developer’s Guide to Better Typography "></a><a href="https://medium.com/google-design/the-android-developers-guide-to-better-typography-97e11bb0e261" target="_blank" rel="noopener">The Android Developer’s Guide to Better Typography </a></h2><p>文章介绍了如何利用Androis Studio为你的View添加新的Font.</p><p>在AS3.0中,可以通过从Layout的的Design Tab中的<code>Component Tree</code>里选择你想要添加font的View,然后在右侧的Attribute里面找到<code>font family</code>,然后就可以添加自己想要的font,还可以是通过Google Font Provider来的网络字体.</p><p>其会在你的<code>res/font</code>下生成字体配置文件,这里可以通过<code>app:fontProviderFetchStrategy</code>设置加载策略,如<code>block</code>,可以避免没下载完成字体被切.</p><p>在生成的配置文件中,还有一个比较重要的就是,<code>res/values</code>下面的<code>preloaded_fonts</code>,定义了会加载的字体名字.</p><h2 id="Clean-Architecture-Kotlin-Dagger-2-RxJava-MVVM-and-Unit-Testing"><a href="#Clean-Architecture-Kotlin-Dagger-2-RxJava-MVVM-and-Unit-Testing" class="headerlink" title="Clean Architecture - Kotlin, Dagger 2, RxJava, MVVM and Unit Testing "></a><a href="https://medium.com/@rahul.singh/clean-architecture-kotlin-dagger-2-rxjava-mvvm-and-unit-testing-dc05dcdf3ce6" target="_blank" rel="noopener">Clean Architecture - Kotlin, Dagger 2, RxJava, MVVM and Unit Testing </a></h2><p>文章介绍了Clean Architecture的结构以及如何对ViewModel进行测试(mock Repository).</p><p>值得一提的是,这里大概介绍了Dagger2.Android,帮助我们轻松的进行DI,通过<code>ContributesAndroidInjector</code>将zhiding的Activity生成<code>AndroidInjector</code>,来帮助我们更轻松的对Activity以及Fragment进行注入.</p><p>关于Dagger2.Android详情也参考之前的<a href="http://talentprince.github.io/2017/09/30/Advanced-Dagger2-Skills/">文章</a>.</p><h2 id="Secure-data-in-Android-—-Encrypting-Large-Data"><a href="#Secure-data-in-Android-—-Encrypting-Large-Data" class="headerlink" title="Secure data in Android — Encrypting Large Data "></a><a href="https://proandroiddev.com/secure-data-in-android-encrypting-large-data-dda256a55b36" target="_blank" rel="noopener">Secure data in Android — Encrypting Large Data </a></h2><p>文章继续介绍如何对大量数据的加密,在Android里非对称加密<code>RSA</code>对加密长度有限制,并且只能在Android18以上可以设置,最大<code>4096</code>bit,显然不符合我们的要求.</p><p>对于Android M以上,系统的KeyStore可以支持生成对称加密秘钥了,所以我们可以直接通过生成<code>ASE</code>秘钥对大量数据进行对称加密.</p><p>但是对于M以下的系统,我们只能通过Java的Key Provider生成一个秘钥文件,存放在某处,这样不是非常安全.解决方案就是,通过<code>RSA</code>对生成的<code>ASE</code>秘钥进行加密后在放在储存器中,解密时先通过<code>RSA</code>对秘钥进行解密,然后再进而解密我们的数据. (因为KeyStore是支持生成<code>RSA</code>非对称秘钥,并随着App的拆卸而销毁的.)</p><h2 id="Kotlin-Playground"><a href="#Kotlin-Playground" class="headerlink" title="Kotlin Playground "></a><a href="https://medium.com/@jcmsalves/kotlin-playground-aab8be8ac432" target="_blank" rel="noopener">Kotlin Playground </a></h2><p>作者通过一个Demo记录自己的Kotlin学习之旅,并附上了一些自己的学习资料,包含视频资料哦.</p><h2 id="6-magic-sugars-that-can-make-your-Kotlin-codebase-happier-Part-1"><a href="#6-magic-sugars-that-can-make-your-Kotlin-codebase-happier-Part-1" class="headerlink" title="6 magic sugars that can make your Kotlin codebase happier - Part 1 "></a><a href="https://medium.com/grand-parade/6-magic-sugars-that-can-make-your-kotlin-codebase-happier-part-1-ceee3c2bc9d3" target="_blank" rel="noopener">6 magic sugars that can make your Kotlin codebase happier - Part 1 </a></h2><p>一个系列文章,介绍Kotlin的牛逼之处.</p><p>本篇介绍了通过<code>seal class</code>来将不同的类型关联起来实现更强功能的Enum,然后配合<code>when</code>来方便swich逻辑.</p><p>还可以将几种<code>seal class</code>合成Pair(<code>left to right</code>)或者Triple(<code>left to mid to right</code>)来穿给<code>when</code>做条件筛选.</p><h2 id="6-magic-sugars-that-can-make-your-Kotlin-codebase-happier-Part-2"><a href="#6-magic-sugars-that-can-make-your-Kotlin-codebase-happier-Part-2" class="headerlink" title="6 magic sugars that can make your Kotlin codebase happier - Part 2 "></a><a href="https://medium.com/grand-parade/6-magic-sugars-that-can-make-your-kotlin-codebase-happier-part-2-843bf096fa45" target="_blank" rel="noopener">6 magic sugars that can make your Kotlin codebase happier - Part 2 </a></h2><p>系列文章的第二篇,涉及到如何用<code>with</code>来简化你的代码,并且还介绍了如何封装一个具备类型检测的<code>withCorrectType</code>,这里涉及到一个kotlin的知识点,我们在很早之前的Weekly有提到:</p><p>就是通过<code>inline</code>与<code>reified</code>让泛型参数可以在运行时被<code>is</code>检测,否则泛型类型会被摸去.</p><h2 id="Lessons-from-my-first-multiplatform-Kotlin-project"><a href="#Lessons-from-my-first-multiplatform-Kotlin-project" class="headerlink" title="Lessons from my first multiplatform Kotlin project "></a><a href="https://medium.com/@marcinmoskala/lessons-from-my-first-multiplatform-kotlin-project-d4e311f15874" target="_blank" rel="noopener">Lessons from my first multiplatform Kotlin project </a></h2><p>Kotlin 1.2推出了多平台功能的支持,其提出了将一个程序分为<code>common module</code>, <code>platform module</code>与<code>regular module</code>三层,并且还提供了<code>expect</code> 与 <code>actual</code>的新特性,可以在common层定义expect类与方法,并通过在platform层实现.</p><p>其相较于接口好的一点是,对于<code>expect</code>类用起来跟一个完整的类一样,可以有构造,可以实例化,可以调用所定义的expect方法.</p><p>文章介绍了自己的思路,并指出了MVP在这种跨平台代码中的妙用,让逻辑代码可以共用.</p><h2 id="Tuning-your-SQLite-with-SQLDelight-amp-SQLBrite-Part-1"><a href="#Tuning-your-SQLite-with-SQLDelight-amp-SQLBrite-Part-1" class="headerlink" title="Tuning your SQLite with SQLDelight &amp; SQLBrite: Part 1 "></a><a href="https://medium.com/lalafo-engineering/tuning-your-sqlite-with-sqldelight-sqlbrite-part-1-9568543fe9af" target="_blank" rel="noopener">Tuning your SQLite with SQLDelight &amp; SQLBrite: Part 1 </a></h2><p>文章介绍了<code>SQLBrite</code>相较于系统ContentProvider好用之处,主要是其实对系统API的Rx封装,使得整个数据库的操作做到React.</p><h2 id="Tuning-Your-SQLite-With-SQLDelight-amp-SQLBrite-Part-2"><a href="#Tuning-Your-SQLite-With-SQLDelight-amp-SQLBrite-Part-2" class="headerlink" title="Tuning Your SQLite With SQLDelight &amp; SQLBrite: Part 2 "></a><a href="https://medium.com/lalafo-engineering/tuning-your-sqlite-with-sqldelight-sqlbrite-part-2-11e59c5a3442" target="_blank" rel="noopener">Tuning Your SQLite With SQLDelight &amp; SQLBrite: Part 2 </a></h2><p>文章介绍了<code>SQLDelight</code>,它是一个通过gradle plugin将<code>.sq</code>文件生成Java代码的db.</p><p>如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getImagesById:</span><br><span class="line">SELECT *</span><br><span class="line">FROM images</span><br><span class="line">WHERE ad_id = ?</span><br><span class="line">ORDER BY _id ASC;</span><br></pre></td></tr></table></figure></p><p>就可以生成对应<code>getImagesById(long ad_id)</code>的Java代码.</p><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="Transitioner"><a href="#Transitioner" class="headerlink" title="Transitioner "></a><a href="https://github.com/dev-labs-bg/transitioner" target="_blank" rel="noopener">Transitioner </a></h2><p>定义两个使用<code>ConstraintLayout</code>封装的View,包装成一个<code>transitioner</code>,实现类似Shared Element的那种动画效果.</p><h2 id="HighLite"><a href="#HighLite" class="headerlink" title="HighLite "></a><a href="https://github.com/jeppeman/HighLite" target="_blank" rel="noopener">HighLite </a></h2><p>高度基于Annotation的一个Android DB,通过<code>@SQLiteDatabaseDescriptor</code>,<code>@SQLiteTable</code>,<code>@SQLiteColumn</code>,<code>@PrimaryKey</code>等为主要注解,并且通过<code>@JvmField</code>支持Kotlin.</p><h2 id="android-disposebag"><a href="#android-disposebag" class="headerlink" title="android-disposebag "></a><a href="https://github.com/kizitonwose/android-disposebag" target="_blank" rel="noopener">android-disposebag </a></h2><p>通过绑定Activity或者Fragment的生命周期,初始化一个<code>DisposeBag</code>,将Rx的析构交给它做.支持RxJava/RxKotlin.</p><h2 id="EasyAdapter"><a href="#EasyAdapter" class="headerlink" title="EasyAdapter "></a><a href="https://github.com/MaksTuev/EasyAdapter" target="_blank" rel="noopener">EasyAdapter </a></h2><p>简化使用RecyclerView实现多类型复杂的List.</p><h2 id="CounterView"><a href="#CounterView" class="headerlink" title="CounterView "></a><a href="https://github.com/AnkitKiet/CounterView" target="_blank" rel="noopener">CounterView </a></h2><p>简单的安卓计数器View控件.</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Kotlin" scheme="http://talentprince.github.io/tags/Kotlin/"/>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="Clean Architecture" scheme="http://talentprince.github.io/tags/Clean-Architecture/"/>
    
      <category term="Android Security" scheme="http://talentprince.github.io/tags/Android-Security/"/>
    
      <category term="Android Database" scheme="http://talentprince.github.io/tags/Android-Database/"/>
    
      <category term="RSA" scheme="http://talentprince.github.io/tags/RSA/"/>
    
      <category term="ASE" scheme="http://talentprince.github.io/tags/ASE/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #286</title>
    <link href="http://talentprince.github.io/2017/12/14/Android-Weekly-Issue-286/"/>
    <id>http://talentprince.github.io/2017/12/14/Android-Weekly-Issue-286/</id>
    <published>2017-12-14T00:46:53.000Z</published>
    <updated>2020-06-22T09:44:59.473Z</updated>
    
    <content type="html"><![CDATA[<p>December 3rd, 2017</p><h2 id="Android-Weekly-Issue-286"><a href="#Android-Weekly-Issue-286" class="headerlink" title="Android Weekly Issue #286"></a><a href="http://androidweekly.net/issues/issue-286" target="_blank" rel="noopener">Android Weekly Issue #286</a></h2><p>本期文章包含如何通过踩坑来学习Kotlin,以及利用Kotlin的<code>data class</code>做MVVM状态保存,还包含一些基础知识的介绍,如RxJava2线程切换,Kotlin与Java容器分析.</p><p>另外,还包括Intant App的软文一篇,以及 Android O对Notification进行Channel管理的文章,帮助大家适配O以上的通知.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="Some-useful-insights-on-Instant-apps"><a href="#Some-useful-insights-on-Instant-apps" class="headerlink" title="Some useful insights on Instant apps "></a><a href="https://medium.com/nos-digital/some-useful-insights-on-instant-apps-67cc7d177695" target="_blank" rel="noopener">Some useful insights on Instant apps </a></h2><p>文章介绍了荷兰的新闻应用NOS支持IA的实例,技术成分不多,更像是新闻报道,需要了解IA具体实现的可能得不到想要的.</p><h2 id="Using-Espresso-to-Test-Opening-Links"><a href="#Using-Espresso-to-Test-Opening-Links" class="headerlink" title="Using Espresso to Test Opening Links "></a><a href="https://collectiveidea.com/blog/archives/2017/11/29/using-espresso-to-test-opening-links" target="_blank" rel="noopener">Using Espresso to Test Opening Links </a></h2><p>一个女博主的小发现,如何通过Espresso测试通过TextView的autolink打开其他程序.</p><p>其实是通过<a href="https://developer.android.com/reference/android/support/test/espresso/action/ViewActions.html#openLinkWithText(java.lang.String" target="_blank" rel="noopener">openLinkWithText</a>)来发出这个事件.</p><h2 id="Learning-Kotlin-by-Mistake"><a href="#Learning-Kotlin-by-Mistake" class="headerlink" title="Learning Kotlin by Mistake "></a><a href="https://engineering.udacity.com/learning-kotlin-by-mistake-b99304b7d724" target="_blank" rel="noopener">Learning Kotlin by Mistake </a></h2><p>文章介绍了在错误中不断前行,学习Kotlin相别于Java的特性.</p><p>如尽量的通过<code>applay</code> <code>run</code> <code>let</code> <code>with</code>等操作符将你的逻辑连起来.</p><p><code>CompanionObjects</code>与<code>@JvmStatic</code> <code>@JvmField</code>的取舍</p><p><code>lateinit</code>与<code>by lazy</code>的故事,以及自定义Delegate等等.</p><p>最笨的办法也可以通过自动转换来学习,但是自动转换出来的并不是完全纯粹的Kotlin哦.</p><h2 id="Paper-Signals-A-Voice-Experiment"><a href="#Paper-Signals-A-Voice-Experiment" class="headerlink" title="Paper Signals: A Voice Experiment "></a><a href="https://papersignals.withgoogle.com/" target="_blank" rel="noopener">Paper Signals: A Voice Experiment </a></h2><p>一个IoT的教学,制作一个声音盒子,通过你的语音可以变形. 比较有趣的是盒子的模型零件可以打印出来自己剪裁.<br>需要的Code他们已经提供了.</p><p>当然最重要的是,需要买材料,$24.95.</p><h2 id="Kotlin-Collections-Inside-Part-1"><a href="#Kotlin-Collections-Inside-Part-1" class="headerlink" title="Kotlin Collections Inside. Part 1 "></a><a href="https://www.runtastic.com/blog/en/tech/kotlin-collections-inside-part-1/" target="_blank" rel="noopener">Kotlin Collections Inside. Part 1 </a></h2><p>一个分析Kotlin容器的系列文章,这是第一篇,关于List.</p><p>主要讲了Java与Kotlin容器的关系,对于Kotlin来说,所有Java的容器都是Mutable的,而对于Java来说Kotlin的Immutable容器可以调用改动操作,但是会抛异常.</p><p>并且介绍了Kotlin如何初始化Immutable与Mutable的List,通过ByteCode分析,虽然MutableList没有继承与Java的ArrayList,但是通过<code>arrayListOf</code>与<code>mutableListOf</code>生成的List可以互转,原因是MutableList在生成ByteCode后,也同样继承了ArrayList….</p><h2 id="Multi-Threading-Like-a-Boss-in-Android-With-RxJava-2"><a href="#Multi-Threading-Like-a-Boss-in-Android-With-RxJava-2" class="headerlink" title="Multi-Threading Like a Boss in Android With RxJava 2 "></a><a href="https://blog.gojekengineering.com/multi-threading-like-a-boss-in-android-with-rxjava-2-b8b7cf6eb5e2" target="_blank" rel="noopener">Multi-Threading Like a Boss in Android With RxJava 2 </a></h2><p>文章主要讲了RxJava2如何在线程之间随意切换的,虽然没有涉及实现原理,但是通俗的讲解了<code>subscribeOn</code>与<code>observerOn</code>的使用.一个是改变<code>source</code>,一个是改变<code>downstream</code>.</p><h2 id="Oreo-Notifications-Channels-–-Part-1"><a href="#Oreo-Notifications-Channels-–-Part-1" class="headerlink" title="Oreo Notifications: Channels – Part 1 "></a><a href="https://blog.stylingandroid.com/oreo-notifications-channels-part-1/" target="_blank" rel="noopener">Oreo Notifications: Channels – Part 1 </a></h2><p>文章介绍Android O对于Notification的新概念,<code>Channel</code>,对于没有使用新的Notification Compat API设置Channel的,将不会再Android O上弹出通知.</p><p>Channel是为了让用户对程序的不同Notification进行分组管理,可以对不同Channel分别设置开关,以及通知方式(震动,亮灯,静音等).</p><p>与Channel配合的还有Group,可以将某几个Channel归类于一个Group,在设置页面可以看到不同的Group下的有不同Channel.</p><h2 id="Representing-View-State-with-Kotlin-Data-Classes"><a href="#Representing-View-State-with-Kotlin-Data-Classes" class="headerlink" title="Representing View State with Kotlin Data Classes "></a><a href="https://medium.com/@trionkidnapper/viewmodel-and-kotlin-data-class-7d3a3b854805" target="_blank" rel="noopener">Representing View State with Kotlin Data Classes </a></h2><p>文章介绍了把所有状态封装在一个ViewState的<code>data class</code>里,并通过其<code>copy</code>的方法,对发生变化的状态进行改变,这样可以保持其他状态不变.</p><p>该状态可以作为ViewModel里面的一个Observable被订阅,获取不同状态下的ViewState,对UI进行操作.</p><h2 id="Kotlin-on-the-Backend"><a href="#Kotlin-on-the-Backend" class="headerlink" title="Kotlin on the Backend "></a><a href="https://medium.com/rocket-travel-engineering/kotlin-on-the-backend-at-rocket-travel-31da239888db" target="_blank" rel="noopener">Kotlin on the Backend </a></h2><p>Rocket Travel已经使用Kotlin做Spring Boot开发一年有余,评价很好,可以在后端开发中使用到Kolin的feature,一定很High.</p><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="RoboPOJOGenerator"><a href="#RoboPOJOGenerator" class="headerlink" title="RoboPOJOGenerator "></a><a href="https://github.com/robohorse/RoboPOJOGenerator" target="_blank" rel="noopener">RoboPOJOGenerator </a></h2><p>一个插件可以直接将JSON转成Java或者Kotlin的POJO文件…</p><h2 id="avdo"><a href="#avdo" class="headerlink" title="avdo "></a><a href="https://github.com/alexjlockwood/avdo" target="_blank" rel="noopener">avdo </a></h2><p>Python的包,可以优化Vector动画或者Drawable文件.</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Kotlin" scheme="http://talentprince.github.io/tags/Kotlin/"/>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="RxJava2" scheme="http://talentprince.github.io/tags/RxJava2/"/>
    
      <category term="Instant App" scheme="http://talentprince.github.io/tags/Instant-App/"/>
    
      <category term="Android Oreo" scheme="http://talentprince.github.io/tags/Android-Oreo/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #285</title>
    <link href="http://talentprince.github.io/2017/12/05/Android-Weekly-Issue-285/"/>
    <id>http://talentprince.github.io/2017/12/05/Android-Weekly-Issue-285/</id>
    <published>2017-12-05T06:30:47.000Z</published>
    <updated>2020-06-22T09:44:59.472Z</updated>
    
    <content type="html"><![CDATA[<p>November 26th, 2017</p><h2 id="Android-Weekly-Issue-285"><a href="#Android-Weekly-Issue-285" class="headerlink" title="Android Weekly Issue #285"></a><a href="http://androidweekly.net/issues/issue-285" target="_blank" rel="noopener">Android Weekly Issue #285</a></h2><p>本周包含好几篇Kotlin的文章,如通过Property Delegate实现SharedPreference的自动读写,Coroutines编写Weather应用的终结篇,还有关于如何写好代码的方法论的Tips,以及MVI的全面介绍,如果不喜欢Mosby的approach,可能这个作者从头到尾实现的更有看头.</p><p>当然如果想了解Android最流行的pipeline如何开发,可以去看一篇关于Devops的文章.对代码感兴趣的,看看MVI也是不错的.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="Shrinking-APKs-growing-installs"><a href="#Shrinking-APKs-growing-installs" class="headerlink" title="Shrinking APKs, growing installs "></a><a href="https://medium.com/googleplaydev/shrinking-apks-growing-installs-5d3fcba23ce2" target="_blank" rel="noopener">Shrinking APKs, growing installs </a></h2><p>文章通过数据分析每提升6M的apk大小,就会损失1%的用户,原因大多因为流量.<br>文章还拿出了google内部的数据图,发现北美使用的应用大,东亚非洲使用的小,殊不知天朝不用google play…</p><h2 id="Multi-currency-support-in-Java-Drivy-Engineering"><a href="#Multi-currency-support-in-Java-Drivy-Engineering" class="headerlink" title="Multi-currency support in Java | Drivy Engineering "></a><a href="https://drivy.engineering/multi-currency-java/" target="_blank" rel="noopener">Multi-currency support in Java | Drivy Engineering </a></h2><p>一个简单的支持数字转货币格式的库,包括同种货币在不同国家不同的显示方式.</p><h2 id="The-Contract-of-the-Model-View-Intent-Architecture"><a href="#The-Contract-of-the-Model-View-Intent-Architecture" class="headerlink" title="The Contract of the Model-View-Intent Architecture "></a><a href="https://proandroiddev.com/the-contract-of-the-model-view-intent-architecture-777f95706c1e" target="_blank" rel="noopener">The Contract of the Model-View-Intent Architecture </a></h2><p>作者对MVI进行了详细的分解,实现了MVI不同模块的Contract,并分析了各个模块的基本职责.</p><p>整体的思路大致如下,形成一个回路:</p><p>View -&gt; Intent –(intent to action)–&gt; Action –(processor)–&gt; Result –(reducer)–&gt; State –(render)–&gt; View</p><h2 id="Function-references-in-Kotlin-use-functions-as-lambdas-everywhere"><a href="#Function-references-in-Kotlin-use-functions-as-lambdas-everywhere" class="headerlink" title="Function references in Kotlin: use functions as lambdas everywhere "></a><a href="https://antonioleiva.com/function-references-kotlin/" target="_blank" rel="noopener">Function references in Kotlin: use functions as lambdas everywhere </a></h2><p>文章讲解了Function Reference (<code>::function</code>)的使用,可以作为lmbda当参数传递,并且生成的bytecode里面会少一个形参的临时变量的创建,相当于把lambda表达式的回调参数inline了.</p><h2 id="Onboard-your-users-with-Lottie-of-Spritz"><a href="#Onboard-your-users-with-Lottie-of-Spritz" class="headerlink" title="Onboard your users with Lottie of Spritz "></a><a href="https://www.novoda.com/blog/onboard-your-users-with-lottie-of-spritz/" target="_blank" rel="noopener">Onboard your users with Lottie of Spritz </a></h2><p>文章介绍了作者自己弄的一个库Spritz,来做引导画面,将ViewPager于AirBnB的LottieAnimationView结合起来,可以通过swipe来触发动画,或者自动触发.</p><h2 id="Room-Migration"><a href="#Room-Migration" class="headerlink" title="Room Migration "></a><a href="https://android.jlelse.eu/android-architecture-components-room-migration-1a269e1aeef7" target="_blank" rel="noopener">Room Migration </a></h2><p>文章介绍了Room如何做DB Migration,与一般的数据库相同,其提供了直接Drop&amp;ReConstruct以及提供相应的Migeration语句两种办法.<br><code>fallbackToDestructiveMigration</code>与<code>addMigrations</code></p><h2 id="Simple-but-painful-steps-for-writing-a-better-code"><a href="#Simple-but-painful-steps-for-writing-a-better-code" class="headerlink" title="Simple but painful steps for writing a better code "></a><a href="https://medium.com/car2godevs/simple-but-painful-steps-for-writing-a-better-code-afb2651cef86" target="_blank" rel="noopener">Simple but painful steps for writing a better code </a></h2><p>作者介绍了几条写更好的代码的原则.</p><ul><li>不要在Class内部再new新的object,应该通过构造注入.</li><li>不要依赖于单例,如果有可直接通过构造传入.</li><li>不要再取Manager/Processor/Hanlder之类的类名,这样会使这个类加入越来越多不太相关的东西.</li><li>不要无脑的继承,有时候组合也挺好.</li></ul><h2 id="The-Art-of-Android-DevOps-–-Undabot"><a href="#The-Art-of-Android-DevOps-–-Undabot" class="headerlink" title="The Art of Android DevOps – Undabot "></a><a href="https://blog.undabot.com/the-art-of-android-devops-fa29396bc9ee" target="_blank" rel="noopener">The Art of Android DevOps – Undabot </a></h2><p>文章介绍了什么是Android DevOps,其实这些Work我们都在做,只是没有独立出来这个Role罢了,其工作内容包括:</p><ul><li>CI/CD</li><li>Automated Test (UT, InstrumentTest, PIT)</li><li>Code check (Findbugs, checkstyle, PMD)</li><li>Deploy (fastlane)</li></ul><h2 id="9-RxJava-2-Migration-Learnings-At-Runtastic"><a href="#9-RxJava-2-Migration-Learnings-At-Runtastic" class="headerlink" title="9 RxJava 2 Migration Learnings At Runtastic "></a><a href="https://www.runtastic.com/blog/en/tech/rxjava-2-migration-learnings/" target="_blank" rel="noopener">9 RxJava 2 Migration Learnings At Runtastic </a></h2><p>介绍了九条从RxJava1升到RxJava2应该注意的东西,比较值得注意的是在测试的时候可以通过Observable.test转换后进行assert,还有应该推广使用<code>Completion</code>,<code>Maybe</code>等在恰当的场合,还有不能滥用<code>Flowable</code>除非你有背压需求.</p><h2 id="Kotlin-Contexts-amp-SharedPreferences"><a href="#Kotlin-Contexts-amp-SharedPreferences" class="headerlink" title="Kotlin: Contexts &amp; SharedPreferences "></a><a href="https://blog.stylingandroid.com/kotlin-contexts-sharedpreferences/" target="_blank" rel="noopener">Kotlin: Contexts &amp; SharedPreferences </a></h2><p>作者通过Property Delegation写了个SharedPreferenceDelegate,这样需要储存的变量只需要通过<code>by</code>交给这个delegate就可以完成数据的自动读写.</p><p>如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var value: Int by bindSharedPreference(context, KEY, DEFAULT_VALUE)</span><br></pre></td></tr></table></figure></p><h2 id="Clean-Code-App-with-Kotlin-and-Architecture-Components-—-Part-3"><a href="#Clean-Code-App-with-Kotlin-and-Architecture-Components-—-Part-3" class="headerlink" title="Clean-Code App with Kotlin and Architecture Components — Part 3 "></a><a href="https://blog.elpassion.com/create-a-clean-code-app-with-kotlin-coroutines-and-android-architecture-components-part-3-f3f3850acbe6" target="_blank" rel="noopener">Clean-Code App with Kotlin and Architecture Components — Part 3 </a></h2><p>使用Kotlin Coroutines优化程序的最后一个Part,主要是UI部分,结合了Architecture Components的ViewModel与LiveData.</p><p>对于Coroutines,作者的看法是它是用来与RxJava竞争的,帮助大家接触Callback Hell,而且它也可以跟RxJava结合使用.</p><p>其核心思想就是对于suspendable function的理解,帮助实现看似同步的异步世界.</p><h2 id="Kotlin-From-The-Trenches"><a href="#Kotlin-From-The-Trenches" class="headerlink" title="Kotlin From The Trenches "></a><a href="https://blog.devexperts.com/kotlin-from-the-trenches/" target="_blank" rel="noopener">Kotlin From The Trenches </a></h2><p>一片宏观介绍Kotlin如何牛逼的文章,Android的Java被锁定在了1.6,即便有了sugar,还是不能完全支持1.8,Kotlin应运而生.</p><p>至于Kotlin的优势,这里不做阐述了,类似的文章太多了,建议大家都去用一下,因为只有真正使用了,才能有比较大的进步.</p><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="spritz"><a href="#spritz" class="headerlink" title="spritz "></a><a href="https://github.com/novoda/android-demos/tree/master/spritz" target="_blank" rel="noopener">spritz </a></h2><p>做一个基于ViewPager的引导界面.</p><h2 id="Droid-Snippet"><a href="#Droid-Snippet" class="headerlink" title="Droid-Snippet "></a><a href="https://github.com/KingsMentor/Droid-Snippet" target="_blank" rel="noopener">Droid-Snippet </a></h2><p>一个AS的查件,有点像代码宝典,内置了各种Util类的方法,可以一键呼出,复制粘贴分分钟.包含Network,Image,File,Permission,Service等等等等….</p><h2 id="koin"><a href="#koin" class="headerlink" title="koin "></a><a href="https://github.com/Ekito/koin" target="_blank" rel="noopener">koin </a></h2><p>之前有介绍过一个Kotlin的Inject框架,相较于Dagger还是有很大的优势,至少配置起来容易.</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Kotlin" scheme="http://talentprince.github.io/tags/Kotlin/"/>
    
      <category term="Kotlin Coroutines" scheme="http://talentprince.github.io/tags/Kotlin-Coroutines/"/>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="RxJava2" scheme="http://talentprince.github.io/tags/RxJava2/"/>
    
      <category term="MVI" scheme="http://talentprince.github.io/tags/MVI/"/>
    
      <category term="Clean Code" scheme="http://talentprince.github.io/tags/Clean-Code/"/>
    
  </entry>
  
</feed>
