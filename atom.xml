<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Weyoung&#39;s Blog</title>
  
  <subtitle>Nothing can prevent is going to be</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://talentprince.github.io/"/>
  <updated>2022-02-14T10:30:04.835Z</updated>
  <id>http://talentprince.github.io/</id>
  
  <author>
    <name>Prince Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DNS的各种记录类型的应用解析</title>
    <link href="http://talentprince.github.io/2022/02/09/DNS-Types/"/>
    <id>http://talentprince.github.io/2022/02/09/DNS-Types/</id>
    <published>2022-02-09T08:55:30.000Z</published>
    <updated>2022-02-14T10:30:04.835Z</updated>
    
    <content type="html"><![CDATA[<p>可能很多人平时工作中不会遇到DNS配置相关的问题， 但如果偶尔遇到不同类型DNS记录的配置， 在没有搞清楚它们都是干啥的情况下， 会眼花缭乱， 还记得很多年前实验室配置DNS不太对导致只能访问<a href="http://www.instlink.com" target="_blank" rel="noopener">www.instlink.com</a>, 而无法解析subdomain.instlink.com。</p><a id="more"></a><p>现在回头想起来，可能是将A类记录配置成了<a href="http://www.instlink.com导致的，" target="_blank" rel="noopener">www.instlink.com导致的，</a> 所以无法再CNAME到subdomain.instlink.com。</p><p>刚好最近所做的工作中涉及到了一些邮箱方面的DNS的配置，使用Amazon Route53托管，这里简单的将不同种DNS记录类型做一些介绍。</p><h2 id="A-AAAA"><a href="#A-AAAA" class="headerlink" title="A/AAAA"></a>A/AAAA</h2><p>这两种是最基本的DNS记录， 它负责绑定域名与对应的IP地址， 只不过<code>A</code>绑定的IPv4， 而<code>AAAA</code>绑定的IPv6。</p><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo.example.com.   A    192.0.2.23</span><br></pre></td></tr></table></figure></p><p>其中86400是TTL</p><h2 id="CNAME"><a href="#CNAME" class="headerlink" title="CNAME"></a>CNAME</h2><p>CNAME（canonical name）是A记录的alias或者叫做lieu， 一般用作绑定subdomain，或者其他domain与主domain的关系， 而且它只能指向一个domain。</p><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar.example.com.    CNAME  example.net.</span><br></pre></td></tr></table></figure></p><p>CNAME的查找是单条的， 也就是如果xyz.bar.example.com来了就无法命中这条CNAME记录， 但是还有另外一个叫<code>DNAME</code>的可以映射整个subtree，且DNS服务器在处理DNAME时，其实也是产生对应的CNAME来解析。</p><p>所以如果存在一条DNAME，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar.example.com.    DNAME  example.net.</span><br></pre></td></tr></table></figure></p><p>那么解析的过程是通过如下的CNAME来完成的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xyz.bar.example.com.  CNAME  xyz.example.net</span><br></pre></td></tr></table></figure></p><h2 id="MX"><a href="#MX" class="headerlink" title="MX"></a>MX</h2><p>Mail Exchange， 这个是专门给邮件用的，依据SMTP协议，通过这个DNS地址找到对应的邮件服务器host，所以这个类型的记录也只能指向一个域名，而不能是IP地址。</p><p>例子：</p><table><thead><tr><th style="text-align:left">Domain</th><th style="text-align:left">TTL</th><th style="text-align:left">Class</th><th style="text-align:left">Type</th><th style="text-align:left">Priority</th><th style="text-align:left">Host</th></tr></thead><tbody><tr><td style="text-align:left">example.com.</td><td style="text-align:left">1936</td><td style="text-align:left">IN</td><td style="text-align:left">MX</td><td style="text-align:left">10</td><td style="text-align:left">onemail.example.com.</td></tr></tbody></table><h2 id="TXT"><a href="#TXT" class="headerlink" title="TXT"></a>TXT</h2><p>TXT就跟他的名字一样， 会返回一段文本， 本来的设计是用来返回人可以阅读的信息， 现在主要用于邮件防Spam， 以及域名所有者声明。</p><p>例子：</p><table><thead><tr><th>Domain</th><th>Type</th><th>Value</th><th>TTL</th></tr></thead><tbody><tr><td>example.com.</td><td>TXT</td><td>This is an awesome domain! Definitely not spammy.</td><td>32600</td></tr></tbody></table><p>关于如何防止Spam， 有三个基于TXT的DNS记录（SPF，DKIM，DMARC）后面会提到。</p><p>基于IETF在1993年的规范，如果想在TXT里保存Key/Value值，需要双引号（“”）包裹K=V值，但是这个规范往往没有被采纳，所以如果我们去看防Spam的几种DNS记录，是没有加引号的。</p><h2 id="NS"><a href="#NS" class="headerlink" title="NS"></a>NS</h2><p>NameServer用来指定DNS解析服务器的域名，它是用来告诉去哪里来找到对应域名的IP地址的。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example.com. 172800 IN NS ns1.example.com.</span><br></pre></td></tr></table></figure><p>不同的subdomain可以通过NS来指向不同的DNS解析服务器，私有的DNS服务器也可以通过NS指向第三方云服务商提供的地址，这个地址可以是一个IP地址，但是这是一个不好的实践，因为IP地址可能会发生变化，导致DNS无法解析。</p><h2 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h2><p>SOA（start of authority）主要用来保存这个域名的一些重要的信息，包括管理员的email地址。</p><p>例子：</p><table><thead><tr><th>Domain</th><th>Type</th><th>MNAME</th><th>RNAME</th><th>SERIAL</th><th>REFRESH</th><th>RETRY</th><th>EXPIRE</th><th>TTL</th></tr></thead><tbody><tr><td>example.com.</td><td>SOA</td><td>ns.example.com</td><td>admin.example.com</td><td>1</td><td>7200</td><td>900</td><td>120960</td><td>86400</td></tr></tbody></table><p>这里面的<code>RNAME</code>是管理员的Email，只是没有带<code>@</code>，看起来不像而已。</p><h2 id="SRV"><a href="#SRV" class="headerlink" title="SRV"></a>SRV</h2><p>这个代表Service记录，一般是为一些特殊的服务提供host与端口的，如VoIP，即时消息，并且只能指向A或者AAAA类地址，不能是一个CNAME。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_xmpp._tcp.example.com. 86400 IN SRV 10 5 5223 server.example.com.</span><br></pre></td></tr></table></figure><p>如果使用表格来描述，即：</p><table><thead><tr><th>Service</th><th>Protocal</th><th>Name</th><th>Type</th><th>Class</th><th>Priority</th><th>Weight</th><th>Port</th><th>Target</th></tr></thead><tbody><tr><td>XMPP</td><td>TCP</td><td>example.com</td><td>SRV</td><td>10</td><td>5</td><td>5223</td><td>service.example.com</td></tr></tbody></table><h2 id="PTR"><a href="#PTR" class="headerlink" title="PTR"></a>PTR</h2><p>PTR是Pointer Record的缩写， 它可以被理解成A/AAAA记录的反向，一般被用于做防Spam，解决邮件发送问题，系统Log IP <-> 域名转换等。</-></p><p>例子：</p><table><thead><tr><th>Host</th><th>Type</th><th>Points to</th><th>TTL</th></tr></thead><tbody><tr><td>1.0.168.192.in-addr.arpa</td><td>PTR</td><td>host1.example.com</td><td>86400</td></tr><tr><td></td></tr></tbody></table><p>这里面之所以要给IP地址加上<code>in-addr.arpa</code>，是因为IP地址存在.apra顶级域名下，如果是IPv6的地址，需要使用.ip6.arpa。</p><h2 id="DNSKEY"><a href="#DNSKEY" class="headerlink" title="DNSKEY"></a>DNSKEY</h2><p>这条记录内保存了一个公钥，主要是为了用来验证DNSSEC（Domain Name System Security Extensions）的数字签名，保证DNS信息来源于一个真实可靠的DNS服务器。</p><p>例子：</p><table><thead><tr><th>Host</th><th>TTL</th><th>Class</th><th>Type</th><th>Flags</th><th>Protocal</th><th>Algorithm</th><th>Public Key</th></tr></thead><tbody><tr><td>example.com</td><td>3600</td><td>IN</td><td>DNSKEY</td><td>257</td><td>3</td><td>13</td><td>ZhCa3rGLofZcndFN2aVd==</td></tr></tbody></table><p>这里Protocal只能填3，代表<code>DNSSEC</code>， 而算法可以选多种：</p><ul><li>1 = RSA/MD5</li><li>2 = Diffie-Hellman (This is not supported by BIND and Infoblox appliances.)</li><li>3 = DSA</li><li>4 = Reserved</li><li>5 = RSA/SHA1</li><li>6 = DSA/SHA1/NSEC3</li><li>7 = RSA/SHA1/NSEC3</li><li>8 = RSA/SHA-256</li><li>10 = RSA/SHA-512</li></ul><p>Flags相对复杂一些，它是一个2位的长度，并且0-6，8-14都是反向的，bit7表明是否包含DNS Zone Key (ZSK)，bit 15表明是否包含KSK（Key signing key），所以只会有两个值，即256说明里面是ZSK，257是KSK。</p><h2 id="SPF"><a href="#SPF" class="headerlink" title="SPF"></a>SPF</h2><p>这个是邮件防Spam里重要的一员，全称Sender Policy Framework，用来认证发送者。</p><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mail.example.com   TXT   v=spf1 ip4=192.0.2.0 ip4=192.0.2.1 include:examplesender.net -all</span><br></pre></td></tr></table></figure></p><p>其中<code>v=spf1</code>表明这是一条SPF记录，<code>ip4</code>说明了可以使用这个host发送邮件的主机IP地址，<code>include:examplesender.net</code>表明可以允许第三方可以以你的域名来发送邮件，<code>-all</code> 表明不在list上的都没有被授权，应当拒收，如果是<code>+all</code>则表示任何人都可以使用该域名来发送。</p><h2 id="DKIM"><a href="#DKIM" class="headerlink" title="DKIM"></a>DKIM</h2><p>全称为DomainKeys Identified Mail，实际上是也是保存了一个公钥，用来验证邮件的数字签名，保证邮件来路正确。</p><p>发送者在发送邮件的时候带上签名与DKIM的selector以及其他的一些字段在邮件头，接收者通过selector来请求DKIM公钥对签名进行验证。</p><p>例子：</p><table><thead><tr><th>Name</th><th>Type</th><th>Content</th><th>TTL</th></tr></thead><tbody><tr><td>selector._domainkey.example.com</td><td>TXT</td><td>v=DKIM1 p=76E629F05F70…</td><td>6000</td></tr></tbody></table><p>其中v=DKIM1表明这是一套DKIM记录，同时也可以看到，通过selector就可以组成DKIM host来请求公钥。</p><h2 id="DMARC"><a href="#DMARC" class="headerlink" title="DMARC"></a>DMARC</h2><p>全称为Domain-based Message Authentication Reporting and Conformance， 这个记录会告诉邮件服务器在通过SPF，DKIM检测后，还需要做些什么。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v=DMARC1; p=quarantine; adkim=s; aspf=s;</span><br></pre></td></tr></table></figure><p>v表明这条TXT记录是一条DMARC记录。<br>p表明在SPF与DKIM失败后，应该怎么做，选项有none，reject，以及quarantine。<br>adkim表明DKIM检测是strict（s），还是relax（r）。<br>aspf跟adkim一样，只不过是给spf设定。<br>其中adkim，aspf都是可选的。</p>]]></content>
    
    <summary type="html">
    
      DNS types analysis and application
    
    </summary>
    
      <category term="Operation" scheme="http://talentprince.github.io/categories/Operation/"/>
    
    
      <category term="ops" scheme="http://talentprince.github.io/tags/ops/"/>
    
  </entry>
  
  <entry>
    <title>Android Framework知识总结</title>
    <link href="http://talentprince.github.io/2021/06/28/Android-Framework-Points/"/>
    <id>http://talentprince.github.io/2021/06/28/Android-Framework-Points/</id>
    <published>2021-06-28T01:09:50.000Z</published>
    <updated>2021-06-28T01:20:12.300Z</updated>
    
    <content type="html"><![CDATA[<p>Android Framework这一系列学习了很久， 也跟了不少源码， 推荐一个查看源码的<a href="https://www.androidos.net.cn/sourcecode" target="_blank" rel="noopener">网站</a>非常不错， 速度也很快。<br>希望可以帮助了解Android Framework各个知识点，也作为自己的一个备忘录，便于查询。</p><a id="more"></a><ul><li>Zygote<ul><li>作用<ul><li>启动SystemServer<ul><li>会用到<ul><li>JNI函数, 主题资源, 贡献库</li></ul></li><li>负责通过ServerManager加载各个系统服务</li></ul></li><li>孵化进程</li></ul></li><li>进程启动三步<ul><li>进程启动-&gt;准备工作-&gt;Loop</li></ul></li><li>Linux第一个进程, Init进程<ul><li>init.rc配置文件中指定ServiceManager的启动</li><li>紧接来启动Zygote, MediaServer, SurfaceFlinger等, 他们都是init子进程</li><li>启动方式<ul><li>fork+handle</li><li>fork+execve<ul><li>execve可以替换到父进程资源</li></ul></li></ul></li></ul></li><li>信号处理<ul><li>SIGCHILD 父进程根据该信号重启子进程</li></ul></li><li>Native部分<ul><li>启动虚拟机<ul><li>应用进程使用Zygote孵化出来的, 虚拟机已经启动好了</li><li>子进程会继承该虚拟机, 只需要重置状态, 重启一些守护线程</li></ul></li><li>注册JNI函数</li><li>进入Java</li></ul></li><li>Java部分<ul><li>预加载资源</li><li>启动system server (fork单独进程)</li><li>Loop循环等待socket消息</li><li>得到消息调用runOnce, 调用Zygote.forkAndSpecialize()</li><li>在子进程执行参数列表指定的ActivityThread.main函数</li></ul></li><li>特点<ul><li>Zygote fork保证单线程<ul><li>父进程有多个线程, 子进程只有一个, 会造成状态不一致或者死锁</li><li>在fork之前将所有线程都停掉, fork完成后再父进程内重启</li></ul></li><li>Zygote的IPC(与SystemServer)采用socket而不是binder<ul><li>原因有多个, 主要是因为binder需要注册在ServiceManager, 然后AMS与Zygote通信的时候又要在ServiceManager中查询binder对象, 来来回回繁琐</li><li>其次如果zygote启动binder再启动SystemServer, 两个进程会同一描述符, 得在SystemService中关闭旧的再次重启新的, 增加复杂度</li><li>App与SystemServer内各个服务通过Binder通信</li></ul></li></ul></li></ul></li><li>Android系统的启动<ul><li>Init fork出Zygote</li><li>Zygote进程内启动虚拟机, 注册JNI函数, 预加载资源</li><li>启动SystemService, 进入Socket Loop<ul><li>Zygote.forkSystemServer启动进程</li><li>handleSystemServerProcess加载逻辑<ul><li>nativeZygoteInit启动binder线程池与app以及ServiceManager通信</li><li>applicationInit启动Java SystemServer类main函数</li><li>main函数启动了MainLooper, 加载共享库</li><li>Start Bootstrap, Core, Other三个service</li><li>进入Loop循环, 但不一定处理主线程消息, 只是为了不让SystemServer App退出</li></ul></li></ul></li><li>启动Launcher, 通过PKMS获取所有安装程序, 进行显示</li><li>系统服务的发布<ul><li>publishBinderService(name, binderService)调用ServiceManager注册自己的Binder</li></ul></li><li>系统服务的线程<ul><li>工作线程 DisplayThread, FgThread, IoThread, UiThread</li><li>binder线程</li></ul></li><li>服务相互依赖<ul><li>分批启动<ul><li>AMS, PMS, PKMS先启动</li></ul></li><li>分阶段启动<ul><li>通知已经启动的service, 根据阶段使用相关服务</li></ul></li></ul></li></ul></li><li>添加系统服务<ul><li>添加<ul><li>通过ServiceManager.addService进行注册</li><li>在SystemService启动的时候来启动其他系统服务</li><li>服务不完全在SystemService进程, 小部分服务开了自己的进程, 如SurfaceFlinger</li><li>SurfaceFlinger是纯底层服务注册<ul><li>创建ProcessState启动binder, 分配缓冲区等<ul><li>打开binder驱动</li><li>映射内存, 分配缓冲区</li><li>启动binder线程, 进入loop, 可以创建也可以使用进程主线程</li></ul></li><li>创建SurfaceFlinger, init初始化</li><li>通过底层IServiceManger.addService将上一步创建的flinger注册</li><li>由于ServiceManager跟SurfaceFlinger都是init进程拉起来的, 需循环等待拿取IServiceManager</li><li>flinger进入loop循环</li></ul></li></ul></li><li>获取<ul><li>getSystemService最终在ContextImp里通过SystemServiceRegistry获取已经注册的<code>SYSTEM_SERVICE_FETCHERS</code>Map, 拿到对应Fetcher来getService</li><li>getService内有加锁的cache数组来缓存不同Service</li><li>如果cache不存在, 则调用CachedServiceFetcher的createService来创建</li><li>createService里调用ServiceManager.getService来或许远端服务的IBinder,  其中ServiceManager对象也是远端的IBinder</li></ul></li><li>如何添加一个系统服务<ul><li>时机<ul><li>跑在SystermServer</li><li>单独跑进程, 加入init.rc中</li></ul></li><li>启动binder机制, 如果在SystemServer, 可以利用已有</li><li>服务初始化</li><li>注册到ServiceManager</li><li>最好给客户端提供ServiceFetcher, 保持与其他服务调用一直</li></ul></li><li>系统服务与应用服务<ul><li>系统服务<ul><li>系统服务大多跑在SystemService内, 大多都在binder线程池, 少数有自己工作线程, 对于独立进程的服务大多跑在native, 自己启动binder机制</li><li>系统服务在binder线程中等待客户端请求, 分发到具体的服务</li><li>通过ServiceManager.addService注册, 只有系统服务才能注册</li><li>客户端通过Context.getSystemService获取系统服务对象, 进行使用</li></ul></li><li>应用服务<ul><li>应用服务启动都是由应用端发起, 内部调用AMS, 创建Service的Record</li><li>AMS只负责调度, 应用服务还是在应用端创建启动</li><li>应用向AMS发起bindService, 如果已经在AMS注册过则返回Binder, 否则通知客户端创建, 并注册, 再返回</li><li>应用服务通过bindService回调的onServiceConnected的IBinder对象调用远端服务</li></ul></li></ul></li></ul></li><li>ServiceManager<ul><li>启动<ul><li>单独进程, 通过init.rc启动</li><li>启动binder<ul><li>打开binder驱动, 映射128k空间作为数据传输 (普通程序有1m)</li></ul></li><li>发布服务<ul><li>通过ioctl, 告诉binder驱动ServiceManager就绪, 传入<code>BINDER_SET_CONTEXT_MGR</code>指令</li></ul></li><li>等待响应请求<ul><li><code>binder_loop</code>内调用<code>binder_write</code></li><li><code>binder_write</code>通过ioctl传入<code>BINDER_WRITE_READ</code>, 第三个参数<code>binder_write_read</code>中的<code>write_size</code>与<code>read_size</code>的大小来控制读写, 如果都大于0, 优先写</li><li>ioctl第三个参数控制写入<code>BC_ENTER_LOOP</code>, 将当前线程注册为binder线程</li><li>将<code>write_size</code>置为0, 进入死循环, 将<code>read_size</code>置为sizeof(readbuf), 通过ioctl读取数据</li><li>通过<code>binder_parse</code>解析<code>readbuf</code>, 并通过最后一个回调函数<code>bind_handle</code>返回</li></ul></li></ul></li><li>获取<ul><li>底层获取ServiceManager<ul><li>通过defaultServiceManger()获取对象<ul><li>通过全局锁, 内部循环sleep(1), 通过ProcessState::getContextObject获取gDefaultServiceManager</li><li>之所以循环, 因为底层例如surfaceflinger与servicemanager都是一起初始化的, 可能还没有创建好</li><li>getContextObject内部调用getStrongProxyForHandle(0), 0为数组索引, 返回BpBinder(IBinder)对象</li><li>interface_cast<iservicemanager>(bpBinder)相当于IServiceManager::asInterface(), 最终调用new BpServiceManager(bpBinder)<ul><li>IServiceManager通过宏定义<code>DECLARE_META_INTERFACE</code>与<code>IMPLEMENT_META_INTERFACE</code>实现asInterface方法, 内部创建Bp###</li></ul></iservicemanager></li></ul></li></ul></li><li>获取Service<ul><li>Java层通过ServiceManager#getService</li><li>底层通过ServiceManager的getService</li><li>通过remote()拿到的BpBinder, 带上name发送transact CHECK_SERVICE_TRANSACTION获取</li><li>svcmgr_handler得到消息后, 查询链表</li></ul></li></ul></li><li>添加<ul><li>defaultServicce</li><li>通过remote()拿到BpBinder对象</li><li>再调用transact发送<code>ADD_SERVICE_TRANSACTION</code>, 发送name与binder对象<ul><li>BpBinder内部通过调用IPCThreadState单例的transact发送</li></ul></li><li>处理<ul><li>ServiceManger通过<code>svcmgr_handler(service_manager.c)</code>进行处理请求</li><li>接收到SVC_MGR_ADD_SERVICE后调用<code>do_add_service</code>将binder加入链表</li></ul></li></ul></li></ul></li><li>Binder<ul><li>启动时机<ul><li>Zygote在fork进程后, 子进程nativeZygoteInit中启动binder</li></ul></li><li>应用启动binder<ul><li>zygote创建进程初始化过程中, 通过ProcessState的构造函数, 打开binder驱动, 打开成功则分配缓冲区大小</li><li>ProcessState::startThreadPool通过IPCThreadState线程单例, 向mOut的Parcel写入, 告诉驱动, 注册线程</li><li>进入Loop循环, 死循环不断从mIn读取驱动数据</li></ul></li></ul></li><li>Application<ul><li>Application跟着进程走</li><li>作用<ul><li>保存进程内全局变量</li><li>初始化</li><li>提供Context</li></ul></li><li>创建<ul><li>ActivityThread#attatch -&gt; AMS -&gt; AMS#attachApplicationLocked -&gt; IApplicationThread#bindApplication -&gt; sendMessage -&gt; handleBindApplication -&gt; makeApplication + onCreate</li><li>makeApplication通过反射创建Application, 并调用attach(attachBaseContext)传入context(ContextImpl)</li></ul></li><li>不能在applicaiton初始化内做耗时操作, 它会影响后续activity, service, broadcast的初始化</li></ul></li><li>Context<ul><li>Context才是各个组件的核心, 没有它, Application只是个空壳</li><li>内部持有了ActivityThread, LoadedApk(PackageInfo), ResourceManager, Resource, PackageManger, mServiceCache</li><li>三种Context<ul><li>Application Context<ul><li>继承关系<ul><li>Application &lt;- ContextWrapper { Context mBase } &lt;- Context</li></ul></li><li>调用关系<ul><li><init> -&gt; attatchBaseContext -&gt; onCreate</init></li></ul></li><li>Zygote启动子进程后, 在makeApplication时创建ContextImpl, 并attatch到Application里</li></ul></li><li>Activity Context<ul><li>performLaunchActivty中反射创建Activity</li><li>获取application, 创建ContextImpl, 调用Activity#attatch</li><li>调用onCreate</li><li>继承关系<ul><li>Activity &lt;- ContextThemeWrapper &lt;- ContextWrapper</li><li>ContextThemeWrapper多了<code>Resources.Theme</code></li></ul></li><li>调用关系<ul><li><init> -&gt; attatchBaseContext -&gt; onCreate</init></li></ul></li></ul></li><li>Service Context<ul><li>与Application类似, 反射创建Service, 创建ContextImpl, attatch后调用onCreate</li><li>也继承了ContextWrapper</li></ul></li><li>Broadcast<ul><li>不继承ContextWrapper</li><li>onReceive的context, 动态注册为注册时的context, 静态注册的则是以application为mBase的ContextWrapper</li></ul></li><li>ContentProvider<ul><li>不继承ContextWrapper</li><li>成员变量mContext是创建的时候传入的Application</li><li>虽然ContentProvider在Application的attatch之后创建并onCreate, 但是它是在Application的onCreate之前.</li></ul></li></ul></li><li>App的Context的个数为Activity个体数+Service个数+Application*进程数</li><li>getApplication是Activity与Service特有返回Application的, 而getApplicationContext是Context的方法, 虽然都返回Application</li><li>Activity的getBaseContext获取的是mBase, 而this是Activity本身</li></ul></li><li>Activity<ul><li>启动 <ul><li>ActivityManagerNative.getDefault()获取到AMS的代理Binder, startActivity</li><li>通过transact发送<code>START_ACTIVITY_TRANSACTION</code></li><li>AMS收到onTransact回调后startActivity</li><li>检测Process是否启动, ProcessRecord是否为空, appthread是否注册</li><li>如果进程未创建, 则通知zygote启动, 这个是基于socket</li><li>启动后父进程将子进程pid返回给AMS, 而子进程启动binder, 并执行ActivityThread的main函数, 通过attatchApplication向AMS注册ApplicationThread, 即应用端的Binder</li><li>AMS中attatchApplication里会通知应用创建Application, 然后启动Activity, Service, Broadcast等挂起的组件<ul><li>其中Activity <ul><li>通过mFocusedStack获取栈顶Activity</li><li>通过ApplicationThread#scheduleLaunchActivity通知应用端启动</li><li>应用收到消息后发送LAUNCH_ACTIVITY消息到主线程</li><li>主线程调用handleLaunchActivity, 其中performLaunchActivity负责创建启动, handleResumeActivity负责进入resume</li></ul></li></ul></li></ul></li><li>显示<ul><li>setContentView<ul><li>Window.setContentView<ul><li>window是在attach的时候创建的PhotoWindow</li><li>内部installDecor创建DecorView, 将根布局inflate后加入, 通过<code>ID_ANDROID_CONTENT</code>获取ContentView</li><li>然后再将自己的View inflate到ContentView上</li></ul></li></ul></li><li>handleResumeActivity<ul><li>WindowManager.addView(decor)<ul><li>创建ViewRootImpl, 负责跟WMS交互, 调用setView设置decorView<ul><li>requestLayout<ul><li>通过choreographer触发绘制回调, doTraversal负责跟WMS进行交互, 进行绘制</li><li>分为四步, relayout申请surface, measure, layout, draw</li></ul></li><li>windowSession.addToDisplay注册window<ul><li>其中windowSession是与WMS通信的binder<ul><li>WMS负责分配Surface, 掌管其尺寸位置, 控制窗口动画, 输入时间分发</li></ul></li><li>注册后就与WMS形成双向调用</li></ul></li></ul></li></ul></li><li>然后activity.makeVisible, 只是触发重绘</li></ul></li></ul></li><li>UI线程启动<ul><li>通过runOnUiThread在UI线程执行<ul><li>onResume之前, 会post到RunQueue等待ViewRootImp#AttachInfo创建</li><li>onResume之后, 直接由AttachInfo的线程handler进行处理</li><li>所以UI线程就是ViewRootImp创建时的线程</li><li>ViewRootImp&lt;-WindowManagerImp.addView&lt;-WindowManagerGlobal.addView&lt;-ActivityThread.handleResumeActivity</li><li>所以UI线程就是主线程, 如果自定义在子线程通过WindowManager来addView, 那么就只能在子线程刷新</li></ul></li></ul></li></ul></li><li>Service<ul><li>启动<ul><li>startService向AMS发起请求, 将Intent发送过去</li><li>通过ActiveServices(mServices)进行启动准备</li><li>内部检查到对应的Service对象后, 创建StartItem并添加到pendingStarts数组, 为之后调用onStartCommand用</li><li>继续调用bringUpServiceLocked, 检测Service是否存在, 如果没启动, 则检测Service进程是否创建, 如果没启动则启动进程, 并添加到PendingServices里, 否则直接通过realStartServiceLocked启动Service, 内部通过scheduleCreateService让应用创建Service, 再通过scheduleServiceArgs让应用调用onStartCommand</li><li>进程应用启动成功后会向AMS发送attatchApplicationLocked的请求, 来处理PendingServices的启动, 调用realStartServiceLocked</li></ul></li><li>绑定<ul><li>调用bindService后, 会将ServiceConnect包装成IServiceConnection交给AMS, 内部是通过ServiceDispatcher来获取</li><li>AMS会调用该Binder的connected, 将Service的Binder发回应用, 如果Service为null, 说明Service挂了断开了, 如果不等于null, 说明连接成功, 应用有Service的Binder的缓存, 如果同样则不会重复调用onServiceConnected, 只有当Service死了才会onServiceDisconnected</li><li>AMS接收到bind请求后, 如果Service没启动则通过bringUpServiceLocked拉起, 拉起过程在调用应用CreateService与onStartCommand之间, 调用requestServiceBindingLocked<ul><li>如果没有请求过绑定, 则调用客户端绑定, 标记requested<ul><li>应用通过onBind生成Service的Binder, 并发布到AMS, AMS标记requested/received, 并遍历ConnectionRecord通知应用(connected)</li><li>onRebind的触发是当Service还在, 但是应用死了, 会在unBind的时候将doRebind标记为true, 下次再次bind的时候会调用onRebind</li><li>应用端Service<->AMS的ServiceRecord<->多个IntentBindService (因为可多个Intent绑定一个Service)<->多个AppBindRecord (因为Intent可能来自不同进程)<->ConnectionRecord (一个进程可以有多个Connection)</-></-></-></-></li></ul></li></ul></li><li>如果Service已经绑定到AMS, 即received标记true, 则直接connected返回应用</li><li>否则检查是否请求过Service, 即requested, 没有则调用requestServiceBindingLocked</li><li>IServiceConnection是与Context+ServiceConnect对应的, 不同组合对应不同的AMS中的Binder</li></ul></li></ul></li><li>Broadcast<ul><li>动态广播注册<ul><li>BroadcastReceiver被包装成ReceiverDispatcher, 内部生成IIntentReceiver发给AMS, 则AMS可通过Dispatcher调用Broadcast</li><li>AMS收到注册请求后, 生成BroadcastList(List<broadcastfilter>), 并添加对应filter, 并且存入Map&lt;IBinder, BroadcastList&gt;, 故多个Filter可能对应同一个Receiver</broadcastfilter></li></ul></li><li>动态广播分发<ul><li>AMS通过Intent查找对应Receiver列表, 创建Record, 放入并行队列(动态广播), 触发分发scheduleBroadcastsLockeded</li><li>Handle收到消息, 调用processNextBroadcast中循环取出record, 通过performReceiveLocked通过activityThread转换为串行, 发送给每一个receiver</li><li>performReceiveLocked内调用applicationThread.scheduleRegisterReceiver将广播分发给客户端, 客户端串行处理</li><li>静态广播与动态广播带oder还需要通知AMS广播执行结束, 这样AMS才可以下发新的广播, 普通动态广播不用调用sendFinished<ul><li>AMS通过检测客户端发过来的Broadcast.state来判断, 如果串行动态广播为<code>CALL_DONE_RECEIVE</code>, 静态广播为<code>APP_RECEIVE</code>, 这两种都会触发AMS继续process下一个</li></ul></li></ul></li><li>静态广播注册<ul><li>PMS在解析到Manifest的receiver标签的时候, 创建Activity Component对象, 将其注册在PMS中</li><li>sendBroadcast到AMS中后, broadcastIntentLocked先根据Intent查找静态广播(collectReceiverComponents), 再查找动态广播(receiverResolver.queryIntent)</li><li>如果没有oder, 且有动态广播, 则加入并行队列</li><li>剩下的跟静态receiver合并在一起, 加入串行队列</li><li>BroadcastQueue在处理串行广播时相对复杂<ul><li>如果有Pending, 就返回, 等待进程启动</li><li>如果超时, 则处理下一个</li><li>如果没超时, 则返回等待处理</li><li>如果已经分发完一个receiver, 就继续分发下一个</li><li>如果是动态注册, 直接分发</li><li>如果是静态注册, 检查进程, 如果启动了就直接分发, 如果没启动, 则将广播标记为pending</li><li>进程启动attachApplication后, 继续处理pending广播</li></ul></li></ul></li><li>静态广播分发<ul><li>AMS最终调用ActivityThread.scheduleReceiver, 应用端先加载Broadcast的类, 创建BroadcastReceiver, 拿到Application, 拿到app的baseContext, 回调onReceive</li><li>如果进程不存在, AMS请求启动进程后, 进程启动成功, 在attachApplicationLocked中, 调用sendPendingBroadcastLocked分发</li></ul></li></ul></li><li>Provider<ul><li>ContentResolver是在ContextImpl创建的时候创建的, ApplicationContentResolver</li><li>当调用resolver的函数时, 在acquireProvider中先查找本地保存的provider binder对象, 没有就请求AMS, AMS返回holder, 本地需要安装再使用<ul><li>本地查找通过authority+userId, 拿到ProviderClientRecord, 该对象对应AMS的ProviderRecord, 然后从中拿出Binder检查alive, 并决定使用还是客户端+服务器进行清理</li><li>如果本地查不到, 则请求AMS, 调用getContentProvider返回Holder<ul><li>AMS检查如果有Record就直接返回</li><li>当不存在时, 如果能跑在调用的客户端进程(canRunHere, multiprocess=true或者进程名相同, 并且uid相同), 就返回<ul><li>当holder中的provider为空, 让应用端自己创建, 不用通过binder通信, 更快</li></ul></li><li>如果不能跑在调用者进程, 当provider进程没启动则通知Zygote启动它的进程 (process), 如果已经启动了但是Binder还未注册给AMS则请求Provider发布<ul><li>应用主动发布, Provider进程启动成功后, attach过程中, 查询PMS得到provider列表, 然后发送消息让AMS等待Provider发布binder, 同时发送给客户端bind请求, 带上provider列表, 为了让应用单安装并发布binder<ul><li>应用端收到请求后, 分别安装并将holder(内有binder)返回AMS</li><li>AMS收到holders后, 把binder保存在自己的records里, 并notifyAll通知等待发布的线程</li></ul></li><li>如果进程已启动但没有provider, AMS则主动请求应用发布, 应用切主线程(scheduleInstallProvider), 再调用installContentProviders, 创建provider, 调用onCreate, 再发布到AMS注册</li></ul></li></ul></li><li>应用端收到holder之后, 进行installProvider操作<ul><li>如果holder.provider不为空, 则使用binder proxy</li><li>如果为空(multiprocess=true或者统一uid+进程名相同, 即允许调用着实例provider), 先反射创建ContentProvider, 从中获得IContentProvider, 实际上是binder实体, 并attach传入context(调用ContentProvider的onCreate)</li><li>创建ProviderClientRecord对象, 赋值IContentProvider到holder.provider, 并保存在mLocalProvidersByName中, 再返回holder</li></ul></li></ul></li></ul></li><li>UI刷新机制<ul><li>应用申请buffer-&gt;系统返回buffer-&gt;应用绘制提交-&gt;系统显示屏幕</li><li>屏幕缓存不止一个, 至少两个</li><li>屏幕固定刷新, 在接收到vsync信号后</li><li>系统的Choreographer控制消息只有等vsync消息来了后触发UI绘制, 保证跟vsync同步</li><li>requestLayout会给消息队列插入屏障, 再给Choreographer里post一个callback到队列, 不同线程有不同的Choreographer</li><li>同一个vsync内, 无论掉多少次requestLayout都只能触发一次, 因为只有当下次vsync触发后, 才会将flag保护置位</li><li>callback如何加入队列<ul><li>Choreographer内有数组mCallbackQueues, 根据类型管理单链表, 根据时间排序</li><li>如果当前就是Choreographer的工作线程, 直接schedule, 如果不是, 则发异步消息到其线程, 插入头部</li><li>Choreographer调用scheduleVsyncLocked请求信号, 当vsync时机到来时, SurfaceFlinger会postSyncEvent进行通知 <ul><li>scheduleVsyncLocked用来告诉SurfaceFlinger下一个vsync通知我</li><li>DisplayEventReceiver会调用native的函数, 再通过SurfaceFlinger在底层创建的EventConnection#requestNextSync<ul><li>Connection是在DisplayEventReceiver的构造中通过SurfaceFlinger创建的</li><li>SurfaceFlinger创建EventThread负责监听Vsync信号, 并通过EventThread创建Connection, 并注册进EventThread等待信号</li><li>EventThread里面等待拿取所有Connections, 便利返回Vsync事件</li><li>等待过程首先检测Vsync信号是否已经到来, 到来就返回connection列表</li><li>Connection通过BitTube发送信号, BitTube类似socket管道, 写端在SurfaceFlinger</li><li>DisplayEventReceiver初始化会通过Connection获取DataChannel(remote()-&gt;transact)拿到Connection远端的Channel的parcel, 再还原回BitTube</li><li>Choreographer构造时就会创建FrameDisplayEventReceiver, 会创建native层将Connection远端Channel接收(mReceivedFd)的fd通过Looper进行监听(addFd), 从而完成监听Vsync闭环<ul><li>addFd内部将fd加入epoll event内 (epoll_ctl), Looper内部pollInner的循环, 通过epoll_wait遍历事件, 一种是消息队列事件 (mWakeEventFd == fd), 另外一个种会放在response列表之后处理</li><li>循环response调用response.request.callback-&gt;handleEvent, 返回0就会删除fd, 返回其他则继续监听</li><li>BitTube的回调通过JNI调用Java层层的DisplayEventReceiver的onVsync</li></ul></li></ul></li></ul></li><li>通知会通过FrameDisplayEventReceiver#onVsync回调, 调用doFrame传入当前vsync时间戳来处理消息, 如果当前时间晚于vsync时间戳太多, 则会打log, 在主线程工作太多</li><li>然后根据时间戳到了与否处理四种类型的callback, INPUT, ANIMATION, TRAVERSAL, COMMIT, 通过extractDueCallbackLocked拿出到时见的callback</li><li>callback内调用doTraversal-&gt;performTraversal来进行真正绘制</li><li>所以并不是每一次Vsync都会绘制, 需要应用自己请求才能收到Vsync信号, 如果没有重绘, 屏幕还会60帧刷新, 只不过用的旧数据</li><li>onDraw完也得等下次Vsync信号来的时候才会刷新</li></ul></li><li>Surface<ul><li>Surface是一个Parcel，Java类保存native指针，主要传递native指针</li><li>native层nativeWriteToPacel写入GraphicBufferProducer的binder</li><li>native层nativeReadToPacel从parcel里读出binder，重新构造成Surface</li><li>performTraversal第一次绘制通过mWindowSession#relayout请求WMS创建Surface</li><li>WMS创建native层的SurfaceControl， 再创建native层的Surface，其中SurfaceControl负责提供GraphicBufferProducer</li><li>Surface内部主要靠的就是GBP, client创建空Surface, WMS创建SurfaceControl, 再用其内部的GBP绑定为Surface</li><li>Surface绘制原理<ul><li>绘制从ViewRootImpl#performTraversal开始, measure, layout, draw</li><li>软绘制<ul><li>nativeLockCavas创建Canvas<ul><li>底层Surface创建buffer, 供SkBitmap使用, 再赋给Canvas</li><li>Surface通过GraphicBufferProducer#dequeueBuffer获取空间</li><li>如果buffer空间地址需要刷新, 则调用GraphicBufferProducer#requestBuffer在SurfaceFlinger里创建</li><li>赋值给后台mLockedBuffer用于绘制</li><li>Buffer的IPC传递知识传递了文件描述符, 让本地与远端都指向同一片物理内存</li></ul></li><li>nativeUnlockCanvasAndPost提交Buffer<ul><li>清空Canvas底层bitmap</li><li>拿到buffer在Slot中的index, 并通过GBP-&gt;queueBuffer告诉SurfaceFlinger, 对buffer进行处理, 再通知consumer端onFrameAvailable去合成</li><li>再把buffer赋值给前台mPostedBuffer用于渲染, 清空mLockedBuffer</li></ul></li></ul></li></ul></li></ul></li><li>Vsync<ul><li>SurfaceFlinger<ul><li>HWComposer硬件生成信号, VSyncThread软件生成信号</li><li>信号分发给工作线程DispSyncThread</li><li>工作线程两路分发给另外两个线程, app-EventThread, sf-EventThread, 并且加了偏移, 避免抢占CPU</li><li>一个通知应用绘制UI, 一个通知SF对绘制完成的图像进行合成渲染</li></ul></li><li>SurfaceFlinger初始化<ul><li>初始化两个EventThread, 并传入不同的DispSyncSource, 参数会加入所谓偏移, 以及工作线程分发器(&amp;mPrimaryDispSync)</li><li>初始化HWComposer, 内部包含硬件生成与软件生成, 传入EventHandler, 即SF自己, 再传给PrimaryDispSync工作线程进行分发 </li><li>app线程会将sync发给app进程, sf线程会将sync发给SF主线程</li><li>SFEventThread创建EventConnection, 并获取DataChannel即BitTube, 并将用于接收的Fd添加到Looper, 收到vSync后回调MessageQueue::cb_eventReceiver</li></ul></li><li>HWComposer<ul><li>加载硬件模块成功, 则不需要软生成, 并且将硬件hook回调hook_vsync赋值<ul><li>hook_vsync会调用HWComposer::vsync</li><li>回调EventHandler, 即SurfaceFlinger#onVSyncReceived</li></ul></li><li>如果加载失败, 启动VSyncThread<ul><li>线程不断执行threadLoop, 通过计算进行sleep(clock_nanosleep)</li><li>回调SurfaceFlinger#onVSyncReceived</li></ul></li></ul></li><li>SurfaceFlinger#onVSyncReceived内调用PrimaryDispSync#addResyncSample, 保存timestamp到mResyncSamples里, 再通过DispSync#updateModel<pre><code>- updateModel会调用mThread发送信号(mCond.signal())- DispSync内的mThread是其工作线程, 循环内等待Vsync信号(mCond), 得到信号后拿到所有callbacks并分发出去- Callback就是DispSyncSource的cb, 即SurfaceFlinger自己    - 而这个cb内又调用了EventThread的cb(onVSyncEvent)    - EventThread将时间戳保存到mVSyncEvent数组, 再通过mCondition.broadcase()唤醒线程    - threadLoop等待信号, 循环等待检测mVSyncEvent    - 将所有事件通过Connection#postEvent分发        - 即DisplayEventReceiver也就是BitTube#sendObject发送出去        - tube通过mSendFd发送, mReceiveFd接收        - 应用进程通过Connection的Binder接收        - 而SF在初始化时添加了接收Fd</code></pre></li></ul></li></ul></li><li>跨进程通信<ul><li>管道<ul><li>单向通信, 无名管道父子进程使用, 有名管道也可以给任意多进程使用</li><li>pipe(fd)可以生成一堆描述符, fd[0]来读, fd[1]来写<ul><li>tips: fork()返回0位子进程, &gt;0位父进程, &lt;0开进程失败</li></ul></li><li>进程内, 跨进城都可以使用, 数据量不大的通信常用</li><li>低版本的Looper底层用pipe, 高版本用event_fd</li></ul></li><li>socket<ul><li>全双工, 用于无亲缘进程之间</li><li>zygote接收AMS的请求用的就是socket <ul><li>通过读取到的参数创建应用, 再把创建的pid写给对方</li></ul></li></ul></li><li>共享内存<ul><li>快, 不需要多次拷贝, 比前两者支持数据量大</li><li>进程之间不需要有关系, 只要能拿到fd</li><li>安卓的匿名共享内存Ashmem<ul><li>通过<code>native_open</code>创建匿名共享内存</li><li>再通过<code>native_mmap</code>将共享内存映射到本进程</li></ul></li></ul></li><li>信号<ul><li>单向, 收不到回复</li><li>只能带信号, 不支持参数</li><li>只要知道pid就能发信号, 也可以给一群进程发信号<ul><li>但是只有root权限才能随便发, 或者同一个uid下才能发</li></ul></li><li>Android里Process.killProcess使用的就是信号</li><li>虽然进程都是Zygote启动的, 但启动后会重新设置uid, 所以不能乱杀</li><li>Zygote关注SIGCHLD信号, 子进程死掉后清理资源</li></ul></li></ul></li><li>Binder<ul><li>主要实现远程调用</li><li>一般跨进程流程: 参数序列化-&gt;buffer传递-&gt;参数反序列化</li><li>需要注意: 性能好, 方便, 安全, 相当复杂</li><li>Binder跑在驱动层, 在内核, 没有用Linux跨进程机制, 不用内核进行中转, 多次拷贝<ul><li>性能好, binder做内存映射, 映射内核与目标应用进程内存空间</li><li>比共享内存容易使用</li><li>安全, 在内核中添加认证机制</li></ul></li><li>Client, Server, ServiceManager工作的前提就是启动binder机制<ul><li>打开binder驱动</li><li>内存映射, 分配缓冲区</li><li>启动binder线程, 线程注册在驱动内, 并且进入loop循环, 与binder交互</li><li>系统Service先与ServiceManager交互, 接着才是Client</li><li>分层<ul><li>应用层 Proxy -&gt; Stub</li><li>Java BinderProxy -&gt; Binder</li><li>Native BpBinder -&gt; BBinder</li><li>binder驱动 IPCThreadState#transact -&gt; onTransact, 通过mHandle跟对应驱动打交道, 标识接收端</li></ul></li></ul></li><li>实现<ul><li>Client<ul><li>transact内首先通过writeTransactionDate写数据到mOut中</li><li>再调用waitForResponse<ul><li>内部调用talkWithDriver完成先写再读<ul><li>实际通过binder_ioctl进行读写</li></ul></li><li>再通过循环反复交互直到<code>BR_TRANSACTION_COMPLETE</code>跳出循环</li></ul></li></ul></li><li>Server<ul><li>binder线程进入loop, 调用IPCThreadState#joinThreadPool<ul><li>首先写入mOut注册线程</li><li>进入死循环读写指令<ul><li>talkWithDriver</li><li>再从mIn读取指令进行执行</li></ul></li><li>执行BR_TRANSACTION指令即接收到远端请求<ul><li>从读取的数据(binder_transaction_data)中拿出cookie, 即binder的server实现</li><li>通过该BBinder-&gt;transact返回Server端上层</li></ul></li></ul></li></ul></li><li>Client: BC_TRANSACTION -&gt; BR_TRRANSACTION_COMPLETE -&gt; 休眠 -&gt; BR_REPLY</li><li>Server: 休眠 -&gt; BR_TRANSACTIOn -&gt; BC_REPLY -&gt; BR_TRANSACTION_COMPLETE -&gt; 休眠</li></ul></li><li>原理<ul><li>如何写入<ul><li>Java层传递Binder对象, 调用writeStrongBinder, 传入mNativePtr(底层Parcel)</li><li>底层通过ibinderForJavaObject转换binder并写入底层Parcel</li><li>如果Java层传入是Binder实体<ul><li>通过Java层对象内拿出native holder的指针</li><li>再从holder中拿出真实的native层binder对象, 是一个继承了BBinder(BnInterface:BBinder:IBinder)的对象</li></ul></li><li>如果Java层传入是Proxy对象<ul><li>直接从Java层拿到native层IBinder(BpBinder)的指针</li><li>Tips: BpInterface父类mRemote为BpBinder类型</li></ul></li><li>底层writeStrongBinder通过flatten_binder来写入Parcel<ul><li>创建<code>flat_binder_object</code>, cookie赋值localBinder</li><li>mObjects保存偏移, mData按顺序排列<code>flat_binder_object</code></li></ul></li><li>驱动层<ul><li>调用binder_transaction<ul><li>取出所有<code>flat_binder_object</code></li><li>如果<code>BINDER_TYPE_BINDER</code>实体对象<ul><li>检查是否在binder驱动内有对应binder_node, 没有创建</li><li>检查是否在目标进程有无对应引用对象</li><li>然后把实体对象类型改为代理对象<code>BINDER_TYPE_HANDLE</code></li><li>并把flat_binder_object里的handle改为刚创建引用的handle(desc)</li></ul></li></ul></li></ul></li></ul></li><li>如何读取<ul><li>Java层通过readStrongBinder传入mNativePtr</li><li>底层通过unflatten_binder<ul><li>如果是<code>BINDER_TYPE_BINDER</code>, 则为同进程传递, 直接返回cookie, 即binder实体</li><li>如果是<code>BINDER_TYPE_HANDLE</code>, 则通过handle生成BpBinder<ul><li>handle是偏移, 在数组中查找handle_entry </li><li>如果entry拿不到IBinder, 就创建BpBinder, 传入handle, 并赋值给entry的binder</li><li>返回BpBinder</li></ul></li></ul></li></ul></li><li>返回Java<ul><li>如果是实体, 就返回JavaBBinder</li><li>如果是代理, 需要生成一个BinderProxy, 且该对象mObject保存了native的指针</li></ul></li><li>oneway机制<ul><li>异步binder调用</li><li>AIDL函数没有返回值</li><li>oneway多个客户端调用在Server端是同步的</li><li>Server端是在前一个处理完Parcel的freeBuffer的析构中, 从todo队列拿出下一个放在tode线程处理</li><li>例如scheduleLaunchActivity就是oneway</li><li>IWindow, IServiceConnection, IIntentReceiver都是异步</li></ul></li><li>一次拷贝<ul><li>只发生在读取方做了内存映射到内核</li><li>另外的拷贝都是外围结构体到内核, 不包含data</li></ul></li></ul></li></ul></li><li>消息队列<ul><li>子线程Looper可以退出, 主线程Looper设置不可退出</li><li>创建子线程Handler需要在子线程内prepare looper, 再传入handler</li><li>一个Looper对应一个MessageQueue, 一个Looper会有多个Handler</li><li>Looper创建后会创建MessageQueue, 上层MessageQueue创建会创建底层MessageQueue, 底层MessageQueue会创建底层Looper</li><li>底层MessageQueue初始化时拿去/创建当前线程Looper</li><li>底层Looper创建<ul><li>创建eventFd, 比管道性能好, 只有计数器加减, 无拷贝</li><li>Looper#wake往fd写东西</li><li>Looper#pollOnce死循环监听fd<ul><li>epoll_wait等待fd事件</li><li>等待到循环eventCount从eventItems里拿出</li></ul></li></ul></li></ul></li><li>消息传递<ul><li>分发handler.dispatchMessage<ul><li>顺序为msg自己有callback-&gt;全局callback-&gt;handler自己callback, 任意个返回true则不继续</li></ul></li><li>接收 循环调用queue.next<ul><li>循环调用nativePollOnce阻塞, 有消息或者时间到会返回<ul><li>底层最终通过MessageQueue调用了Looper的pollOnce, 循环调用</li><li>核心通过epoll_wait等待, 返回-1出错, 0没消息, 非0为消息个数</li><li>循环消息Count, 如果事件使用的fd是被唤醒的fd(mWakedEventFd), 且是读事件(event&amp;EPOLLIN), 则通过awoken来消化管道事件</li></ul></li><li>从mMessage取一条消息, 并将msg标记为InUse (当obtainMessage时候标记不使用, 即把消息从空闲链表里拿出)</li></ul></li><li>发消息 handler.sendMessage<ul><li>消息会直接放入队列, 只是在某个时间才会被分发<ul><li>equeueMessage根据触发时间插入到queue的位置 (循环查找位置)</li><li>底层pollOnce拿消息<ul><li>如果没拿到消息, 则设置超时为-1, 一直等待</li><li>如果拿到的没到点, 则设置超时为还差的那一段时间</li><li>如果到点了, 则取出消息, 标记next为null, 返回msg</li><li>因为主要靠epoll_wait等待, 所以精度不行</li></ul></li></ul></li><li>消息被插入messageQueue后, 通过nativeWake唤醒消息队列线程<ul><li>底层调用了Looper.wake, 然后往mWakeEventFd写数唤醒等待在某线程的Looper</li></ul></li></ul></li></ul></li><li>IdleHandler<ul><li>消息队列当前没有可处理消息的时候, 就会调queueIdle</li><li>当消息处理完后 (Message#next循环内), 会查询pendingIdleHandlerCount, 如果有则逐个处理</li><li>当idler.queueIdle返回false,则将该handler从mIdleHandlers删掉</li><li>Framework中的应用<ul><li>ActivityThread里加入了GcHandler, return false, 进行一次性GC</li><li>waitForIdle, 内部也是往主线程queue加入IdleHandler, 返回false, 一次性调用<ul><li>为了防止本身就是Idle不会调用, 则post一个EmptyHandler, 触发Idle</li></ul></li><li>waitForSync, 与上一条的差别是最后循环等待信号, 当queueIdle被调用时, notify等待.<ul><li>Tips: wait要配合while循环使用, 防止notify之后, 获得锁之前, 条件变化, 所以配合mIdle标记为一起, notifyAll之前mIdle=true</li></ul></li></ul></li><li>适用场景<ul><li>延迟执行, 替代postDelay</li><li>密集操作, 可以先往线程队列放进行处理, 当队列空闲再汇总刷新界面</li></ul></li><li>IdleHandler不会重复调用, 当消息队列为空或者没有可执行的消息时, 会调用一次, 如果再被唤醒还是没有, 则不调用, 因为pendingIdleHandlerCount会被设置为0, 且一直循环poll, 不会跳出next, 直到有消息处理, 再次进入next后会被设置为-1进而重新读取size</li></ul></li><li>ANR<ul><li>Service, BroadcastQueue, ContentProvider, InputDispatching Timeout都会触发ANR</li><li>比如Service, AMS发起让客户端启动Service后, 启动超时定时器(delay message), 当客户端响应启动Service之后, 移除超时消息, 如果未及时移除, 则AMS会弹框</li><li>AMS通知客户端的Binder线程, Binder线程再往主线程发消息来启动Activity, Service, BroadcastReceive </li><li>主线程在无消息时休眠, 其他线程需要写入eventFd才能唤醒主线程</li><li>ANR是由于主线程有耗时任务, 或者创建本身有耗时, 而不是由于主线程消息循环阻塞</li></ul></li><li>消息屏障<ul><li>普通消息, 屏障消息, 异步消息</li><li>屏障消息没有target, 正常消息没有target会抛异常</li><li>屏障消息会有时间戳, 且影响后面的消息</li><li>屏障消息不会唤醒线程来处理</li><li>屏障插入(postSyncBarrier)会返回屏号</li><li>删除屏障需要屏障号, 会唤醒线程, 只有当消息阻拦了消息</li><li>如果当前要处理的消息是屏障, 则会往后遍历, 处理异步消息</li><li>如果要插入消息, 但消息已经被屏障block, 且当前消息是最早的异步消息, 则要唤醒</li><li>Framework应用<ul><li>绘制界面scheduleTraversal时, 会加入barrier, 再往Choreographer里放入Runnable callback, 等vsync执行该回调后, 去除屏障, 为了使屏幕绘制的异步消息优先执行, block普通消息</li></ul></li><li>消息屏障的api都是隐藏的, 需要反射或者其他方式</li></ul></li><li>实践经验<ul><li>跨进程传输大图片<ul><li>考虑点<ul><li>性能, 减少拷贝</li><li>内存泄露, 资源释放</li></ul></li><li>Binder启动时映射内存为1M, 是所有事务共享的</li></ul></li><li>直接通过Intent传输bitmap, 在未允许传fd或者size小于16K的情况下, 会直接直接存parcel, 太大就会报错</li><li>如果通过传binder到Intent, 则会打开allowFds, bitmap的数据会开辟ashmem空间, 再把空间地址fd写入parcel, 图片将会被拷贝到共享内存空间</li><li>如果传输大文件可以用ContentProvider或者MemoryFile, 底层都是用共享内存实现</li></ul></li><li>ThreadLocal<ul><li>Looper里用到, 作为静态变量, 里面存放Looper, 不同线程拿到不同的looper</li><li>Choreographer里也有静态变量初始化ThreadLocal并且在initialValue回调中创建对象</li><li>原理<ul><li>每一个线程都有thread对象, 里面有一个数组, 按照key + value排列</li><li>key是WeakReference<threadlocal>, value是存储对象</threadlocal></li><li>可以定义多个ThreadLocal, 每一个ThreadLocal都有自己的hash值作为数组下标</li><li>hash算法每次增加一个值(是一个偶数)再对table的size取余数得到index</li><li>如果冲突了, 则从当前遍历找空的存储</li><li>ThreadLocal.get()<ul><li>先获取当前线程Thread, Thread.currentThread()</li><li>从thread里拿出Values, 在Values.table中提取</li><li>如果Values不存在, 则创建一个</li><li>如果提取的Key不等于当前ThreadLocal, 说明冲突, 继续调用Values.getAfterMiss</li></ul></li><li>ThreadLocal.set()<ul><li>拿到当前线程的Values, 如果不存在就创建一个</li><li>然后调用Values.put, 找合适位置放进去</li></ul></li></ul></li></ul></li><li>Looper的副业<ul><li>当epoll_wait被唤醒后, 轮询event发现fd不等于mWakeEventFd, 则进入else开始副业</li><li>这些事件是通过addFd添加到EpollFd中让其进行监听的(epoll_ctl)</li><li>通过Java的MessageQueue#addOnFileDescriptorEventListener, 底层在调用NativeMessageQueue::setFileDescriptorEvent进行添加</li><li>Framework层没用这个机制, Native有使用<ul><li>Vsync机制唤醒, Choreographer初始化的时候, 在底层给自己的Looper添加了Fd, 该Fd在SurfaceFlinger进行创建, 其中读的fd被跨进程传递到应用进程, 再在Choreographer的线程中将其添加到Looper监听的Fd中</li><li>当新来来的时候, 就会将信号写入SurfaceFlinger中的写fd, 应用进程就可以监听到可读事件</li><li>通过监听fd与bindCall的抉择<ul><li>使用fd, 应用端可以控制监听fd的线程, 并且可以一次拿到所有的事件, 自己决定何时进行分发</li><li>使用binderCall的话, 应用端接收到消息只能带binder线程, 如果不采用oneway, 会阻塞服务端, 如果采用oneway, 客户端只能按照顺序处理事件, 灵活性差</li></ul></li><li>小Demo<ul><li>MainActivity创建管道, 并通过bindService与其他进程的Service通信, 将读fd传递给它, Service将该Fd添加到Looper监听, 然后MainActivity向自己的写fd写入信息, 处于其他进程的Service收到消息, 并通过binder返回给MainActivity</li><li>管道创建: ParcelFileDescriptor.createPipe, 0号读, 1号写</li><li>写管道: AutoCloseOutputStream(fd[1])</li><li>需要通过反射将读fd设置为非阻塞, 否则读不到消息就阻塞了</li><li>监听描述符: <ul><li>通过Queue#addOnFileDescriptorEventListener添加fd与回调</li><li>在回调中, 使用AutoCloseInputStream包装fd</li><li>循环读取直到没数据</li></ul></li></ul></li></ul></li></ul></li><li>检查线程耗时任务<ul><li>WatchDog, 系统来检查死锁<ul><li>检查哪个线程就把它加入WatchDog的Looper</li><li>可以同时检测多个线程, 锁</li><li>自己就是个线程, 继承了Thread</li><li>内部会有多个HandlerChecker(Runnable), 每个Checker可以添加多个Monitor进行监听</li><li>BinderThreadMonitor监控Binder线程使用<ul><li>Monitor的monitor回调调用native函数</li><li>blockUnitlThreadAvailable循环检测mExecutingThreadCount与mMaxThreads, 当有空闲线程时返回</li><li>mExecutingThreadCount会在binder线程每次从驱动读取东西时++, 返回广播之前–</li></ul></li><li>WatchDog线程跑一个死循环, 遍历所有checker, 调用scheduleCheckLocked<ul><li>如果没有Monitor, 并且Handler一直在polling状态, 则标记Complete, return</li><li>如果还没Complete, 则不继续执行新任务, 返回</li><li>继续向下则标记Complete为false, 并向Handler头部post一个消息, 记下startTime</li><li>Post中的Runnable会遍历Monitor列表, 调用monitor函数, 标记Complete为true</li><li>Watchdog会每隔30s检测Checker完成状况, 遍历所有Checker, 通过getCompletionStateLocked拿到所有完成情况, 取最大值<ul><li>检测过程中, 执行完了则COMPLETE, 如果还没执行完, 则用当前时间-startTime, 小于30秒, 则继续等待(WAIT), 大于30秒小于60秒再给一次机会(WAIT_HALF), 否则超时(OVERDUE)</li></ul></li></ul></li><li>系统服务添加<ul><li>APS, WMS, PMS通过addMonitor, 通过sychronized(this)尝试获取锁来监控死锁, 在单独的线程中检查, 这个monitor会被添加到WatchDog的main checker里</li><li>APS, WMS, PMS通过addThread, 内部会添加了一个新的HandlerChecker, 检测工作线程(Handler的thread)是否阻塞</li></ul></li></ul></li><li>BlockCanary, 检查消息有没有耗时<ul><li>因为消息队列在拿到消息后, dispatching前后会打log, 并且logging可以自己配置, 则可以通过这个获取消息处理时间</li></ul></li></ul></li><li>同步处理消息<ul><li>在发消息后, 进行等待, 待消息处理完成后, 获取消息结果</li><li>Native<ul><li>底层调用MessageBase::wait等待消息</li><li>返回后通过MessageBase::getResult获取结果</li></ul></li><li>Java<ul><li>Handle#runWithScissors, 将Runnable包装到BlockingRunnable里</li><li>postAndWait会发送之后在同步块内循环检测mDone, 并且wait()</li><li>run内执行runnable, 返回结果后标记mDone, 并notifyAll()</li><li>可以改进BlockingRunnable, 传入Callable<t>, 通过getResult获取结果</t></li><li>也可以直接使用FutureTask, 它既是Runnable, 又可以阻塞获取结果</li></ul></li><li>binder调用统一切换工作线程<ul><li>通过动态代理</li><li>自定义ProxyInvocationHandler, 传入对象, Handler, Async标识</li><li>在invoke里, 判断没有Handler, 则直接调用, 如果有, 则将方法调用包装到FutureTask里, 并post到Handler里进行执行, 并且根据Async标识判断是否需要等待task执行结果</li></ul></li></ul></li><li>ActivityThread与ApplicationThread<ul><li>ActivityThread里持有ApplicationThread</li><li>ActivityThread是Zygote创建的运行主线程的对象</li><li>ApplicationThread是一个Binder实现, AMS通过它与App进行通信, 它再通过ActivityThread内的H (handler)与主线程通信</li></ul></li><li>Framework解决实际问题<ul><li>空Activity也会占用内存20m<ul><li>zygote启动会预加载系统资源, 主要跟主题相关的</li><li>zygote启动应用进程则会继承资源</li><li>getDrawable先拿cache, 再拿预加载资源</li><li>加载完成后, 缓存到cache</li><li>所以不需要UI的单独进程后台Service可以反射清掉他们</li></ul></li><li>为何Activity onResume后才显示<ul><li>在handleResumeActivity中, 需要window被加入windowmanager, willBeVisible才会为true</li><li>获取window的decorview添加到wm中<ul><li>requestLayout内部通过choreographer触发绘制</li><li>通过windowSession注册window, 与WMS形成双向调用</li></ul></li><li>Activity.makeVisible重绘</li></ul></li><li>为何bindService时候onRebind掉不到<ul><li>onRebind的触发是当Service还在, 但是应用死了, 会在unBind的时候将doRebind标记为true, 下次再次bind的时候会调用onRebind</li></ul></li><li>广播onReceive的context可否启动Activity<ul><li>onReceive的context, 动态注册为注册时的context, 静态注册的则是以application为mBase的ContextWrapper, 不是Activity本身</li><li>所以动态注册可以直接启动, 静态需要添加<code>FLAG_ACTIVITY_NEW_TASK</code></li><li>静态不能弹出AlertDialog</li></ul></li><li>ContentProvider的onCreate早<ul><li>虽然ContentProvider在Application的attatch之后创建并onCreate, 但是它是在Application的onCreate之前.</li></ul></li><li>Intent带数据量大会异常<ul><li>Binder共享共建1M所有事务共享</li><li>当数据小于16K会直接写Parcel, 但未开allowFd且大于16K也会直接写, 就会报错</li><li>所以需要传binder来开启fd传输, 将ashmen共享内存的fd传过去</li></ul></li><li>Handler延时精度<ul><li>handler取message后, 遍历所有, 如果时间未到则设置剩余时间, 通过epoll_wait来等待</li><li>所以精度不高</li></ul></li><li>IdleHandler有时候不掉<ul><li>当无消息, 或者没可执行消息时, 调用一次, 如果再次唤醒, 则不会再调</li></ul></li></ul></li><li>Framework用到的设计模式<ul><li>单例<ul><li>同进程<ul><li>系统有Singleton<t>的抽象, 如IActivityManager</t></li></ul></li><li>同线程<ul><li>通过ThreadLocal<t>, 保证线程内每次都拿到同一个对象, 不同线程拿到的确是不同对象</t></li></ul></li><li>进程间<ul><li>ServiceManager与binder驱动结合, 形成进程单例</li><li>ServiceManager对应的binder句柄都是0</li></ul></li></ul></li><li>观察者<ul><li>Broadcast可以进程间, 进程内</li><li>进程内<ul><li>系统抽象类Observable<t></t></li></ul></li><li>进程间<ul><li>ContentService可以注册通过Transport实现的IContentObserver, 其实是一个Binder, 这样远端的Service就可以通过Binder来通知, 本地的Transport收到onChange后再通过内持有ContentObserver进行分发</li><li>RemoteCallbackList利用同一个binder实体在目标进程只会有一个binder proxy对象, 虽然有多个业务层封装, 但是通过asBinder可以拿到唯一, 来实现注册与反注册, 这样Binder Proxy作为Map的key, 而Callback (业务层Binder)作为Value</li></ul></li></ul></li><li>代理<ul><li>静态代理<ul><li>ActivityManagerProxy实现IActivityManager将所有业务代理给内部的mRemote(IBinder, binder proxy)对象</li><li>ActivityManagerNative#asInterface, 通过binder.queryLocalInterface, 如果返回不为空, 则与Binder实体在一个进程, 直接返回, 如果未空, 则创建Proxy, 封装为业务代理对象</li><li>比如startActivity就会通过mRemote#transact, 它就是binder proxy对象</li></ul></li><li>动态代理<ul><li>Decorator<t>实现了InvocationHandler</t></li><li>它的newInstance(T obj, DecorationLinstener l), 通过反射给obj加上动态代理(Proxy.newProxyInstance, 需要三个参数, ClassLoader, Interface, InvocationHandler), 在调用obj方法前后时, 回调listener</li></ul></li></ul></li></ul></li><li>Framework设计<ul><li>Binder, 跨进程, 模糊进程边界<ul><li>请求转发, 从客户端进程转发到目标进程, 处理完再把结果返回</li><li>Binder对象传递, 实体对象跨进程后就变代理对象, 代理对象回到所在进程又变实体, 都是在驱动层转换, 但应用层永远拿到的是统一接口对象</li><li>分层结构<ul><li>应用端BinderProxy (Java) -&gt; BpBinder (Native) -&gt; 驱动</li><li>服务端Binder (Java) -&gt; BBinder (Native) -&gt; 驱动</li></ul></li><li>转换<ul><li>Binder为实体<ul><li>是否创建node (实体), 没有则创建, 且localBinder实体复制给cookie</li><li>是否创建目标进程引用, 没有则创建</li><li>改类型为Handle, 且handle复值上一步创建的引用</li></ul></li><li>Binder为引用<ul><li>是否是同一进程, 如果是, 查找node, 改类型为Binder, 给cookie赋值</li><li>非同一进程, 则查找目标进程引用, 没有创建, 赋值给handle</li></ul></li></ul></li></ul></li><li>Bitmap大图传输, 传输匿名共享内存句柄, 到目标进程再映射内存<ul><li>常规的数据得先拷贝到Parcel, 再拷贝到Binder驱动, 到目标进程再从Parcel拷出来, 三次拷贝</li><li>通过匿名共享内存只需要一次甚至不需要拷贝<ul><li>将图片拷贝到Ashmem空间传输fd, 但是这个fd没有被写到Bitmap中, 所以每次发送都需要拷贝</li><li>读取的话如果是Ashmem, 则直接映射, 作为Bitmap的像素缓冲区, 这次生成的Bitmap内会写入Ashmem的Fd, 则这张图如果再次传输, 就会非常快, 省去上一步的拷贝</li></ul></li></ul></li><li>Zygote创建进程, 预加载资源, 每次应用启动, 不需要重复做事, 加速应用启动</li><li>Intent, 模糊进程边界, 如Broadcast<ul><li>动态广播会并送发送，AMS通过binder进行one-way通信到app进程</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      Android Framework 知识点
    
    </summary>
    
      <category term="Android Framework" scheme="http://talentprince.github.io/categories/Android-Framework/"/>
    
    
      <category term="Android，Android Framework" scheme="http://talentprince.github.io/tags/Android%EF%BC%8CAndroid-Framework/"/>
    
  </entry>
  
  <entry>
    <title>如何自定义Kubernetes资源</title>
    <link href="http://talentprince.github.io/2020/12/14/Custom-your-own-k8s-resource/"/>
    <id>http://talentprince.github.io/2020/12/14/Custom-your-own-k8s-resource/</id>
    <published>2020-12-14T03:20:20.000Z</published>
    <updated>2020-12-16T00:48:14.272Z</updated>
    
    <content type="html"><![CDATA[<p>目前最流行的微服务架构非<code>Springboot+Kubernetes+Istio</code>莫属, 然而随着越来越多的微服务被拆分出来, 不但Deploy过程boilerplate的配置越来越多, 且繁琐易错, 维护成本也逐渐增高, 那么是时候采用k8s提供的扩展自定义资源的方法, 将重复的template抽到后面, 从而简化Deploy配置的数量与复杂度.</p><a id="more"></a><p>Tips:<br><code>一个基础的k8s微服务应该由几部分组成, 首先Deployment负责App的部署, Service负责端口的暴露, ServiceAccount负责赋予Pod相应的Identity, ServiceRole+RoleBinding负责api的访问权限控制, VirtualService负责路由</code></p><p>如果我们通过自定义资源的方式, 将每个微服务App的共有配置封装起来, 暴露出可变部分供各个应用配置, 如image, public/private api, mesh内访问权限等, 并设置mandatory/required的字段与validation pattern, 这样每一个App只需要一个配置文件, 就可以完成统一部署.</p><p>下面我们可以首先看一下k8s提供的扩展的两种方法.</p><ul><li>通过Aggregated Apiserver</li><li>通过Custom Resource Defination</li></ul><p><img src="/images/k8s-extension.png" alt="k8s-extension"></p><p>这两种最大的区别就是, 前者需要自己实现一个用户自定义的Apiserver, 而后者是被kube-apiserver内的extension apiserver module所处理.</p><p>二者都需要通过自定义Controller来处理资源的配置.</p><h2 id="创建CRD"><a href="#创建CRD" class="headerlink" title="创建CRD"></a>创建CRD</h2><p>虽然看似AA的开放程度更高, 但实际上通过CRD来定义自定义资源更成熟且方便. 通过<a href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" target="_blank" rel="noopener">官方文档</a>, 我们可以看到CRD的定义规则, 如下面我们定义的一个资源<code>Beer</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apiextensions.k8s.io/v1</span><br><span class="line">kind: CustomResourceDefinition</span><br><span class="line">metadata:</span><br><span class="line">  name: beer.weyoung.io</span><br><span class="line">spec:</span><br><span class="line">  group: weyoung.io</span><br><span class="line">  versions: </span><br><span class="line">    - name: v1alpha1</span><br><span class="line">      storage: true</span><br><span class="line">      served: true</span><br><span class="line">      schema: </span><br><span class="line">          openAPIV3Schema: </span><br><span class="line">            type: object</span><br><span class="line">            properties:</span><br><span class="line">              spec:</span><br><span class="line">                type: object</span><br><span class="line">                properties:</span><br><span class="line">                  BeerName:</span><br><span class="line">                    description: This is a custom field of beer      </span><br><span class="line">                    pattern: ^[a-z]+$</span><br><span class="line">                    type: string</span><br><span class="line">                required: </span><br><span class="line">                - beerName</span><br><span class="line">            required: </span><br><span class="line">            - spec</span><br><span class="line">            type: object</span><br><span class="line">  names:</span><br><span class="line">    kind: Beer </span><br><span class="line">    listKind: BeerList</span><br><span class="line">    singular: beer</span><br><span class="line">    plural: beers</span><br><span class="line">  scope: Namespaced</span><br></pre></td></tr></table></figure><p>这里我们添加了一个自定义字段<code>beerName</code>, 指定了pattern, 并且设置了spec与其下的beerName死<code>required</code>字段. 其余关键字可以查阅<a href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" target="_blank" rel="noopener">官方文档</a>.</p><p>在apply该配置后, 通过<code>kubectl get crd</code>即可获得已经存在的资源.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   kubectl get crd</span><br><span class="line">NAME                   CREATED AT</span><br><span class="line">beers.weyoung.io   2020-12-12T17:28:34Z</span><br></pre></td></tr></table></figure><p>有了CRD之后, 我们就可以apply自定义的资源了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: weyoung.io/v1alpha1</span><br><span class="line">kind: Beer</span><br><span class="line">metadata:</span><br><span class="line">  name: test-beer</span><br><span class="line">spec:</span><br><span class="line">  beerName: abc</span><br></pre></td></tr></table></figure><p>这里大家可以试验一下required与pattern的作用是否生效.</p><p>这里有个比较关键的点, CRD中未声明的资源依旧可以被成功添加到<code>Beer</code>资源里, 并成功apply&amp;configured, 但是不具备validation的效果, 这也可能是早期版本的crd把<code>schema</code>关键字换做<code>validation</code>的原因吧.</p><h2 id="创建Controller"><a href="#创建Controller" class="headerlink" title="创建Controller"></a>创建Controller</h2><p>当我们实现了自己的CRD, 并且apply了根据CRD定义的自定义资源<code>Beer</code>后, 这仅仅是存在etcd的静态资源, 还需要controller来根据<code>Beer</code>的变化创建相应资源, 让<code>Beer</code>动起来.</p><p>首先可以先了解一下Controller的工作原理.</p><p><img src="/images/k8s_controller.jpg" alt="controller"></p><p>从图中可以看出, Informer模块内的Reflactor会监听k8sapi, 根据自己注册的资源类型, 轮询的将所有资源的最新状态存入队列, Indexer会对资源进行index, 生成key与namespace/name的映射关系. </p><p>通过Informer的监听方法, 可以从队列依次读取, 放进WorkQueue中供controller消费, 而controller可以通过Lister API由namespace/name获取到对应的自定义资源, 并做增删改查操作.</p><p>看似有很多模块在其中, 不过k8s已经帮我们实现了大部分(Informer, Lister等), 即它的<code>client-go</code> library. 我们只需要用对应的api来实现自己的controller部分就可以了.</p><p>具体的逻辑, k8s官方提供了一个<a href="https://github.com/kubernetes/sample-controller" target="_blank" rel="noopener">sample-controller</a>来供大家学习, 本人通过对这个sample的踩坑, 总结了一些需要注意的地方会在之后highlight出来.</p><p>总体来讲, 自定义自己的controller需要三个步骤:</p><ul><li>定义资源Type与注册</li><li>生成Informer相应代码</li><li>编写与调用Controller</li></ul><p>当然在这之前, 需要先添加依赖.</p><ul><li>apimachinery 负责client与k8sapi之间通信编解码等</li><li>client-go 调用k8s cluster相关api</li><li><p>code-generator 根据定义的type生成相关代码, 包括informer, client</p><p>这里需要注意的是依赖版本应该最新, 并且一致, 因为在尝试多次之后, 发现新老版本之间的变化非常大, 添加了很多新的module与功能, 而且如果不一致, 也会导致代码生成, 与k8sapi之间通信等各种的异常.</p><p>当我们通过<code>go init custom-k8s-controller</code>初始化新的module后, 可以添加最新依赖:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go get apimachinery@master</span><br><span class="line">go get client-go@master</span><br><span class="line">go get code-generator@master</span><br></pre></td></tr></table></figure></li></ul><h3 id="定义Type与注册"><a href="#定义Type与注册" class="headerlink" title="定义Type与注册"></a>定义Type与注册</h3><p>首先需要在工程目录创建一个存放自己api module的地方, 如<code>api</code>, 并在之下创建<code>beercontroller</code>, 放置我们自定义资源相关的代码, 版本号可以自己定义, v1/v1alphav1.</p><ul><li><code>types.go</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package v1alpha1</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">metav1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// +genclient</span><br><span class="line">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span><br><span class="line"></span><br><span class="line">//Beer is a custom kubenetes resourec</span><br><span class="line">type Beer struct &#123;</span><br><span class="line">metav1.TypeMeta   `json:&quot;,inline&quot;`</span><br><span class="line">metav1.ObjectMeta `json:&quot;metadata,omitempty&quot;`</span><br><span class="line">Spec              BeerSpec `json:&quot;spec&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//BeerSpec is the spec of Beer</span><br><span class="line">type BeerSpec struct &#123;</span><br><span class="line">BeerName string `json:&quot;BeerName&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span><br><span class="line"></span><br><span class="line">//BeerList is a list of Beer</span><br><span class="line">type BeerList struct &#123;</span><br><span class="line">metav1.TypeMeta `json:&quot;,inline&quot;`</span><br><span class="line">metav1.ListMeta `json:&quot;metadata&quot;`</span><br><span class="line"></span><br><span class="line">Items []Beer `json:&quot;items&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了<code>Beer</code>的成员<code>BeerName</code>, 且有两行给代码生成器的注释也很关键, 不能缺失.</p><ul><li><code>register.go</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">var (</span><br><span class="line">// SchemeBuilder initializes a scheme builder</span><br><span class="line">SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)</span><br><span class="line">// AddToScheme is a global function that registers this API group &amp; version to a scheme</span><br><span class="line">AddToScheme = SchemeBuilder.AddToScheme</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func addKnownTypes(scheme *runtime.Scheme) error &#123;</span><br><span class="line">scheme.AddKnownTypes(</span><br><span class="line">SchemeGroupVersion,</span><br><span class="line">&amp;Beer&#123;&#125;,</span><br><span class="line">&amp;BeerList&#123;&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// register the type in the scheme</span><br><span class="line">metav1.AddToGroupVersion(scheme, SchemeGroupVersion)</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里省略了一些, 完整代码可参考官方<a href="https://github.com/.kubernetes/sample-controller/blob/master/pkg/apis/samplecontroller/v1alpha1/register.go" target="_blank" rel="noopener">sample</a>. 这里主要的逻辑是将我们定义的资源注册上去, 当然由于还没有运行generator, AddKnownTypes会因为我们的<code>Beer</code>没有Deepcopy而报错.</p><h3 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h3><p>之前讲过需要实现一个完整的自定义k8s资源需要很多东西, 但实际上除了controller之外的都可以生成出来, 这里就使用到了<code>code-generator</code>里面的<code>generate-groups.sh</code>.</p><p>由于要使用该脚本, 这里我们可以添加<code>vendor</code>来管理我们的之前添加的依赖. 在工程的根目录输出<code>git mod vendor</code>来创建vendor目录, 这时所有之前添加过的依赖 (go.mod)都会出现在这个文件夹下供我们项目使用.</p><p>关于如何调用generator的逻辑可以参考官方<a href="https://github.com/kubernetes/code-generator/blob/master/hack/update-codegen.sh" target="_blank" rel="noopener">sample</a>, 这里我们需要给<code>vendor</code>整体(-R)赋予可执行权限, 否则在generate的过程会提示权限问题.</p><p>关于<code>generate-groups.sh</code>的使用需要注意的是它其中的2,3,4参数, 分别为输出目录, 输入目录(我们自定义资源的module所在的目录, 即之前创建的api文件夹), 自定义资源名:版本.</p><p>具体参数设置也可以参考:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">../vendor/k8s.io/code-generator/generate-groups.sh \</span><br><span class="line">  &quot;deepcopy,client,informer,lister&quot; \</span><br><span class="line">  custom-k8s-controller/generated \</span><br><span class="line">  custom-k8s-controller/api \</span><br><span class="line">  beercontroller:v1alpha1 \</span><br><span class="line">  --go-header-file $(pwd)/boilerplate.go.txt \</span><br><span class="line">  --output-base $(pwd)/../../</span><br></pre></td></tr></table></figure><p>在执行脚本过后, 它会在<code>types.go</code>旁生成deepcopy代码, 并会在我们指定的generated文件夹下生成informer, lister等代码.</p><h3 id="编写与调用Controller"><a href="#编写与调用Controller" class="headerlink" title="编写与调用Controller"></a>编写与调用Controller</h3><p>现在万事俱备只欠实现最后的自定义资源处理逻辑, 就是之前提到的controller.</p><p>首先我们需要定义controller的成员:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type Controller struct &#123;</span><br><span class="line">// kubeclientset is a standard kubernetes clientset</span><br><span class="line">kubeclientset kubernetes.Interface</span><br><span class="line">// beerclientset is a clientset for our own API group</span><br><span class="line">beerclientset clientset.Interface</span><br><span class="line"></span><br><span class="line">deploymentsLister appslisters.DeploymentLister</span><br><span class="line">deploymentsSynced cache.InformerSynced</span><br><span class="line">beersLister   listers.beerLister</span><br><span class="line">beersSynced   cache.InformerSynced</span><br><span class="line"></span><br><span class="line">// workqueue is a rate limited work queue. This is used to queue work to be</span><br><span class="line">// processed instead of performing it as soon as a change happens. This</span><br><span class="line">// means we can ensure we only process a fixed amount of resources at a</span><br><span class="line">// time, and makes it easy to ensure we are never processing the same item</span><br><span class="line">// simultaneously in two different workers.</span><br><span class="line">workqueue workqueue.RateLimitingInterface</span><br><span class="line">// recorder is an event recorder for recording Event resources to the</span><br><span class="line">// Kubernetes API.</span><br><span class="line">recorder record.EventRecorder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中kubeclientset可以调用k8s的CRUD api, 例如创建更新deployment; beerclientset可以调用自定义资源的CRUD; deploymentsLister与beersLister可以通过namespace/name获得对应资源; workqueue用来同步与限流多个自定义资源处理worker; recorder用来publish在资源处理过程中的事件, 该事件可以在kubectl describe里面看到.</p><p>接着我们可以创建构造函数将clientset, informer传入构建自己的controller对象, 并通过informer的<code>AddEventHandler</code>添加监听, 将回调的beer资源通过indexer(cache)的MetaNamespaceKeyFunc方法转换为key, 加入workqueue队列.</p><p>当然有队列必然有死循环去读取这个队列, 这也是我们启动整个controller的入口, 我们需要从workqueue中pop交由下游处理, 在处理成功后调用forget方法清除queue, 否则会重新进行处理.</p><p>处理资源是我们controller的核心逻辑, 这里我们可以再次通过indexer(cache)通过key反转回namespace/name, 然后通过listers查找对应的资源, 比如beer或者deployment, 通过对比自定义资源与背后k8s资源的区别, 对k8s资源进行CRUD.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">func (c *Controller) syncHandler(key string) error &#123;</span><br><span class="line">// Convert the namespace/name string into a distinct namespace and name</span><br><span class="line">namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(&quot;invalid resource key: %s&quot;, key))</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Get the beer resource with this namespace/name</span><br><span class="line">beer, err := c.beersLister.beers(namespace).Get(name)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">// The beer resource may no longer exist, in which case we stop</span><br><span class="line">// processing.</span><br><span class="line">klog.Infof(&quot;beer %s is deleted &quot;, name)</span><br><span class="line">if errors.IsNotFound(err) &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(&quot;beer &apos;%s&apos; in work queue no longer exists&quot;, key))</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deploymentName := beer.Spec.beerName</span><br><span class="line">if deploymentName == &quot;&quot; &#123;</span><br><span class="line">// We choose to absorb the error here as the worker would requeue the</span><br><span class="line">// resource otherwise. Instead, the next time the resource is updated</span><br><span class="line">// the resource will be queued again.</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(&quot;%s: deployment name must be specified&quot;, key))</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deployment, err := c.deploymentsLister.Deployments(beer.Namespace).Get(beer.Name)</span><br><span class="line">// If the resource doesn&apos;t exist, we&apos;ll create it</span><br><span class="line">if errors.IsNotFound(err) &#123;</span><br><span class="line">deployment, err = c.kubeclientset.AppsV1().Deployments(beer.Namespace).Create(context.TODO(), newDeployment(beer), metav1.CreateOptions&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// If an error occurs during Get/Create, we&apos;ll requeue the item so we can</span><br><span class="line">// attempt processing again later. This could have been caused by a</span><br><span class="line">// temporary network failure, or any other transient reason.</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  // ***********************</span><br><span class="line">  // Handle custom CRUD here</span><br><span class="line">  // ***********************</span><br><span class="line"></span><br><span class="line">c.recorder.Event(beer, corev1.EventTypeNormal, SuccessSynced, MessageResourceSynced)</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个<code>syncHanlder</code>函数分为四个部分:</p><ul><li>通过index做key-&gt;namespace/name</li><li>通过lister查找beer资源<ul><li>如果不存在, 说明这是一次删除操作, 直接返回</li></ul></li><li>通过lister获取deployment<ul><li>如果不存在, 通过beer中相关字段创建对应的deployment, 或者其他k8s资源</li></ul></li><li>否则, 说明资源已经存在, 则对比beer与实际资源的区别, 判断是否需要对相应的资源, 如deployment进行更新. 这里举例子</li></ul><p>当然在整个过程中也可以通过<code>recorder</code>来广播event, 这样在apply自定义资源后, 可以获取一定信息, 方便查看或者debug问题原因.</p><p>controller完整的逻辑存在大量boilerplate的代码, 具体也可以参考官方的<a href="https://github.com/kubernetes/sample-controller/blob/master/controller.go" target="_blank" rel="noopener">sample</a>进行学习.</p><p>最后还有一点需要注意的是, 在我们创建并启动自己的controller时, 即本次<code>custom-k8s-controller</code>的入口main package内, 除了调用构造以及启动函数, 一定要记得传入的Informer需要调用<code>Start</code>进行启动, 否则无法获得资源变化的回调. 当然这里也涉及到需要传入一个stopSignal可以让监听中断, 这一个可以直接cop<a href="https://github.com/kubernetes/sample-controller/tree/master/pkg/signals" target="_blank" rel="noopener">y官方代码</a>.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>k8s已经提供了一个非常详尽的<a href="https://github.com/kubernetes/sample-controller" target="_blank" rel="noopener">demo</a>来实现自定义资源并通过controller进行配置, 但是对于没有go开发经验, 有不少由于版本, 依赖, 权限造成的小问题, 希望文章中highlight的点能提供一定帮助~</p><p>最后通过不懈努力, 我们可以通过一个自定义的Beer资源来deploy pod了. 由于这条路的打通, 我们可以继续添加CRD的schema, 并在controller内进行解析, 简化deploy过程, 统一基于k8s的微服务基础架构. 比如对于任意一个通过Beer资源deploy的app, 我们都通过istio sidecar来做ingress/outgress, 对于image的完整仓库地址, 我们也在后面通过不同部署(apply)环境来组合不同的地址, 还有大量缺省值的公共配置, 都不需要再重复的写在多个yaml中了.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://github.com/kubernetes/sample-controller" target="_blank" rel="noopener">https://github.com/kubernetes/sample-controller</a></li><li><a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/</a></li><li><a href="https://itnext.io/comparing-kubernetes-api-extension-mechanisms-of-custom-resource-definition-and-aggregated-api-64f4ca6d0966" target="_blank" rel="noopener">https://itnext.io/comparing-kubernetes-api-extension-mechanisms-of-custom-resource-definition-and-aggregated-api-64f4ca6d0966</a></li></ul>]]></content>
    
    <summary type="html">
    
      通过自定义Kubernetes资源来降低微服务开发与维护成本, CustomResourceDefinition
    
    </summary>
    
      <category term="DevOps" scheme="http://talentprince.github.io/categories/DevOps/"/>
    
    
      <category term="Kubernetes" scheme="http://talentprince.github.io/tags/Kubernetes/"/>
    
      <category term="Istio" scheme="http://talentprince.github.io/tags/Istio/"/>
    
  </entry>
  
  <entry>
    <title>Refresh Clean Code</title>
    <link href="http://talentprince.github.io/2020/10/27/Refresh-Clean-Code/"/>
    <id>http://talentprince.github.io/2020/10/27/Refresh-Clean-Code/</id>
    <published>2020-10-27T04:26:45.000Z</published>
    <updated>2020-10-27T04:30:36.661Z</updated>
    
    <content type="html"><![CDATA[<p>这是一本被前辈称赞, 另一个马丁的知名著作, 被赋予学习如何写出漂亮代码的教皇级手册, 最近(再)浏览, 有诸多感受.</p><p>总结一下就是如果你是新手, 可能看优秀的open source学习更好; 如果你是老手, 可能他说的东西要么你会觉得太啰嗦, 要么你会觉得例子太细节, 太教条, 无法举一反三.</p><p>不过一些General的要点思想我摘录了出来, 有些还包括个人的观点, 记录在此, 以备查阅.</p><a id="more"></a><ul><li>勒布朗(LeBlanc)法则, Later equals never</li><li>代码如果烂了就会越来越烂, 所谓破窗原理, 以前老是也提过叫代码腐化</li><li>命名<ul><li>命名应该合理, 成员变量不用加前缀, 靠高亮就很好</li><li>接口加前缀I也不太好, 不如实现加Imp</li><li>方法命名最好使用动词或动词短语</li><li>多使用计算机领域的词汇</li><li>有时候命名在语境里才有意义, 有时候变量命名也不需要重复语境</li></ul></li><li>函数<ul><li>函数短小一些比较易懂, 20行内最佳</li><li>if/else/while代码块封装函数, 只有一行最好 (有点激进?)</li><li>一个函数只干一件事情</li><li>复杂的switch试图用多态取代, 然后封装在抽象工厂里</li><li>同一类型函数命名风格应该一致, 使用描述性的语句描述比难懂的短词更好</li><li>一元函数最普遍, 标识函数(参数为boolean)的不如分成两个函数, 二元函数尽可能转换成一元函数</li><li>参数太多可能需要封装类了</li><li>好名字的函数一般是动词, 或者动词+关键字</li><li>函数一般要么做事, 要么回答事, 不可兼得 (其实也不一定, 比如很多返回boolean状态的函数)</li><li>推荐使用异常代替错误代码</li><li>最好将try/catch单独抽入一个函数 (如Android代码会对RemoteService调用进行类似封装, 吃掉exception)</li><li>使用枚举表示错误码会让改动变得繁琐 (重新导入或者编译部署), 大家都依赖这个枚举, 应该用异常与继承取代</li><li>不要重复, 偶尔可以考虑AOP这类的方法解决</li></ul></li><li>注释<ul><li>注释少要比注释多有用, 注释多说明代码糟糕 (其实分情况吧)</li><li>有目的性的注释还是有用的, 比如阐述, 放大, 警告, 定期维护的TODO等</li><li>如果代码不用, 不要注释掉, 直接删掉</li></ul></li><li>格式<ul><li>横向, 竖向对齐, 间隔, 缩进等. 其实目前formater已经很强大了, 养成良好的format习惯, 渐渐的写出来的代码就会像直接format后一样</li></ul></li><li>对象与数据结构<ul><li>面向过程与面向对象对立, 前者容易加函数, 不容易加对象, 后者容易加对象, 而不容易加函数</li><li>理想情况下, Law of Demeter认为, 类不应该操作对象内部的东西, 如不应该操作函数返回对象的方法. 目的只是为了降低复杂度, 认为这样将私有变量公开化, 增加了重构的难度, 如添加新函数, 方法等, 将数据结构与对象逻辑耦合在一起.</li><li>针对于上面的问题, 原则应该是对象暴露行为, 隐藏数据, 数据结构暴露数据</li></ul></li><li>错误处理<ul><li>Java特色的受控异常(Checked Exception), 必须得被catch, 对受控异常的修改会引起上层所有调用方法的改动, 尽量不要使用, 其他语言只有RuntimeException</li><li>可以包装第三方逻辑, 封装自己的异常类, 简化为只catch一种异常</li><li>简化使用也可以将异常处理完全封装进去, 返回特例即可</li><li>轻易不要返回null, 传入null</li><li>代码的坚固与干净不冲突, 所以添加一些check, throw相应的Exception也合理</li></ul></li><li>边界<ul><li>所谓边界就是自己可以控制到的程序与第三方的边界, 通常需要通过封装的办法来划清边界, 限制那些无法控制的第三方, 如直接Wrapper或者Adapter模式等</li></ul></li><li>单元测试<ul><li>测试需要整洁, 需要跟随代码一起更新, 测试的最大用途是保证你后续的修改有信心</li><li>测试的整洁主要讲的是可读性, 即分为三个环节, build-&gt;operate-&gt;check, 可以把繁杂的准备封装起来</li><li>测试API是渐渐重构演进过来的, 也不可能是起初就设计出来</li><li>有人建议每个测试一个assert, 但是这样会有很多重复的代码, 不过可以利用<code>Template Method</code>来解决. 不过也不一定必须一个, 做到最小化就可以了</li><li>整洁还有五条规则, Fast, Independent, Repeatable, Self-Validation, Timely</li><li>这里讲到TDD的好处, 主要是帮助你覆盖更多的测试, 如果写完再测, 发现测不了, 就不写了.</li></ul></li><li>类 <ul><li>类应该短小, 权责应该足够单一, 内聚性应该高</li><li>如果期望抽走一部分逻辑, 最好连相关函数参数也抽走</li><li>简化类的过程应该小步, 每一步都运行测试一下</li><li>类的精简是为了更好的体现开闭原则, 整体结构为修改而设计</li><li>类应依赖于接口, 不依赖实现, 可以隔离修改, 符合依赖倒置原则, 类似策略模式</li></ul></li><li>系统<ul><li>构造与使用分开, 通过依赖注入等</li><li>通过AOP, Proxy的方式, 无侵入性的插入逻辑</li><li>系统如果充分模块化, 领域之间相互直接松耦合, 最为理想, 就可以通过测试来驱动</li><li>DSL的使用可以平衡领域与技术</li></ul></li><li>迭代<ul><li>代码是在不断迭代中进步的, 比如通过抽函数, 运用设计模式等</li></ul></li><li>并发<ul><li>应该尽可能分离并发代码与其他代码</li><li>尽可能让线程之间独立, 不要有共享</li><li>线程模型有典型的生产者与消费者, 读者与作者, 宴席哲学家模型, 分别用来说明互斥, 读写, 竞争死锁等特例</li><li>锁定代码块应该尽可能小</li><li>线程最好可插拔, 遵循单一权责, 分离线程与其他代码,  测试先保证除线程之外的逻辑</li><li>最后一张通过实例来介绍并发代码如何重构的比较清晰</li></ul></li><li>逐步改进<ul><li>这片使用了一个例子, 先采用蛮干进行重构发现越来越难, 后来采用逐步的办法, 还写的很细节,  但是比较Tricky的地方是, 这里提出的每步改动都通过测试来印证, 然后保证测试通过, 或者补充一个测试, 让代码通过, 但是所谓TDD部分只有思想, 老代码既然写的不好, 测试是如何出来的, 如何做到Cover全的. 如果假设在一个有比较好测试覆盖的基础上重构, 我感觉即便蛮力也不会太差…</li></ul></li><li>JUnit<ul><li>比较神奇的一章, 感觉更像是用一个算法类的重构来说明如何把代码改简单, 但是开头先介绍了100%覆盖的Junit测试长什么样子… 感觉作者是想说以前的人做的还不错, 都用JUnit给覆盖全了, 还是可以重构的更漂亮的, 所以感觉标题不太好</li></ul></li><li>重构SerialDate<ul><li>跟上一个对比, 这个测试覆盖不全, 所以在补测试的过程中进行重构, 还发现了缺陷, 又最终把代码改清晰了. 不过同样由于太过细节, 一些重构理论也很教条, 如果想通过看别人重构的例子来学习如果写简洁的代码, 不如直接看优秀的代码是怎么写的</li></ul></li><li>味道<ul><li>里面类比了很多Bad Smell, 同样是很细节, 比如太多, 太死, 太复杂, 重复, 不一致, 耦合, 测试不足等, 提供的Tips大多的中心思想就是抽, 封装, 单一职责, 命名清晰</li><li>提到使用*来避免过长import, 不过这个与现在流行的lint检测违背, 可以因为以前都是手动, 通配符简单吧.</li><li>不要通过继承来使用常量, 还提到不要用静态常量, 用枚举, 这个也与当前的思想有出入, 现在经常将Java的enum太冗余, 不必要时可以用常量</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      Clean Code
    
    </summary>
    
      <category term="Clean Code" scheme="http://talentprince.github.io/categories/Clean-Code/"/>
    
    
      <category term="Note" scheme="http://talentprince.github.io/tags/Note/"/>
    
      <category term="Clean Code" scheme="http://talentprince.github.io/tags/Clean-Code/"/>
    
  </entry>
  
  <entry>
    <title>Java与Android知识点总结</title>
    <link href="http://talentprince.github.io/2020/09/08/Android-Points/"/>
    <id>http://talentprince.github.io/2020/09/08/Android-Points/</id>
    <published>2020-09-08T04:25:31.000Z</published>
    <updated>2020-09-08T04:41:19.807Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看关于Java以及Android开发相关知识点的视频, 有的非常细节, 有的则很概括, 本人也通过查阅文档对一些知识点进行了补充, 将其要点总结于此, 以供日后查阅.</p><a id="more"></a><ul><li>Char<ul><li>Char两个字节, 里面使用UTF-16编码</li><li>String的length是字符占据的长度, 而不是字符个数, python3.3以后已经改成实际个数了, 如果在微博输入一个emoj, 就会减2/3个字符</li><li>Java9会优化字符存储, 字母会用Byte来存字母, 而不是以前的2个字节</li><li>Unicode是字符集, 而不是编码</li><li>ASCII (Windows上简体中文用GB2312), Unicode (只规定了二进制代码, 不规定如何存, Windows上用UCS-2), UTF8 (1~4表示一个字符), UTF16 (UCS-2的父集, 2/4字节)</li></ul></li><li>String<ul><li>栈中的String, 使用<code>CONSTANT_Utf8_info</code>来存储, 长度为u2即两个字节长度, 所以最多65534个字节 (Java编译器用了&lt;而不是&lt;=, Kotlin没问题), 最终储存在方法区内的常量池</li><li>对于汉字, 得通过Utf8编码才知道占用字节, 这里使用了&gt;MAX所以可以存入65535/3个汉字</li><li>堆中的长度跟Int.Max一样, 有些虚拟机有头部保留, 可能为Max - 8</li></ul></li><li>方法绑定<ul><li>Java方法重载, 编译期就决定了, 调用声明类型</li><li>但是Groovy调用实际类型, 因为它先反射你的变量得到实际类型, 再调用</li><li>C++非虚方法只会调用声明类型方法, 虚方法只有指针调用时才触发虚绑定, C++对象本身赋值会触发赋值/复制构造, 进行裁剪, 所以无法触发绑定</li><li>Java方法都是虚方法, 覆写会动态绑定, 调用实际类型</li><li>注解扩展<ul><li>Target<ul><li>限制注解使用位置, 如METHOD, FIELD, TYPE(class/interface)等</li></ul></li><li>Retention<ul><li>约束其生命周期<ul><li>SOURCE 只会在代码里, 编译后丢失</li><li>CLASS 会保留在源码里, 但是不会加载到虚拟机, 如Override, Deprecate</li><li>RUNTIME 加载JVM,  运行时可通过反射用</li></ul></li></ul></li></ul></li></ul></li><li>Java泛型<ul><li>为了兼容性, Java用了假泛型, 类型擦出</li><li>基本类型无法作为泛型类型, 必须装箱拆箱, Android可以用SparseArray省去装箱</li><li>静态方法没法用类泛型, 因为会早于类实例化, 但可以自己定义方法泛型</li><li>即便有泛型, 1.5以后强转开销还在</li><li>Gson的TypeToken<x>(){}.getType()就是通过getGenericReturnType等方法拿到运行时泛型信息, 前提得<code>- keepattributes Signature</code>保存泛型签名<ul><li>TypeToken的构造为protected, 通过创建其匿名内部类调用getType方法</li></ul></x></li><li>Retrofit的接口定义Call<x>泛型信息也是通过类似方法</x></li><li>Kotlin反射原理来自最终的注解Metadata, 反射得把<code>kotlin.Metadata{*;}</code>给keep了</li><li>混淆扩展<ul><li>keep 类所有东西都保留</li><li>keepclassmembers 指定的成员保留, 比如方法, 类成员</li><li>keepclasseswithmember 保留满足条件(含某成员或者方法)的类</li></ul></li></ul></li><li>onActivityResult<ul><li>不能使用简单回调是因为activity可能重建, 回调匿名类持有的已经不是显示出来的</li><li>新API里通过prepareCall/launch或者直接ActivityResultRegistry注册</li><li>改造回调办法<ul><li>基于DummyFragment实现回调 <ul><li>将回调存在一个地方, 再次返回调用新Fragment的onResult时将回调中的activity替换成新的</li></ul></li><li>基于AOP<ul><li>AOP hook住所有activiy的onResult, callback存全局map</li></ul></li><li>基于Hook<ul><li>向ActivityThread的handler callback里加入自己的handler, 然后拿出返回的activty进行回调</li></ul></li></ul></li></ul></li><li>线程停止<ul><li>stop/suspend被废弃了<ul><li>stop主要是因为stop后会释放所有线程锁, 这样其他线程就获取一些被保护的变量获取不一致的状态, 因为数据没有机会清理</li><li>suspend主要因为可能会造成死锁, 或者卡主其他的线程</li></ul></li><li>正常的中断方式<ul><li>boolean</li><li>interupt</li></ul></li><li>中断<ul><li>interrupted()<ul><li>静态方法, 获取当前线程,  读取后状态清空, 除非等到下一次打断信号</li></ul></li><li>isInterrupted()<ul><li>状态清除前一直是true</li></ul></li><li>Java层调用interrupted其实底层给<code>interrupted_</code>加锁并置位</li><li>除非用了sleep, 一般用boolean标志位就够了, boolean需要加上volatile, 并且比底层操作性能高</li></ul></li></ul></li><li>线程安全<ul><li>Java内存模型<ul><li>每一个线程都有内存副本, 更改完副本后, JMM会控制刷新主内存, 其他共享该内存的线程会去主内存拉去状态, 更新副本. 类似于线程一向线程二发消息.</li><li>JVM的内存会被分为, 线程栈区跟堆区.<ul><li>本地变量原始类型, 放在栈区, 对象类型引用在栈区, 实际对象在堆区</li><li>对象成员方法中的变量, 全部在栈区, 即便对象本身在堆区</li><li>对象的成员变量, 不管什么类型, 都在堆区</li><li>静态类本身与变量都会在堆区</li></ul></li><li>堆区的变量是多个线程共享的</li><li>volatile变量JMM会在写入字段后插入指令, 保证写入时其他线程也能看到更新</li><li>Java5以后提出happens-before模型, 保证前一个操作执行结果对后一个可见<ul><li>同一个线程, 顺序执行</li><li>解锁操作与随后的加锁操作</li><li>volatile的写入与其他线程的读取</li><li>传递性, A-hb-B, B-hb-C, 则A-hb-C</li></ul></li></ul></li><li>可变资源线程共享<ul><li>共享不可变资源</li><li>不共享资源<ul><li>函数不使用外部内存</li><li>ThreadLocal<ul><li>弱引用</li><li>定义全局静态final</li><li>避免存储大量对象<ul><li>因为它内部的map使用的开放定址, hash值为magicnumber的倍数</li></ul></li><li>用完即时移除<ul><li>因为它自己得线程退出才移除</li></ul></li></ul></li></ul></li><li>共享可变<ul><li>遵循原则<ul><li>可见性<ul><li>volitale防止操作副本</li><li>final防止重排序</li><li>加锁, 锁释放时会刷新主内存</li></ul></li><li>原子<ul><li>++不是原子操作, 因为会把原值放进tmp内再加</li><li>通过加锁保证</li><li>使用CAS指令, 如Unsafe.compareAndSwapInt<ul><li>这个方法得通过反射Unsafe内的<code>theUnsafe</code>得到实例</li><li>方法swap成功返回true, 否则返回false</li></ul></li><li>AtomicInteger等</li><li>AtomicReferenceFieldUpdater</li></ul></li><li>禁止重排序<ul><li>final可以禁止重排序, 保证赋值操作在构造体内完成</li><li>1.5之后, volitale也能保证改造函数一定在赋值操作之前调用, 写单例必须加上volatile</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>ConcurrentHashMap<ul><li>HashTable是全表加锁</li><li>优化进程<ul><li>1.5 分段加锁, 必要时加锁</li><li>1.6 优化二次hash算法</li><li>1.7 段懒加载, volatile加cas</li><li>1.8 摒弃段, 基于hashmap实现并发</li></ul></li></ul></li><li>AtomicReference与AtomicReferenceFieldUpdater<ul><li>ARFU指向前者, 占用16字节(压缩指针)或者24个字节 </li><li>ARFU使用反射, 创建一个静态的用于原子赋值, 节省内存</li><li>AR使用更简单</li><li>kotlin by lazy(PUBLICATION)使用的就是ARFU</li></ul></li><li>异步代码<ul><li>异步不一定快, 如果是CPU密集型可能会更慢, 因为切换需要消耗</li><li>通过RxJava解决回调低于, 注意异常处理, 以及disposable的处理, 如使用AutoDisposable</li><li>通过Kotlin协程处理, 参考AutoDiaposable写自动cancel, 通过class AutoDisposable(view, job): Job by job, OnAttachStateChangeListener的扩展+代理, 保证不改变原本launch的返回值为Job, 且可链式调用添加Listener控制cancel</li></ul></li><li>CPU架构适配(native)<ul><li>普通开发者与sdk开发者考虑问题不同, sdk要尽可能全, 并且优化体积</li><li>架构分为mips64/mips(废弃了) x86_64/x86(兼容armeabi) armeabi-v7a/v8a/armeabi</li><li>优先去对应目录找so, 如果不全, 则加载失败, 如果一个都没提供, 则会自动找兼容</li><li>简单的使用v7a最通用的so</li><li>复杂一些把不同的架构都放在armeabi里, 通过代码来加载对应, 获取优化, 如libmath.so</li><li>混用限于同一种位数, 比如都是32位 (arm与v7), 如果v8a机器加载armeabi中的v8a库则会以32位加载出问题</li><li>太大的so库又不是启动项则可以后期增量下载</li><li><code>-fvisibility=hidden</code>隐藏符号表, 只公开必要, <code>-fno-exceptions -fno ftti</code>用处不大可以去掉, 不要使用iostream使用android log, 可以通过gc-sections去除无用代码, 如cflags<code>-ffunction-sections</code> <code>-fdata-sections</code>, 以及ldflags<code>-WL</code> <code>--gc-sections</code></li><li>也可以使用官方的splits { abi {} }分包</li></ul></li><li>JNI绑定<ul><li>分静态绑定与动态绑定<ul><li>全部可见占用符号表, 名字写死, 但是AS可以跳转 </li><li>动态绑定(env-&gt;RegisterNative)任何时候都可以触发, 可以覆盖静态绑定</li></ul></li><li>需要暴露的JNI方法通过<code>extern &quot;C&quot; JNIEXPORT void JNICALL</code>进行声明<ul><li><code>JNIEXPORT</code>设置了函数的visibility为default</li><li><code>JNICALL</code>在某些平台上有定义, 如Windows定义了函数如何入栈等惯例规则</li></ul></li></ul></li><li>JNI数据传递<ul><li>指针通过long传递</li><li>字符串传递<ul><li>GetStringUTFChars/ReleaseStringUTFChars<ul><li>const char* Modified-UTF-8字节流, <code>\0</code>编码为0xc080, 不影响c字符串结尾</li></ul></li><li>GetStringChars/ReleaseStringChars<ul><li>const jchar* 自动处理字节序转换, Java是大端, C是小端</li></ul></li><li>GetStringUTFRegion/GetStringRegion<ul><li>需要自己开辟内存, 可以控制长短</li></ul></li><li>GetStringCritical/ReleaseStringCritical<ul><li>调用会暂停Jvm Gc 与 其他JNI操作</li></ul></li><li>这些函数大部分第二个参数都是<code>jboolean* isCopy</code>, 告诉你是不是复制的, 虚拟机支持的话, 可以指向Java层的字符串</li></ul></li><li>Local Reference有个数限制, 使用完就释放, 如果个数少可以等函数调用结束自动释放</li><li>ByteBuffer直接在物理内存开辟 (ByteBuffer.allocateDirect), 不需要拷贝, 底层直接通过<code>GetDirectBufferAddress</code>获取指针地址, 但是需要自己处理字节序</li><li>尽可能让底层访问少的Java对象, 减少反射, 多使用基本类型</li></ul></li><li>捕获Native异常<ul><li><code>struct sigaction</code> handler结构体</li><li>调用sigaction(SIGNAL, &amp;handler, &amp;old_hanlders[SIGNAL])设置新的handler, 保存旧的</li><li>然后再新handler内处理不同信号的异常, 处理完再交给oldhandler处理, 类似Java</li><li>对于底层pthread创建的线程, 要通过<code>Jvm-&gt;AttatchCurrentThread</code>来获得新的env, 并且结束后Detach</li><li>如果<code>Jvm-&gt;GetEnv</code>返回JNI_OK, 则可以直接使用, 利用这两个机制创建Helper对象, 析构函数Detach简化Env的获取</li><li>如果Env是attach到native线程上的, 就无法拿到Java层的类了, 就需要通过底层保存的<code>classLoader</code>对象调用findClass来找到jclass</li><li>JNI只有GlobalRef才可以被返回, LocalRef出了函数就被回收了</li><li>需要使用备用栈 (<code>action.sa_flags |= SA_ONSTACK;</code>),  防止SIGSEGV栈循环溢出无法拿到</li><li>通过独立线程收集, 通过libcorkscrew.so(4.1-5.0),libunwind.so(5.0+)</li><li>通过线程对应Java崩溃堆栈, 分析问题</li></ul></li><li>只有C/C++才能编译so吗<ul><li>只要符合规定就可以运行<ul><li>静态绑定<ul><li>符号表可见</li><li>命名符合报名_类名_方法名</li><li>符号使用extern C修饰, 不能用C++</li></ul></li><li>动态绑定<ul><li>只要在JNI_OnLoad里注册就行</li></ul></li></ul></li><li>可选的编译成native的语言都可以<ul><li>Golang, Rust, Kotlin Native, Scala Native</li></ul></li><li>Kotlin Native<ul><li>@CName静态绑定native函数签名</li><li>JEnv*通过对象包装, CPointer<jnienvvar></jnienvvar></li><li>memScoped可以自动管理内存</li><li>动态注册需要通过<code>staticCFunction(::function)</code>拿到指针然后register</li></ul></li></ul></li><li>Activity启动<ul><li>Activity通过AMP(Proxy/Client)访问AMS<ul><li>解析Activity信息</li><li>处理启动参数</li><li>启动与绑定进程, 通过Zygote fork进程, 以便可以复用资源加快速度</li></ul></li><li>AMS通过ATP(Proxy/Client)#scheduleLaunchActivity返回Activity<ul><li>控制生命周期回调</li></ul></li><li>插件化就是在发起跟结束的时候欺上瞒下, hook发给AMS的信息, 并在返回ActivityThread后改回来</li><li>Bundler有缓冲区, 大小有限制, 数据必须序列化<ul><li>同一个进程就通过全局共享内存传大数据</li><li>进程间则可能需要ContentProvider之类的</li></ul></li><li>Activity跟Fragment都需要无参构造, 系统通过反射创建它<ul><li>new-&gt;attach-&gt;create-&gt;start-&gt;restoreState-&gt;postCreate-&gt;resume-&gt;makeVisible</li><li>attach-&gt;createPhoneWindow</li><li>create-&gt;installDecor (add, setContentView)</li><li>resume-&gt;显示 (status bar, action bar, content view)</li></ul></li><li>转场动画<ul><li>新页面显示之前, 拿到之前页面元素(共享元素)的位置信息, 应用到新元素并播放动画, 达到新页面位置</li></ul></li><li>跨App启动Activity<ul><li>sharedUserId相同, 直接通过Intent.setComponentName来启动</li><li>exported暴露, 公开可见</li><li>定义了私有的的action<ul><li>加上一个自定义permission, 但是必须主应用先安装, 才能申请到权限</li></ul></li><li>暴露的Activity如何防止其他人传未知类型导致crash, 拒绝服务漏洞<ul><li>trycatch包住intent.getExtra</li></ul></li></ul></li><li>Activity传参繁琐<ul><li>通过Builder设置Require以及Optional</li><li>在ActivityLifeCycleCallback的onActivityCreated里注入, 这是被onCreate触发的</li><li>onNewIntent需要单独手动处理</li><li>这些都可以通过注解生成器来生成<ul><li>需要合并父类的fields, 父类可能不需要生成builder</li><li>万一Activity是内部类可能需要特殊处理, 命名会有$</li><li>尽量少生成代码, kotlin与java之间类型的映射</li></ul></li><li>元编程<ul><li>apt (dagger, arouter), bytecode(replugin), generic, reflect, proxy(retrofit)</li></ul></li></ul></li><li>任意位置添加View<ul><li>GC回收<ul><li>被GCRoots持有都不会被回收<ul><li>虚拟机栈, 方法栈</li><li>静态类属性</li><li>常量引用</li><li>Native方法引用</li></ul></li><li>SoftRef<ul><li>内存快满才回收</li></ul></li><li>WeakRef<ul><li>GC一次就回收</li></ul></li></ul></li><li>Activity里面添加<ul><li>因为只有addContentView, 没有remove, 需要拿到decorview</li></ul></li><li>全局View<ul><li>通过window来添加</li></ul></li></ul></li><li>App右滑效果<ul><li>Fragment<ul><li>不涉及Window, View跟随手势</li><li>手势结束判断取消或者归位动画等</li></ul></li><li>Activity<ul><li>顶层Window背景为透明<ul><li>windowBackground</li><li>windowIsTranslucent (如果不设置, window背景会强制被改为不透明)</li></ul></li><li>多个Task<ul><li>在切task后会先显示另一个task最顶层再打开目标</li><li>可以通过偷偷放截图在下面障眼</li></ul></li><li>透明与生命周期<ul><li>看不到是create, 能看到是start, 顶层是resume</li></ul></li><li>SwipeBackActivity<ul><li>必须继承父类</li><li>必须设置windowIsTranslucent<ul><li>设置后下面的activity生命周期会变化, 永远会被绘制, 不会进入onStop </li></ul></li></ul></li><li>优化降低成本<ul><li>改继承为实现接口</li><li>通过隐藏方法在滑动的时候转换透明<ul><li>convertToTranslucent/convertFromTranslucent</li></ul></li></ul></li><li>造轮子, 或者改造现有轮子</li></ul></li></ul></li></ul></li><li>非UI线程更新UI<ul><li>Zygote–main函数–&gt;ActivtyThread-&gt;Loop–退出后–&gt;RuntimeException</li><li>Handler.post-&gt;Looper.loop-&gt;MessageQueue-&gt;Handler.dispatchMessage-&gt;MainThread</li><li>UI变化快需要高效, 所以不能加锁, 所以必须单线程更新</li><li>SurfaceView可以在非UI线程绘制, lockCanvas-&gt;draw-&gt;unLockCanvasAndPost, 主线程只显示, 所以帧率高</li><li>GLSurfaceView是SurfaceView的子类, 有GLThread进行绘制, 死循环不断onDrawFrame</li><li>Handler.postDelay<ul><li>enqueueMessage-&gt;wake-&gt;write</li><li>epoll_wait-&gt;pollOnce-&gt;next(当前时间与消息队列第一条消息时间, 到了就执行, 不到就继续等)-&gt;执行消息</li><li>delay不靠谱, 大于Looper周期基本可靠 (&gt;50ms)</li><li>消息队列优化<ul><li>重复消息过滤</li><li>互斥消息取消</li><li>obtain复用消息, 避免太多触发gc</li><li>IdleHandler, glide3是用它移除ReferenceQueue监听到需要移除的弱引用</li><li>HandlerThread可以自己开线程穿件Looper, 内部已经Loop.prepare+loop过了</li></ul></li></ul></li><li>Looper与ANR<ul><li>Service(20s/200s), Broadcast(10s/60s), ContentProvider(10s), InputDispatch(5s)卡久了就ANR</li><li>AMS-&gt;ActiveService-&gt;到app启动Service, 开始后AS会发一个延迟的消息, scheduleServiceTimeoutLocked, 如果规定时间内没有执行完调用doneExecutingLocked, 就会发送handler message到UI线程, 弹出ANR对话框</li><li>Looper是消息循环, 里面出问题了才会有ANR</li><li>Looper空消息后调用epoll_wait, 等待文件消息, 不占用CPU<ul><li>epoll_ctl建立监听管道, rbtree</li><li>epoll_wait监听就绪列表, rdlist</li></ul></li><li>简单的Handler-Looper<ul><li>Handler内部用了开机后消耗了多少时间, 简单实现可以使用当前时间</li><li>Looper.prepare把对象存放在ThreadLocal里</li><li>Looper.loop启动循环调用next拿消息执行</li><li>MessageQueue可以用现成的DelayQueue来实现<ul><li>取消息阻塞类似于MessageQueue的nativePollOnce</li><li>不过take阻塞底层通过<code>pthread_cond_timeout</code>来实现</li><li>Android为何不使用DelayQueue<ul><li>没有合适的remove, android通过msg里的token(obj)移除</li><li>自己实现底层, 自由度更高</li><li>MessageQueue对单线程读取优化, 只有Looper现成读, 提前读取下一条消息</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>避免OOM <ul><li>选择合适的数据结构<ul><li>SparseArray+ArrayMap<ul><li>数量少于1000, 增删不频繁就用, 扩容慢, 还能缩容</li><li>内存复用, </li></ul></li></ul></li><li>整形替代枚举 4byte vs 24byte<ul><li>@IntDef限制类型, 只能提示不能阻止, kotlin也不支持</li><li>inline class</li></ul></li><li>图片使用<ul><li>选择合适分辨率, 注意原始分辨率与缩放关系<ul><li>xxhdpi放的匹配图片放入hdpi里面会缩放2倍, 占用更多内存</li></ul></li><li>bitmap使用重采样, 缩略图</li></ul></li><li>不用帧动画, 用代码实现</li><li>谨慎使用多进程, 因为进程本身分配了很多内存</li><li>使用NDK内存跳出JVM限制</li><li>5R原则<ul><li>Reduce, Reuse, Recycle, Refactor, Revalue</li></ul></li><li>图片如何缓存<ul><li>三级缓存</li><li>获取成本 缓存成本 缓存价值(命中率) 随着时间的变化</li><li>LRU(对应的还有LFU), 最近使用交换位置排在最后, 干掉最开始不常用的<ul><li>LRU内部有一些private的算法统计字段xxxCount</li><li>LRU线程安全, 采用短锁</li><li>LRU内部使用LinkedHashMap, accessOrder设置true会自动发访问过的放最后</li></ul></li></ul></li><li>图片占用内存大小<ul><li>根据dpi抽象出canvas层, 在不同设备上进行缩放</li><li>getByteCount应该占用内存</li><li>getAllocationByteCount实际占用, 当小图复用大图时</li><li>预先计算<ul><li>宽<em>高</em>像素编码位数</li><li>高dpi手机拿低dpi文件夹下的, 图片会变大 (scale=屏幕dpi/图片目录dpi + 0.5f)</li></ul></li><li>inSampleSize采样大变小, 矩阵变换小变大</li><li>使用svg, rgb_565, 9-patch, 不用图</li><li>通过assets中透明的indexed-png+rgb565强行加载index-8类型<ul><li>因为skia库中对于透明的565格式返回图本身</li><li>该类型不能通过Bitmap创建Canvas, 不能放入缩放目录</li><li>8.1底层开始被移除了</li></ul></li></ul></li></ul></li><li>Android P隐藏API<ul><li>@hide的函数可以通过自编jar骗过编译器</li><li>private的只能使用反射<ul><li>setAccessible绕过权限控制, 还可以修改final变量</li></ul></li><li>API名单<ul><li>白名单</li><li>浅灰名单 反射依旧可以用</li><li>深灰名单<ul><li>Targe低于28 可以使用</li><li>Targe&gt;=28 反射也不能用</li></ul></li><li>黑名单 反射也不能用</li></ul></li><li>Android修改了getDeclaredMethods方法, 调用底层检查是否在白名单或者是否是No_check的Policy</li><li>使用FreeReflection绕过检查<ul><li>修改Runtime的<code>hidden_api_policy</code><ul><li>底层通过JavaVM拿到JavaVMExt的私有变量Runtime</li><li>自己写个Struct凑位数, 第二个<code>void*</code>(没虚方法少一个vp)类型就是Runtime变量</li><li>Runtime里面通过每4个字节(内存对齐)查找定位变量位置</li><li>查找<code>target_sdk_version</code>做为定位点, 将Runtime转换为PartialRuntime拿到Policy修改</li></ul></li><li>修改<code>hidden_api_exemptions</code>, 让程序豁免<ul><li>类似于第一种方法拿到Runtime, 修改HiddenApiExemptions </li></ul></li></ul></li><li>修改想要使用的Class, 将其ClassLoader置空 <ul><li><code>fn_caller_is_trusted</code>判断如果classLoader是空认为是bootClassLoader</li><li>可以在Java层修改, 也可以在native层修改</li></ul></li></ul></li><li>换肤功能<ul><li>Theme只支持定义的时候配置的值, 无法外部与动态加载</li><li>资源加载Context-&gt;Resource-&gt;AssetsManager (xml, 非xml, ResourceValue, ResourceText)</li><li>Resources内缓存替换<ul><li>替换资源有限, 只能替换缓存过的</li><li>Hook繁琐</li></ul></li><li>ResourcesWrapper包装<ul><li>不支持style, assets目录</li><li>包装起来代码量大</li><li>id映射可以在编译时期一致, 或者动态映射<ul><li>Id映射成资源name, 然后替换package再查找资源包新Id</li></ul></li></ul></li><li>AssertManager替换<ul><li>支持style, assets, 替换简洁</li><li>不能动态映射, 只能编译器需要对齐资源ID<ul><li>aapt输入主包的id映射表, public.xml</li><li>或者修改resource.arsc</li><li>如果皮肤资源少, 不能剔除public.xml, 因为剔除后位置会被后续非public资源补位, 保持资源紧凑</li><li>皮肤包资源需要对自己没有而主包有的资源进行占位/补位, 保证主包资源能加载进来<ul><li>修改AAPT, 或者直接修改resource.arsc</li><li>ResourceTable#applyPublicEntryOrder中间为不存在的占坑</li><li>如果最后有少资源还需要补位</li></ul></li></ul></li><li>非运行时替换<ul><li>编译器主包跟皮肤包差分, 应用阶段主包再与差分包合成皮肤包, 需要资源重定向</li><li>创建新的AssertManager只需要加入一个包即可, 因为包含所有资源</li></ul></li><li>反射创建并调用AssertManager#addAssetPath方法加入主包, 皮肤包, L以上要单独把Assets拿出来最后再加一次<ul><li>插件化是为了资源并存</li><li>皮肤是为了覆盖</li></ul></li><li>创建WrapContext<ul><li>attatchBaseContext的时候包装, 替换掉里面的resource, assertManager, classLoader<ul><li>Resource可以通过AssertManager构造</li></ul></li><li>getBaseContext的时候解包</li><li>可以使用JavaAssist改字节码插入attatch/detach方法</li></ul></li></ul></li></ul></li><li>VirtualAPK<ul><li>ClassLoader双亲委派<ul><li>DexClassLoader (user/plugin) -&gt; PathClassLoader (context) -&gt; BootClassLoader (parent)</li><li>先查看是否加载, 然后由父类查找, 父类查不到再让子类查找</li><li>他们都继承了BaseClassLoader-&gt;ClassLoader</li><li>BaseClassLoader#findClass会在pathList里查找类, 而这个list就是dex的list</li></ul></li></ul></li><li>Tinker<ul><li>Patch与Apk组成新Apk并放在Dex数组最前面<ul><li>基于Dex的差分, DexSectionDiffAlgorithm/DexSectionPatchAlogrithm<ul><li>先排序再用双指针分别指向</li><li>如果Old指针指向小于New指针指向, 说明DEL了</li><li>如果Old指针指向大于New指针指向, 说明ADD了</li><li>如果相等, 则更新映射</li><li>最后Index相同内容不同, 删除ADD/DEL操作, 标识为REPLACE</li><li>最终把变化转换为差分后的操作</li></ul></li></ul></li><li>Assets直接创建新的AssetsManager<ul><li>基于Entry的BSDiff, 得出资源差分包</li><li>与旧资源组成新包, 创建新的AssetsManager加载</li></ul></li><li>异常熔断<ul><li>加载之前checkpatch</li><li>单一进程启动三次失败</li><li>十秒钟内崩溃多次</li><li>大量注释, 46000代码, 69%代码</li><li>早起监控129个</li></ul></li></ul></li><li>Shadow<ul><li>使用Hook在海外直接下架</li><li>由反射转入编译器字节码, 注解处理器的方案</li><li>Shadow属于静态代理流派, 使用了很多字节码编辑</li><li>插件化流派<ul><li>动态Hook<ul><li>发送的时候靠占坑Activity替换绕过AMS检测, AMS返回的时候再换回PluginActivity</li></ul></li><li>静态代理<ul><li>将Activity的启动与生命周期靠ProxyActivity代理, 然后传递给PluginActivity, Plugin寄生与Proxy不被系统获知</li><li>在编译的时候, 通过字节码修改, 将PluginActivity修改成寄生的ShadowActivity</li></ul></li></ul></li><li>Shadow结构<ul><li>manager (插件管理, 如版本)<ul><li>plugin (ShadowActivity)</li><li>runtime (PluginContainerAcitity, Proxy)</li><li>loader (实现插件加载)</li><li>plugin, runtime, loader可以有多组, 没各插件都有一组, manager只有一个, 他们都是单独的apk</li></ul></li></ul></li><li>Shadow模块<ul><li>DynamicPluginManager与PluginProcessService都在Host里, 前者负责加载Manger, 反射创建PluginManager实例, 而该实例负责启动跨进程通信Service</li><li>PluginProcessService负责启动Loader与Runtime</li><li>Manager通过Binder接口直接控制Loader加载对应Plugin</li></ul></li><li>宿主与插件ClassLoader关系<ul><li>ApkClassLoader负责加载Manager, Loader</li><li>RuntimeClassLoader负责加载Runtime, 唯一的反射将其挂在PathClassLoader之上, 为了让系统启动Proxy壳子</li></ul></li><li>宿主与插件资源关系<ul><li>分开, ShadowActivity默认注入插件资源</li></ul></li><li>字节码编辑<ul><li>Java -&gt; APT (AST-&gt;Symbol)-&gt;Class-&gt;Dex-&gt;Apk</li><li>Class-&gt;Transform-&gt;Dex通过Transform修改</li><li>源码-&gt;Javassit-&gt;ASM-&gt;字节码, 越来越抽象</li></ul></li><li>插件系统通信机制<ul><li>主从通信<ul><li>插件注册Callback到宿主</li><li>插件通过binder与宿主通信</li></ul></li><li>对等结构<ul><li>通信模块可能也是特殊的插件</li><li>低频用Broadcast, 高频用LocalSocket</li></ul></li></ul></li><li>插件更新管理<ul><li>差分包<ul><li>Dex使用DexDiff(Tinker)</li><li>so使用Courgette(指令差分)</li><li>binary使用BSDiff</li></ul></li><li>v2签名<ul><li>插件包可以不需要签名</li><li>自研的更新服务器可重新签名<ul><li>可以拿到签名   <ul><li>先解包重新排列再签名</li><li>与重排列的完整包进行差分</li><li>合并插件</li></ul></li><li>拿不到签名<ul><li>拿到原始包压缩级别， entrylist</li><li>合成新的包, 可以做到复制签名信息等同等MD5值</li><li>google/archive-patcher</li></ul></li></ul></li></ul></li><li>工程管理<ul><li>Maven版本管理, 但有缓存不好用</li><li>所有都在一个project中, 耦合性大</li><li>Git Submodule, 依赖git, 手动管理更新代码</li><li>Gradle CompositeBuild<ul><li>setting.gradle里面直接<code>includeBuild=path-to-other-project</code></li><li>也有一些插件简化该操作</li></ul></li></ul></li></ul></li></ul></li><li>如何开展优化<ul><li>目标必须明确, 从定性到定量</li><li>定位关键问题, 找出最大的点, 梳理优先级</li><li>二八定律<ul><li>前期20%时间解决80%问题</li><li>后期则相反</li></ul></li><li>业内对比, 造轮子成本高</li><li>优化需要监控</li><li>算法策略优化<ul><li>对比现有方案, 论文或者经验交流</li><li>不同角度问题分析, 选择痛点</li><li>算法能否动态下发</li><li>监控报表与收益</li></ul></li><li>工程技术优化<ul><li>现有方案对比 <ul><li>系统方案, 开源方案, 基于开源自研方案</li></ul></li><li>基于开源自研优化<ul><li>针对特定Case进行处理, 如估算+再次判断</li><li>与产品探讨是否接受妥协, 使用估算代替精确</li></ul></li><li>开源协议License<ul><li>GPL 使用了就必须开源</li><li>LGPL 不用开源</li></ul></li></ul></li></ul></li><li>系统设计<ul><li>需求分析与系统设计</li><li>需求-&gt;流程-&gt;细节</li><li>细节<ul><li>IO密集还是CPU密集</li><li>线程如何调度, 需要多少线程</li><li>使用RxJava还是Koroutine</li><li>网络接入<ul><li>长连接, 高频交互, 维护复杂<ul><li>心跳保活, 要求高6-9s, 一般30-40s</li></ul></li><li>短连接, 低频交互, 查询为主<ul><li>短轮询, 固定时间抓取</li><li>长轮询, 60秒时间如果有就返回, 没有就超时让客户端重新抓</li></ul></li></ul></li><li>加密算法<ul><li>对称加密 </li><li>非对称加密, 耗时太长, 对数据长度有限制(RSA)</li><li>一般用对称加密, 用非对称加密将对称加密秘钥加密</li></ul></li><li>热修复与插件化<ul><li>是否需要立即生效</li><li>是否修改或者新增类</li><li>是否有未来做平台的打算</li></ul></li><li>脚本化<ul><li>存在很多模式化逻辑, 游戏关卡, 自定义UI体系等</li><li>经常调整的策略</li></ul></li><li>可以执行<ul><li>是否存在复杂平台不想管逻辑, 抽象为so库</li></ul></li><li>性能问题<ul><li>算法时间空间复杂度</li><li>内存峰值OOM</li><li>CPU占用与耗电量</li></ul></li><li>监控<ul><li>异常捕获Java+Native</li><li>性能监控</li><li>优化指标监控</li><li>运营数据监控</li></ul></li></ul></li></ul></li><li>短视频APP<ul><li>网络</li><li>相机<ul><li>新API都是异步, 状态难维护</li></ul></li><li>滤镜<ul><li>下发Shader Script给OpenGL渲染</li></ul></li><li>播放器<ul><li>H265 文件小, 硬件支持差, 解码慢, 适合热点小规模</li><li>H264 文件大一些, 硬件支持好, 解码快, 适合大规模</li><li>自带播放器一般收到一组GOP才能播放, FFmpeg收到关键帧就可以</li></ul></li><li>封装模式调整<ul><li>Mpeg4 (File Type Box, Movie Box, Media Data Box)</li><li>将一般的顺序由ftyp-mdat-moov改为ftyp-moov-mdat, 边下边播</li></ul></li></ul></li><li>网络请求框架<ul><li>依赖简单, 接口简单, 功能纯粹</li><li>协议 Http, WebSocket</li><li>基础组件<ul><li>连接管理</li><li>线程管理</li></ul></li><li>拦截器, 日志系统也是类似</li><li>重试机制, 渐进式重试, 最大重试次数与衰减因子</li><li>使用注解配置请求, 类似于retrofit与spring</li><li>支持第三方扩展, 支持rx, suspend</li><li>DNS增强, HttpDnsServer, 提速防止被劫持</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      Android 知识点
    
    </summary>
    
      <category term="Android Note" scheme="http://talentprince.github.io/categories/Android-Note/"/>
    
    
      <category term="Android" scheme="http://talentprince.github.io/tags/Android/"/>
    
      <category term="Note" scheme="http://talentprince.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>Refresh Refactor</title>
    <link href="http://talentprince.github.io/2020/09/01/Refresh-Refactor/"/>
    <id>http://talentprince.github.io/2020/09/01/Refresh-Refactor/</id>
    <published>2020-09-01T08:39:21.000Z</published>
    <updated>2020-09-08T04:28:43.337Z</updated>
    
    <content type="html"><![CDATA[<p>最近在闲暇之余重(第)温(一..次)此书, 首先能感受到的, 无论你是新程序员还是老程序员, 这本书都<strong>已经</strong>不具备太多的可读性了.</p><p>由于本书成书年代久远, 那个时候软件行业还不够发达, 面向对象还没有被大数人理解, 加之编译器也非常落后, 设计模式也不深入人心, 所以文中提供的所谓重构的心法, 在当时或许有一些意义. 而今看来, 整书400多页的文字, 主要的思想就是「抽」, 无论是类, 接口, 方法, 逻辑, 还是参数. 但是为什么会有这么大的篇幅, 其中一半的内容是教你如何在一个IDE功能匮乏的年代, 以一个出错率更低的顺序, 来进行上面所说的多种抽象操作.</p><p>当然我去除了大量书中已经没有任何价值的点后, 总结了如下的一些内容, 应该大多数大家已经在工作实践中已有体会, 主要还是总结一下, 温故知新吧.</p><a id="more"></a><ul><li>思想方面<ul><li>如果发现加特性很难, 就需要重构</li><li>重构前需要想想有没有可靠的测试机制</li><li>重构要微小步伐, 容易发现错误</li><li>Extract method是最简单的重构</li><li>写出机器认识的代码容易, 写出人类容易理解的才是应该的, 最大的影响就是命名</li><li>做移动重构时, 最好先复制粘贴, 测后再删除旧的代码</li><li>对于另外对象的switch往往可以通过继承, 多态来取代</li><li>三次遇到不合理的, 可能就是重构的时候了</li><li>重构往往通过加隔离层进行</li><li>不要过早发布接口</li><li>性能优化应该基于良好的代码结构, 性能瓶颈往往只会在很小的代码片段里</li><li>每次遇到一个bug, 尽量写个单元测试覆盖</li><li>测试集中覆盖边缘case  </li></ul></li><li>代码坏味道与手段<ul><li>重复代码<ul><li>抽方法</li></ul></li><li>大函数<ul><li>抽方法, 抽类</li></ul></li><li>大类<ul><li>抽类, 抽子类</li></ul></li><li>太多参数<ul><li>参数变方法, 抽参数对象</li></ul></li><li>加新功能修改多个函数<ul><li>抽子类</li></ul></li><li>加新功能需要改很多类<ul><li>挪方法, 挪成员</li></ul></li><li>函数过度依赖其他类<ul><li>挪方法, 抽方法</li></ul></li><li>同样的几个参数到处出现<ul><li>抽参数对象</li></ul></li><li>大量同样的基本类型做参数<ul><li>抽类, 不同表达式可抽进子类</li></ul></li><li>很多switch<ul><li>考虑用多态取代</li></ul></li><li>子类需平行同时添加<ul><li>先持有对方, 再挪方法, 再挪变量, 再合并</li></ul></li><li>没人用的类<ul><li>做内部类</li></ul></li><li>没太大用处的抽象, 参数, 命名<ul><li>删除, 重命名, 内联</li></ul></li><li>临时变量命名模糊<ul><li>抽方法, 抽类</li></ul></li><li>消息链过长, 对象转换过多<ul><li>对同一对象的使用抽方法, 推入消息链消除对象</li></ul></li><li>过度代理<ul><li>内联代理</li></ul></li><li>注释太多<ul><li>可能代码写的太难懂, 需要重构</li></ul></li></ul></li><li>数据<ul><li>临时变量被赋值多次, 则可以抽成方法</li><li>有时候需要提取多个临时变量对逻辑进行解释, 当然更好的可以再抽成方法</li><li>Java按值传递, 本质上是对象的引用按值传递</li><li>移除中间人与隐藏委托是相辅相成的</li><li>如果类无法更改, 就写个函数包装他, 类似于工厂方法?</li><li>如果不能修改, Adapter模式常常用于扩展方法功能</li><li>子类修改某些变量的获取可以通过自封装, 把变量抽象成函数</li><li>成员如果不用改变, 就由引用变为值对象, 即immutable对象</li><li>当业务复杂度变高需要将类之间单向关系改为双向绑定关系, 甚至一对多与多对一的关系</li><li>双向绑定可能会造成很多僵尸对象, 增加复杂度与空间占用, 所以只有真正需要的时候用, 删除可以通过将内部绑定查询转移为传参, 再在调用的位置进行判断是否为僵尸对象</li><li>不要使用Magic Number, 常量即可以优化储存, 又可读性高</li><li>封装字段可以控制字段的读写, 称之为数据隐藏</li><li>对于返回集合的函数需要返回只读副本, 如果需要修改, 则可另行提供修改方法</li><li>原始类型替换成类, 有类型字段的类转换为多个子类, 或者抽象成策略模式, 从而合理改变数据结构</li><li>如果子类只有常量, 可以抽成变量放父类, 再添加工厂方法创建, 降低复杂度</li></ul></li><li>条件表达式<ul><li>条件表达式很复杂的时候, 可以将条件, 执行代码进行封装, 更表意</li><li>嵌套很深的条件表达式的每个结果都作为返回值的话, 可以简化为多个if+return, 类似于swift里面的guard, 或者kotlin里面的?:return, 书里叫卫语句(Guard Clauses)</li><li>嵌套很深的条件表达式可以将范围大的if反向, 实现提前return</li><li>switch表达式有时候可以通过多态来取代</li></ul></li><li>函数调用<ul><li>函数最好读写分离</li><li>抽象重复性的函数用以复用</li><li>switch构造可以替换成工厂方法</li><li>从对象内拿出参数再传递给某函数不如直接将对象传入函数</li><li>当函数的参数来自另外一个函数时, 也可以删掉参数, 把函数调用挪进去</li><li>函数参数过多可以同对象替代</li><li>如果不需要设置就不要提供set方法, 变量都需要为final</li><li>有时候用抛异常替代返回错误码, 如果程序无法继续进行的话</li><li>如果可以条件逻辑避免Runtime异常, 应不要无脑try/catch</li></ul></li><li>继承关系<ul><li>子类同样的方法应该向上提, 并将不同的地方抽象为抽象方法分别继承</li><li>子类构造复制父类字段应该通过父类构造, super</li><li>超类与子类差不多, 就合并</li><li>逻辑相同, 类型不同可以通过模板函数, 模板类解决</li><li>不能滥用继承, 组合代理好过继承, 但也有特殊, 如果需要使用委托函数所有函数或者大量, 则就需要继承, 不过这一点在kotlin里面也可以通过by来代理</li></ul></li><li>复杂的重构<ul><li>整理复杂的继承关系, 该抽接口抽接口, 摘出更多深层子类</li><li>领域与表述分离, 就是UI与逻辑分离</li><li>过程抽象为对象</li><li>提炼继承体系</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      Refactor 重构 Martin Fowler 马丁福勒
    
    </summary>
    
      <category term="Refactor" scheme="http://talentprince.github.io/categories/Refactor/"/>
    
    
      <category term="Note" scheme="http://talentprince.github.io/tags/Note/"/>
    
      <category term="Refactor" scheme="http://talentprince.github.io/tags/Refactor/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化总结</title>
    <link href="http://talentprince.github.io/2020/07/30/Android-Performance-Enhance/"/>
    <id>http://talentprince.github.io/2020/07/30/Android-Performance-Enhance/</id>
    <published>2020-07-30T10:28:53.000Z</published>
    <updated>2020-09-08T04:29:51.760Z</updated>
    
    <content type="html"><![CDATA[<p>最近断断续续的看完了Android性能优化相关的一个系列视频, 感觉总结的非常不错, 很多地方都有深受启发.<br>期间也穿插着停下来研究了一些相关的技术,框架,与工具, 并做了一些小笔记, 现将整个体系总结下来, 以便翻阅与温习.</p><a id="more"></a><ul><li>性能优化工具<ul><li>TraceView<ul><li>图形化界面</li><li>track所有线程, 消耗大</li><li>Debug.start/stopMethodTracing开启与停止生成文件</li><li>AS的CPU Profile Trace Method就是这个</li><li>系统函数黄色, 第三方蓝色, 自己绿色</li><li>四个图表来查看<ul><li>Call Chart<ul><li>顺序的函数调用关系与时间, 由上到下</li></ul></li><li>Flame Chart<ul><li>函数调用时间汇总, 有下到上</li></ul></li><li>Top Down<ul><li>由根函数开始做树状图</li></ul></li><li>Bottom Down<ul><li>由叶子函数开始做树状图</li></ul></li></ul></li><li>时间<ul><li>Wall Clock Time<ul><li>表示真实运行时间, 包括Sleep, CPU切换</li></ul></li><li>Thread Time<ul><li>线程占用CPU的时间, 小于真实运行时间</li></ul></li><li>Self Time<ul><li>函数除第三方调用耗时以外的时间消耗</li></ul></li><li>Children Time<ul><li>函数第三方调用消耗</li></ul></li></ul></li></ul></li><li>Systrace<ul><li>主要检测CPU各个内核使用情况</li><li>消耗小, 只拿埋的点数据</li><li>python脚本, 通过Trace/TraceCompat打tag</li><li>CPU time才是优化的方向, 如果耗时过长, 可以通过多线程处理</li><li>灰色:睡眠, 蓝色:可以运行, 绿色:正在运行, 红色:内核睡眠, 橙色:IO睡眠</li><li>w:放大, s:缩小, a:左移, d:右移, f:放大, m:选中</li><li>查看frame中F的间隔, 大于16ms可能就有卡顿, 再通过traceview或者CPU Profile来进行追踪</li><li>4.3(18)以上加入了Java的Trace, 6.0(23)加入了Native Tracce, 低版本Native可以通过JNI来获取</li></ul></li><li>CPU Profiler<ul><li>3.0以上AS使用Profiler取代了Monitor</li><li>CPU时间轴最上面有事件时间轴, 7.1(25)及一下版本必须在Config里面勾选Advanced profiling, 重新编译, 注入监控逻辑才能有, 附带的还有一些内存的监控</li><li>Trace Method<ul><li>给方法调用前后记录时间戳, 有运行开销</li></ul></li><li>Sample Java Method<ul><li>通过不断的捕获堆栈</li></ul></li><li>System Trace<ul><li>使用systrace获取更加详细的</li><li>必须在7.0 (24)以上的机器才具备</li><li>在代码中添加检测代码进行标记<ul><li>C使用trace.h原生跟踪</li><li>Java使用Trace</li></ul></li><li>9.0 (28)以上手机里也可开启systrace </li></ul></li><li>Sample C++ Function<ul><li>8.0 (26)以上</li><li>使用simpleperf进行采样</li><li>如果想指定参数, 命令行使用simpleperf</li></ul></li></ul></li></ul></li><li>启动速度优化<ul><li>时间测量<ul><li>AOP AspectJ<ul><li>Join Points <ul><li>切入点<ul><li>函数调用,执行</li><li>get/set</li><li>init</li></ul></li></ul></li><li>Cut Point<ul><li>带条件的切入点</li></ul></li><li>Advice<ul><li>Hook, 插入位置<ul><li>Before</li><li>After</li><li>Around</li></ul></li></ul></li><li>语法<ul><li>@Aspect</li><li>@Before(“excution (* android.app.Activity.on**(..))”) public xx(JointPoint joinPoint) {}</li><li>@Around(“call(* package.**(..))”) public xx(ProceedingJoinPoint joinPoint) {}</li></ul></li></ul></li><li>通过AMS<ul><li>adb logcat -s ActivityManager | grep “Displayed”</li></ul></li></ul></li><li>启动器多线程<ul><li>Task</li><li>有向无环图</li></ul></li><li>延迟初始化<ul><li>View显示第一帧启动初始化任务<ul><li>ViewTreeObserver.addOnDrawListener</li></ul></li><li>IdleHandler<ul><li>Looper.queue.addIdleHandler</li><li>return true handler被移除, return false handler继续停留</li><li>结合第一帧, 封装一个Dispatcher, 将初始化任务加入, 注册IdleHandler</li></ul></li></ul></li><li>提前异步读取SharePreference<ul><li>在Multi dex install之前</li></ul></li><li>启动阶段不启动子进程</li><li>提前异步类加载<ul><li>在Multi dex install之前</li></ul></li></ul></li><li>内存优化<ul><li>常用工具<ul><li>离线<ul><li>Memory Profile</li><li>Memory Analyser</li><li>LeakCanary</li></ul></li></ul></li><li>Java内存分配<ul><li>方法区<ul><li>静态变量</li><li>方法信息</li><li>所有线程共享</li></ul></li><li>虚拟机栈</li><li>本地方法栈(native)</li><li>堆</li><li>程序计数器<ul><li>函数执行多多少行</li></ul></li></ul></li><li>Java内存回收<ul><li>标记清除法<ul><li>先标记再统一回收</li><li>效率低, 内存不连续</li></ul></li><li>复制算法<ul><li>划分多个块</li><li>一块用完后复制存活到另一块</li><li>再清除另一块</li><li>效率高, 但浪费</li></ul></li><li>标记整理<ul><li>存活对象向一端移动</li><li>清理其他内存</li><li>不浪费, 也没碎片</li></ul></li><li>分代收集<ul><li>新生代存活低, 复制</li><li>老年代存活高, 标记整理</li></ul></li></ul></li><li>Android内存管理<ul><li>内存弹性分配, 根据设备</li><li>OOM, 内存不足或者可用不足</li><li>Dalvik<ul><li>固定回收算法</li></ul></li><li>Art<ul><li>运行期选择<ul><li>前台<ul><li>标记清除</li></ul></li><li>后台<ul><li>标记整理</li></ul></li></ul></li></ul></li><li>Low Memory Killer<ul><li>进程分类<ul><li>根据优先级Kill</li><li>前台,可见,服务,后台,空进程</li></ul></li><li>回收收益<ul><li>根据需要回收的量级</li></ul></li></ul></li></ul></li><li>内存抖动与OOM<ul><li>原因 <ul><li>频繁创建对象, 会造成内存碎片与不足</li><li>内存碎片化会导致无法分配出来可用内存导致OOM</li></ul></li><li>Memory Profiler分析<ul><li>锯齿状</li><li>Record查看内存活动情况<ul><li>Allocate 分类instance个数</li><li>Shallow 自身占用内存大小</li><li>Retained 持有对象总大小</li></ul></li><li>追踪可疑内存allocate位置</li></ul></li><li>CPU Profile分析<ul><li>查看频繁调用方法的地方<ul><li>内存泄露</li></ul></li></ul></li><li>定义<ul><li>内存中存在没有用的对象 </li></ul></li><li>表象<ul><li>内存抖动 (因为GC), 可用内存逐渐减少</li></ul></li><li>危害<ul><li>GC频繁, 卡顿, 甚至OOM</li></ul></li><li>用Memory Profiler检测内存是否泄漏, 并dump java内存堆栈</li><li>用Memory Analyzer(MAT)分析<ul><li>需要进行转换 hprof-conv</li></ul></li></ul></li><li>Memory Analyzer<ul><li>Overview<ul><li>饼图</li><li>Top Consumer<ul><li>可查看Biggest Object</li></ul></li><li>Leak Suspect<ul><li>自动化分析泄露引用树</li></ul></li></ul></li><li>Histogram<ul><li>以类来列表</li><li>右键Group by package 以包名摆放</li><li>检查Objects, 存在个数</li><li>可疑对象右键可选List Object -&gt; with incoming ref</li></ul></li><li>dominator tree<ul><li>以对象列表</li><li>Percentage<ul><li>查看占比大的</li><li>同样通过List Object -&gt; with incoming ref</li></ul></li></ul></li><li>OQL<ul><li>对象数据库</li><li>可使用select * FROM className</li></ul></li><li>thread overview<ul><li>查看各个线程</li></ul></li><li>Unreachable Objects Histogram<ul><li>已经可回收的对象</li></ul></li></ul></li><li>Bitmap内存模型<ul><li>Api10之前, 像素存在Native, 对象存在Dalvik<ul><li>native回收时机不够</li></ul></li><li>Api10之后全部放Dalvik</li><li>Api26更改机制, 全部放Native, Bitmap回收后通知Native层</li><li>计算大小<ul><li>getByteCount</li><li>h <em> w </em> density, res要考虑压缩比例</li></ul></li><li>ARTHook<ul><li>Epic<ul><li>Hook Java方法</li><li>4.0 - 9.0</li><li>继承XC_MethodHook</li><li>DexposedBridge.hookXX用于注册</li><li>DexposedBridge.findXX用于查找</li></ul></li><li>无侵入性</li><li>基于Dexposed来hook</li><li>Hook了ArtMethod指向的函数指令, 指向自己的片段</li><li>兼容性问题大, 开源不能带入线上环境</li></ul></li></ul></li><li>线上内存问题解决一般方案<ul><li>检测内存使用达到一定程度, 使用Debug.dumpHprofData()</li><li>文件太大, 不易上传, 虽然可裁剪</li></ul></li><li>完整方案<ul><li>监控待机内存, 重点模块内存, OOM率<ul><li>ActivityManager#getProcessMemoryInfo</li><li>Debug.MemoryInfo#getMemoryStat</li><li>读取</li></ul></li><li>整机或者重点模块GC次数, GC时间<ul><li>Debug.startAllocCounting</li><li>Debug.getGlobalAllocCount() &lt; 6.0</li><li>Debug.getRuntimeStat(“art.gc.gc-xxx”) &gt; 6.0</li></ul></li><li>增强型LeakCanary<ul><li>ResourceCanary</li><li>自己找怀疑点</li><li>只分析Retain size大的</li><li>对象裁剪, 不全加入内存</li></ul></li><li>开LargeHeap</li><li>onTrimMemory/onLowMemory, 自我释放</li><li>使用SparseArray</li><li>谨慎使用SharedPreference</li></ul></li></ul></li><li>布局优化<ul><li>16ms发送VSync触发渲染</li><li>手机刷新频率一般是60Hz</li><li>Systrace查看帧率<ul><li>Frames</li><li>会给出一些Alert</li></ul></li><li>LayoutInspector查看布局层次</li><li>Choreographer<ul><li>API 16以上</li><li>可以获取FPS</li><li>Choreographer.getInstance().postFrameCallback</li></ul></li><li>原生布局加载优化<ul><li>读取资源使用IO<ul><li>?X2C?Async?</li></ul></li><li>创建View使用反射<ul><li>LayoutInflater.Factory/2<ul><li>创建一个Hook</li><li>全局替换自定义View的创建</li><li>LayoutInflaterCompat.setFactory2</li></ul></li></ul></li><li>AsyncLayoutInflater<ul><li>内部没有用Compat, 不能用Factory</li><li>View不能有创建Handler或者使用myLooper, 因为没调用prepare</li><li>不支持Fragment, 这个通过privateFactory构建的</li><li>父布局的generateLayoutParams必须线程安全</li><li>默认queue的size只有10</li></ul></li></ul></li><li>获取界面打开耗时<ul><li>Hook setContentView <ul><li>AspectJ<ul><li>excution setContentView</li></ul></li><li>ARTHook<ul><li>DexposedBridge.findAndHookMethod</li></ul></li></ul></li></ul></li><li>获取每一个控件耗时<ul><li>LayoutInflater.Factory/2</li></ul></li><li>X2C<ul><li>XML通过Apt转换为Java</li><li>@Xml让Java知道XML</li><li>X2C.setContentView</li><li>有的xml属性Java不支持</li><li>如果想要使用Compat的View做兼容, 需要自己修改X2C</li></ul></li><li>视图绘制优化<ul><li>减少层级</li><li>宽而浅, 避免前而深<ul><li>由上到下元素尽量在一个Group内</li><li>由左到右, 布局深度更浅</li></ul></li><li>不嵌套RelativeLayout</li><li>不在嵌套的LinearLayout里使用weight</li><li>多使用merge</li><li>避免过度绘制<ul><li>去掉多余背景色</li><li>减少复杂shape使用</li><li>不免空间重叠</li><li>自定义View使用clipReact屏蔽遮盖view绘制</li></ul></li><li>使用ViewStud延迟</li><li>onDraw不要创建大对象</li></ul></li><li>所使用的工具<ul><li>Choreographer -&gt; 帧率 线上</li><li>AOP, ArtHook -&gt; 统计耗时 线上</li><li>Systrace -&gt; 每一帧的耗时 线下</li><li>Layout Inspector -&gt; 布局层级 线下</li></ul></li></ul></li><li>App卡顿优化<ul><li>代码, 内存, 绘制, IO …</li><li>工具<ul><li>CPU Profiler<ul><li>Debug.startMethodTracing</li><li>Debug.stopMethodTracing</li><li>开销大</li></ul></li><li>Systrace<ul><li>API 18</li><li>TraceCompat</li><li>systrace.py -t 10 [options] [categories]</li><li>轻量级, 开销小</li><li>CPU利用率可视, 帧卡顿给出建议</li></ul></li><li>StrictMode<ul><li>运行时检测</li><li>线程策略<ul><li>自定义耗时调用<ul><li>detectCustomSlowCalls()</li></ul></li><li>磁盘读写<ul><li>detectDiskReads</li></ul></li><li>网络请求<ul><li>detectNetwork</li></ul></li></ul></li><li>虚拟机策略<ul><li>Activity泄露<ul><li>detectActivityLeaks</li></ul></li><li>Sqlite泄露<ul><li>detectLeakedSqlLiteObjects</li></ul></li><li>实例数检测<ul><li>setClassInstanceLimit</li></ul></li></ul></li></ul></li></ul></li><li>线上自动化监测<ul><li>原理<ul><li>Looper在dispathMessage的时候前后都会调用mLogging, 可用于监控耗时</li><li>通过seetMessageLogging</li></ul></li><li>AndroidPerformanceMonitor<ul><li>基于之上的原理, 时间超了就说明卡了</li><li>BlockCanary</li><li>非浸入</li><li>不足与优化<ul><li>只有T2时刻的堆栈, 可能不能表现卡顿原因</li><li>优化方案就是高频多次采集</li><li>对多次卡顿堆栈进行去重, 减少数据量</li></ul></li></ul></li></ul></li><li>ANR<ul><li>ActivityManagerService里定义了<ul><li>KeyDispatchTimeout 5s</li><li>BroadcastTimeout 前台10s, 后台60s</li><li>ServiceTimeout 前台20s, 后台200s</li></ul></li><li>ANR弹出会多余5s, 因为要写入堆栈信息</li><li>导入/data/anr/traces.txt分析</li><li>线上ANR监控<ul><li>低版本通过FileObserver监控文件变化</li><li>ANR-Wartchdog<ul><li>自有线程向UIhandler发消息</li><li>然后Sleep等待计数器增加</li><li>如果醒来发现没有增加, 说明ANR了, 就抛异常, 并且打印主线程堆栈信息</li><li>可以复写Listener, 自己处理异常</li></ul></li></ul></li></ul></li><li>单点卡顿监控:<ul><li>AspectJ与ArtHook<ul><li>AspectJ只能往自己或者lib里方法, 不支持系统方法</li><li>ArtHook则可以在系统方法调用的时候进行hook</li></ul></li><li>IPC问题监控<ul><li>关注点<ul><li>IPC调用类型, package manager等</li><li>次数, 耗时</li><li>堆栈, 发生的线程</li></ul></li><li>adb监控<ul><li>adb shell am trace-ipc start</li><li>adb shell am trace-ipc stop –dump-file xxx.txt</li></ul></li><li>Hook IPC数据传输<ul><li>BinderProxy#transact</li></ul></li></ul></li><li>IO, DB, View绘制</li></ul></li><li>界面秒开<ul><li>轻量级AOP框架, Lancet<ul><li>编译速度快, 增量编译</li><li>API简单, 没有多余的代码插入Apk中, 只有自己hook的</li><li>API<ul><li>@Proxy 对系统API进行Hook, 传入方法名</li><li>@TargetClass 指定Hook所在的<ul><li>scope<ul><li>SELF </li><li>DIRECT SELF+直接子类</li><li>ALL SELF+所有子类</li><li>LEAF 叶子节点</li></ul></li></ul></li><li>@Insert 操作App或者lib的类<ul><li>mayCreateSuper<ul><li>true 如果方法不存在, 就创建</li></ul></li></ul></li><li>Origin.call() 调用原有方法</li></ul></li><li>检测onWindowFocusChange - onCreate就是页面打开时间</li><li>监控生命周期函数耗时, 以及生命周期函数之间转换的耗时</li></ul></li><li>思路<ul><li>Systracce分析</li><li>异步+延迟初始化</li><li>异步Inflate, X2C, 绘制优化</li><li>提前获取数据</li></ul></li></ul></li><li>监控盲区<ul><li>只知道耗时了, 不知道具体做了什么</li><li>线上也不好操作</li><li>线下检测<ul><li>TraceView可以查看每一个线程都做了什么</li><li>还可以监控系统调用</li><li>GC可以通过log或者通过systrace的HeapTaskDaemon线程查看</li></ul></li><li>线上检测<ul><li>使用定制化的Handler监控sendMessage跟dispatchMessage</li><li>sendMessage保存msg记录时间, 调用栈, dispatchMessage拿出msg, 检测耗时, 上报调用栈</li><li>使用gradle插件编译期替换bytecode</li><li>didi的DroidAssist方便替换</li></ul></li></ul></li><li>卡顿优化不同阶段<ul><li>线下通过系统工具定位, 通过异步或者延时解决</li><li>线上自动化卡顿方案, 通过消息机制捕获上报, 包括ANR上报<ul><li>改进方案, 高频采集, 分析重复堆栈  </li></ul></li><li>线下监控与线上监控工具建设<ul><li>线下关注提前暴露, 线上关注自动化, 全面性, 灵敏度</li><li>对于达不到阈值的小卡顿, 线下AOP对一些耗时代码hook, 如IPC, IO等, 分析数据</li><li>线下Hook Handler的两个方法, 统计时间与堆栈信息</li><li>线上还监控秒开时间, 生命周期之间耗时</li></ul></li></ul></li></ul></li><li>线程调度<ul><li>普通CPU调度采用公平分配</li><li>Jvm线程调度根据优先级分配时间片</li><li>Android调度是抢占式<ul><li>nice<ul><li>在Process中定义</li><li>越小优先级越高</li><li>默认是0</li></ul></li><li>cgroup<ul><li>根据群组调用, 防止很多后台压制前台</li><li>优先级低的线程会进后台group</li><li>不在前台运行的程序的线程也会进去</li></ul></li></ul></li><li>线程太多会导致CPU频繁切换, 降低效率</li><li>工作量与优先级应该成反比</li><li>线程有继承性, 在UI线程创建的子线程就会抢占UI线程的时间片</li><li>线程执行的过程中, 也可以改名字与优先级</li><li>为了让子库做到线程收敛, 可提供一个setExecutor的方法统一设置</li><li>分类设置线程池<ul><li>如果IO密集型, 不消耗CPU, 线程池可以设置的很大</li><li>CPU密集型的线程大小要与核心数相关</li></ul></li></ul></li><li>网络优化<ul><li>维度<ul><li>流量消耗<ul><li>一段时间的消耗, 不同网络类型, 前台后台</li><li>流量消耗均值, 异常率, 流量消耗多, 次数多, 文件大等</li><li>所有网络请求Request/Response本地监控</li></ul></li><li>质量监控<ul><li>请求时长, 成功率, 失败率, Top失败接口</li></ul></li><li>其他消耗<ul><li>成本, 带宽, CDN</li><li>耗电</li></ul></li></ul></li><li>工具<ul><li>NetworkProfiler<ul><li>监控发送接收, 连接数</li><li>手动需要开启高级分析 (API小于26)</li><li>只支持URLConnection与OkHttp</li></ul></li><li>抓包工具<ul><li>Charles (mac)</li><li>Fiddler (windows)</li><li>WireShark (底层抓包)</li><li>Stetho (chrome)</li></ul></li></ul></li><li>获取流量消耗<ul><li>本地测试<ul><li>流量管理关闭其他app</li><li>抓包工具只允许本App联网</li></ul></li><li>线上获取<ul><li>TrafficStats API8(2.2)之后 重启之后的流量数据<ul><li>getUidRxBytes</li><li>getTotalTxBytes</li></ul></li><li>NetworkStatsManager API23(6.0)之后<ul><li>querySummary 返回bucket, 判断uid过滤本app数据</li><li>bucket getRxBytes getTxBytes</li></ul></li></ul></li><li>前台与后台<ul><li>定时+统计+前后台标记</li><li>每隔30s进行统计一次</li></ul></li></ul></li><li>网络优化<ul><li>添加配置使用http缓存<ul><li>NonetworkIntercepter, 无网环境打开Force Cache</li></ul></li><li>增量更新</li><li>数据gzip压缩</li><li>etag</li><li>图片压缩后上传<ul><li>Luban</li></ul></li><li>合并网络请求<ul><li>批量上传, 如上报数据</li></ul></li></ul></li><li>图片相关<ul><li>先试用缩略图</li><li>使用webp</li></ul></li><li>质量相关<ul><li>成功率与速度</li><li>dns优化<ul><li>使用HttpDns绕过运营, 不使用dns53端口而使用80</li><li>阿里云 httpdns.aar</li><li>通过实现Dns接口设置给okhttp</li></ul></li><li>http版本<ul><li>1.0 tcp不复用</li><li>1.1 长连接, 复用, tcp上的http是按顺序</li><li>2.0 tcp上的http同时发送多个请求, 类似于spdy</li></ul></li><li>监控<ul><li>请求耗时, 成功率, 错误码<ul><li>添加okhttp EventListener, 监控每个环节</li><li>通过EventListenerFactory加入okhttp </li></ul></li><li>图片加载每一步耗时<ul><li>Fresco 设置RequestListener      </li></ul></li></ul></li><li>其他<ul><li>容灾, 如果多次连接不上, 就不要请求了</li><li>cdn加速, 更新则需要清缓存</li><li>减少传输量, 时机, 频率</li><li>Okhttp请求池<ul><li>Dispatcher</li><li>okhttp限制了同域名最多请求个数为5, 如果单域名, 可以增加</li></ul></li></ul></li></ul></li><li>体系化<ul><li>线下测试<ul><li>只开本App</li><li>请求有误, 多余, 切网, 弱网, 无网</li></ul></li><li>线上监控<ul><li>服务端<ul><li>请求耗时, 地域, 时间段, 版本, 机型</li><li>失败率, 包括业务失败与请求失败</li><li>统计Top失败接口</li></ul></li><li>客户端<ul><li>接口每一步信息, 包括DNS解析, 连接建立, 请求包大小等</li><li>请求次数, 包大小, 失败原因</li><li>图片监控</li></ul></li></ul></li><li>异常监控<ul><li>服务器防刷</li><li>大文件预警 </li><li>异常兜底, 一定时间错误次数太多, 就不能访问, 或重试次数增加</li><li>单点问题查看日志分析</li></ul></li></ul></li></ul></li><li>电量优化<ul><li>统计电量消耗<ul><li>系统电量排行</li><li>通过注册Action_Battery_Changed广播</li><li>Battery Histrian 5.0+ 线下使用</li></ul></li><li>测试<ul><li>复杂运算, 视频</li><li>传感器相关, 耗电, 发热, 使用时长等</li><li>后台静默</li></ul></li><li>Battery Histrian<ul><li>基于dumpsys, 试用前先重置电量, 再开启电量统计, 再通过adb导出<ul><li>adb shell dumpsys batterystats –reset</li><li>adb shell dumpsys batterystats –enable full-wake-history</li><li>adb bugreport bugreport.zip</li></ul></li><li>可以通过docker安装histrain, 或者上<a href="http://bathist.ef.lc" target="_blank" rel="noopener">http://bathist.ef.lc</a></li></ul></li><li>运行时能耗<ul><li>能耗设定<ul><li>adb pull /system/framework/framework-res.apk</li><li>反编译找到power_profile拿到能耗</li><li>能耗是厂家设置的, 可以帮助分析哪些比较耗电</li></ul></li><li>AOP统计耗电组件调用时间, 次数<ul><li>使用Lacent @Insert @TargetClass</li><li>对于WakeLock, Thread.run</li></ul></li></ul></li><li>总结<ul><li>降低CPU时间片占用, 通过traceview, cpuprofiler, 降低后台工作</li><li>网络请求合并, 数据压缩</li><li>不要轮询进行操作业务</li><li>定位使用低精度, 网络定位, 使用完立即关闭</li><li>耗电操作后台关闭, 如动画</li><li>WakeLock及时释放, 设置超时时间, 释放最好写到finally中</li><li>如需要保持长亮, 可使用KeepScreenOn</li><li>使用JobScheduler/WorkManager, 设置运行场景</li></ul></li></ul></li><li>APK瘦身<ul><li>头部App都出Lite版, 提升转化率</li><li>Apk组成<ul><li>classes.dex 代码</li><li>资源 res, asserts, resource.arsc</li><li>so相关 lib</li></ul></li><li>分析工具<ul><li>apktool 反编译</li><li>analyze apk studio自带</li><li>nimbledroid.com 分析网站<ul><li>文件大小排行</li><li>dex, sdk方法数</li><li>启动时间, 内存占用</li></ul></li><li>classyshark github开源<ul><li>支持apk, jar, class, so</li></ul></li></ul></li><li>代码优化<ul><li>混淆</li><li>第三方库统一, 选小库<ul><li>android methods count插件</li><li>可以引入第三方库的部分模块, 或者修改源码剥离</li></ul></li><li>移除无用代码<ul><li>通过AOP统计activity是否还在被用</li><li>通过AOP看看类的构造还有没有被调用<ul><li>@After(excution(xxx.new(..)))</li></ul></li></ul></li></ul></li><li>资源优化<ul><li>无用资源<ul><li>右键refactor-&gt;remove unused resources</li><li>或者通过Analyze里面run inspect by name, 搜unused</li></ul></li><li>图片压缩<ul><li>tinypng.com及tinypngplugin</li><li>jpeg比png小很多</li></ul></li><li>资源混淆<ul><li>AndResGuard github项目</li><li>gradle引入插件, 添加配置</li><li>通过gradle task resguardRelease</li><li>会将resource.resc中的名字变短</li></ul></li><li>其他<ul><li>图片保留一份 如xdpi</li><li>资源放远端</li></ul></li></ul></li><li>so瘦身<ul><li>加解密, 音视频一般都是用so</li><li>在lib设置abifilters设置支持架构, 一般留armeabi, 兼容其他, 但是不会优化</li><li>可以把对性能要求高的so单独加入到armeabi中, 通过代码逻辑进行加载</li><li>so动态下载</li><li>插件化<ul><li>atalas</li><li>replugin</li></ul></li><li>CI监控大小变化</li></ul></li></ul></li><li>稳定性优化<ul><li>维度<ul><li>Crash</li><li>性能</li><li>业务高可用</li></ul></li><li>重要的是在于预防</li><li>Crash率<ul><li>UV评估影响范围, PV评估影响程度</li><li>启动Crash, 启动10秒后crash</li><li>优先解决新增crash (增量与存量)</li><li>99.8%是底线 万分之更优秀</li></ul></li><li>业务高可用<ul><li>主流程核心路径监控<ul><li>AOP采集, 统一上传</li><li>阈值报警, 趋势报警, 特定指标报警</li></ul></li><li>异常监控<ul><li>catch的代码块</li><li>异常逻辑, 一些逻辑返回false, 一些参数为空, 进行上报</li></ul></li><li>兜底<ul><li>关闭功能</li><li>跳转分发中心, 不要进入有错误的页面</li></ul></li></ul></li><li>容灾<ul><li>功能开关, remote toggle</li><li>统跳中心, 重定向到临时界面或其他</li><li>热修复<ul><li>tinker (把修复的dex里的elements放在host的pathlist中elements之前)</li><li>andfix (method hook, dalvik修改函数指向, art hook entrypoint)</li><li>robust (跟instant-run一样插装在diapatch)</li><li>如果rn之类的, 可以直接升级</li></ul></li><li>安全模式<ul><li>多次启动失败, 就重置app</li><li>太严重则需要阻塞热修</li><li>服务器多次失败, 网络库可以拒绝继续发送请求, 保护服务器</li></ul></li></ul></li><li>长效治理<ul><li>开发阶段<ul><li>增强编码功底, codereview等</li><li>架构优化, 能力收敛, 如界面切换用路由, 统一容错, 统一网络库, 统一网络错误处理</li><li>容错测试, 如服务器宕机, 脏数据, 特殊机型等边界</li><li>云测平台</li></ul></li><li>合代码<ul><li>编译检测, 静态扫描</li><li>合入跟主干一样的分支, 预编译, 防止代码冲突</li><li>主流程回归测试, 自动化执行</li></ul></li><li>发布环节<ul><li>多轮灰度, 筛选忠实用户</li><li>针对低于, 版本定向灰度</li><li>灵敏监控, 热修, 容灾等UI</li></ul></li></ul></li></ul></li><li>列表页卡顿<ul><li>图片不要太大</li><li>滑动过程中停止图片加载</li><li>列表页用线程池, 并设置为background, 不抢占UI</li><li>TextView优化<ul><li>BoringLayout 单行, StaticLayout 多行, DynamicLayout 可编辑</li><li>异步创建StaticLayout</li><li>可以使用facebook的TextLayoutBuilder优化</li></ul></li><li>使用StringBuilder拼接而不是直接+<ul><li>常量直接拼接性能最高, jvm直接拼好</li><li>变量拼接使用StringBuilder更好, 虽然直接拼接也会转换builder, 但还会多一些临时变量</li><li>循环内不要使用拼接, 因为会每次循环都创建出一个StringBuidler</li></ul></li></ul></li><li>储存优化<ul><li>SP优化<ul><li>系统SP问题<ul><li>初始化慢, 虽然异步, 但UI线程需要等</li><li>写入慢, 全量写入</li><li>卡顿, apply会与丢失的可能, 而且SP在一些时候, 如onPause进行写入磁盘</li></ul></li><li>使用腾讯MMKV取代<ul><li>mmap+文件锁</li><li>增量写入, 使用protobuffer</li><li>支持sp迁移</li></ul></li></ul></li><li>日志优化<ul><li>mmap 内存映射文件</li><li>使用微信的Xlog或者美团的Logan</li></ul></li><li>其他<ul><li>常用数据缓存</li><li>文件流缓存4-8K</li></ul></li></ul></li><li>Webview异常监控<ul><li>webview优化<ul><li>容器预热, 资源预加载</li><li>参考VasSonic</li></ul></li><li>检测白屏<ul><li>通过getBitmapFromView</li><li>用每一个像素点对比第一个</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近断断续续的看完了Android性能优化相关的一个系列视频, 感觉总结的非常不错, 很多地方都有深受启发.&lt;br&gt;期间也穿插着停下来研究了一些相关的技术,框架,与工具, 并做了一些小笔记, 现将整个体系总结下来, 以便翻阅与温习.&lt;/p&gt;
    
    </summary>
    
      <category term="Android Note" scheme="http://talentprince.github.io/categories/Android-Note/"/>
    
    
      <category term="Android" scheme="http://talentprince.github.io/tags/Android/"/>
    
      <category term="Note" scheme="http://talentprince.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>Refresh Java</title>
    <link href="http://talentprince.github.io/2020/06/02/Refresh-Java/"/>
    <id>http://talentprince.github.io/2020/06/02/Refresh-Java/</id>
    <published>2020-06-02T09:54:52.000Z</published>
    <updated>2020-09-08T04:28:35.760Z</updated>
    
    <content type="html"><![CDATA[<p>当你的知识来源于实践, 你可能会忽略很多细节.<br>当你的知识来源于阅读, 你可能会很快的忘掉.</p><p>那么, 不如在空闲之余, 浏览一遍, 把觉得有必要的记录下来, 也便于以后温故而知新, 何乐而不为呢?<br>于是便有了这138条从Thinking In Java中记下来的条目.<br>这本书不同于其他的Java教材, 它的作者更喜欢通过与C++进行对比来阐述Java的不同思想, 如果读者有一定C++知识储备, 会更好的理解Java的很多设计.</p><a id="more"></a><ul><li><code>&gt;&gt;&gt;</code>无符号移位</li><li><code>for(1 : range(10))</code>可实现计数器循环foreach</li><li><code>printnb</code>不会换行放在缓冲区, <code>print()</code>将其输出</li><li>带标签的<code>break</code>与<code>continue</code>可以跳出嵌套循环</li><li>构造调用<code>this(xxx)</code>只能调用一次,并且在最开始</li><li>Java的<code>finalize</code>是在垃圾回收时候调用的, 一般是配合释放ndk相关的底层空间</li><li>静态对象只有在所属类被实创建时才会被加载</li><li>构造方法其实也是静态方法</li><li><code>int[] a</code>与<code>int a[]</code>都可以,  前一种更合理, 后一种像C++</li><li>数组初始化花括号最后一个逗号可选, 即<code>{x,y,z,}</code></li><li>没有写<code>package</code>的类默认属于目录所在包</li><li>即时类不是<code>public</code>, 但是<code>main</code>方法依旧可以被调用</li><li>子类调用父类方法, 父类再调用<code>public</code>方法则可能会调用到子类所继承的方法(如果覆盖的话), 如果该方法在父类是<code>private</code>, 则只会调用父类方法, 因为不能覆盖, C++如果不是虚函数, 则只会调用父类的, 因为<code>this</code>内函数地址编译时就确定了</li><li><code>Java</code>函数没有隐藏/屏蔽特性, <code>C++</code>子类会同名函数会隐藏/屏蔽掉父类所有同名重载函数, 因为它会先查找函数名, 再找具体类型.</li><li>早起<code>JVM</code>会根据<code>final</code>类型来内联函数, 现在已经有更先进的技术了, 只为了禁止覆盖.</li><li>覆盖<code>private final</code>其实是假象而已</li><li>面向对象特性, 抽象, 继承, 多态</li><li><code>Java</code>除了<code>static</code>与<code>final</code>外函数都是后期绑定的, 即动态绑定</li><li><code>Java</code>构建子类时父类构造函数调用已被覆盖的函数会触发动态绑定, 但此时子类未完成构造, 所以类内对象都为空值. <code>C++</code>在处理同样问题时更加合理, 由于虚表指针未完整建立, 所以不会触发动态绑定, 无论是构造还是析构函数, 都是直接调用而非虚调用, 为了避免问题, 尽量不要在构造函数内调用可被覆盖的函数, 可以调用<code>final</code>函数来防止出错</li><li>Java5加入被覆盖方法返回参数协变(向下转型)</li><li>interface中定义的所有常量都是自动static fianl的</li><li>类内部定义的private接口可以进行内部public的实现, 但在外部无法看出任何有关私有接口的类型信息, 即不可向上转型</li><li>嵌套在接口内的接口自动public</li><li>private接口不能在定义它的类之外被实现</li><li>内部类持有的外部类对象学术名叫Enclosing Object(外围对象)</li><li>创建非静态内部类必须通过<code>.new</code>来创建, 即使用外部对象来创建内部对象</li><li>private内部类可以帮助隐藏具体实现, 外部类可以提供其实例的向上转型</li><li>内部类还可以放在方法里缩小scope, 作用于与局部变量一样</li><li>匿名内部类没有命名构造器, 只有实例初始化传参, 或者通过final形参直接在内部使用</li><li>static内部类叫作嵌套类, 它不持有外围对象</li><li>接口内部可以放嵌套类, 可以这么搞个测试在里面</li><li>内部类更重要的作用是有效的实现了<code>多重继承</code>, 比如需要继承多个抽象类而不是接口</li><li>Java使用内部类实例做回调来实现闭包功能</li><li>Java通过接口+内部类可以结果C++多重继承所能解决的问题</li><li>List/Set/Queue都继承Collection, Map独立有接口, 两者唯一的关系是Map提供一个返回Collection的entrySet与values</li><li>Queue虽然继承于Collection, 但Queue有自己独立的接口, 创建Queue不需要Collection的方法</li><li>LinkedList也继承于Dequeue</li><li>当我们在异常处理的终止与恢复中选择时, 开始往往是恢复, 最后趋向终止</li><li>对自定义异常的扩展可能没太大用, 因为更多的时候只关注异常类型</li><li>重新抛异常会保留之前的信息, 不会新加入抛出点的信息, 除非调用fillInStackTrace()</li><li>重新抛出新的异常则会清楚之前的信息</li><li>Finally用来清理，C++靠的是析构函数</li><li>即便有break，continue，return，finally始终都会被执行</li><li>Finally中return会吃掉try内的异常</li><li>Finally中抛异常会吃掉try内的异常</li><li>基类构造抛出异常不用在子类限制必须抛出， 因为基类构造必须调用， 并且需要处理</li><li>子类方法不能抛出基类未声明过的异常，这样直接调用基类接口不用处理，实际运行可能会出错</li><li>子类方法可以抛出基类声明异常的子类异常</li><li>对于构造需要清理的对象，如文件，应该将构造失败单独try/catch，而close方法放在内部的try/catch只对创建成功后进行清理</li><li>字符串正则表达式查找find匹配任意位置，lookingAt只从开头匹配， matches匹配全部</li><li>正则Pattern可以用<code>|</code>与操作进行组合</li><li>Java默认类型转换会RTTI，但是C++不会</li><li>setAccessable只是控制是否安全检测，public默认仍是false，关闭后速度快</li><li>泛型会被擦除， ArrayList<integer>跟ArrayList<string>一样，通过getTypeParameters()也只能得到占位符</string></integer></li><li>C++泛型不会擦除， 所以编译的时候仍然可以获得具体使用类型，所以定义时泛型对象就可以调用实际类型的方法，Java得通过泛型extends来实现</li><li>擦除主要是为了兼容低版本</li><li>C++可以直接new T()而Java只能通过泛型当参数newInstance，对于没有默认构造的Java可以传入泛型工场进行构造</li><li>泛型可以通过extends来限制边界, 并且可以通过<code>&amp;</code>增加多个边界, 类应该放在接口的前面</li><li><code>Clazz&lt;Apple&gt;</code>只能向上转型为<code>Clazz&lt;? extends Fruit&gt;</code>, 而不能<code>Clazz&lt;Fruit&gt;</code>, <code>Clazz&lt;Food&gt;</code>可以向下转型为<code>Clazz&lt;? super Fruit&gt;</code></li><li><code>&lt;? extends X&gt;</code>指定上界, 无法进行add操作, 因为它是由子类List向上转型来的, 子类多种多样不确定, 所以不让你放, 而get返回<code>X</code>, <code>&lt;? super X&gt;</code>指定下届, 是由父类List向下转型来的, 可以add <code>X</code>的子类, 内部可安全强转为同一个父类(X的某个父类), 但get就不清楚是哪个父类, 所以只能拿到<code>Object</code></li><li>类不能实现泛型接口的两种变体</li><li>自限定泛型继承, <code>class SelfBounded&lt;T extends SelfBounded&lt;T&gt;&gt;</code>, 任何继承SelfBounded类的泛型类型必须也是SelfBounded的导出类</li><li>继承自限定类可保证接口函数导入类唯一, 参数为限定类泛型指定</li><li>C++可以通过<code>template&lt;class T&gt; : T</code>来进行混型, 有一些AOP方面的思想</li><li>Java可以通过继承多个接口, 并分别初始化的时候进行实现, 然后再代理进行混型</li><li>Java也可以通过装饰器进行混型的概念, 但是由于装饰器其实只有最后一层是暴露的, 失去了内部各层的特性, 而混型是基于继承, 保留所有特性</li><li>Java还可以通过动态代理, 将所有需要混型的实现与接口导入, 在invoke的时候查表得到对应的Delegate来调用方法, 实现混型, 但是不方便, 也不易懂, 不如C++静态的好</li><li>对于一些脚本语言, 类型检测是在运行期, 所以可以使用潜在类型机制, 进行代码复用, 如Python, 只需要方法名一样, 或者称为鸭子类型机制, 只要走起来像鸭子, 叫起来像鸭子, 就当做鸭子…</li><li>由于C++的泛型在编译器可以检测T支持的方法, 可以直接对泛型类型调用相应函数,  也可以做到类似Python的效果. 表面上看C++的泛型成了弱类型, 但实际上是安全的, 称之为具有通气门的强类型</li><li>Java的泛型出现的晚, 已经不具备这种潜在类型机制了, 可以认为比他们更缺乏泛化性</li><li>Java虽然不能潜在类型, 但可以通过泛型, 一定程度补偿了这样的灵活性</li><li>虽然Java的Map有泛型, 但是<code>containsKey</code>, <code>get</code>之类的方法不受泛型约束, 而C++的Map是会在编译器检查类型的. 主要原因是泛型对于Java是后来引入的, 而对于C++在最初的标准版本里就引入了</li><li><code>Arrays.deepToString()</code>可以给数组填充初始默认值</li><li><code>Arrays.fill()</code>可以给数组填充指定值</li><li>无法创建泛型数组, 但是类型可以被赋值</li><li><code>Array.newInstance</code>用反射的Array可以生成任意类型, 指定大小的数组</li><li><code>System.arraycopy</code>可以实现高效的数组内存拷贝</li><li>自己实现Collection不一定需要支持所有的操作, 虽然平时用的List, Map, Set都实现了</li><li><code>Arrays.asList()</code>生成的是固定大小数组, 不支持改变大小的操作, 使用会抛异常</li><li><code>LinkedList</code>实现了<code>Queue</code>接口, 但是Java没有<code>Dequeue</code>接口, 不过它已经实现了所需方法<code>getLast</code>, 所以可以自己包装 </li><li><code>TreeMap</code>是唯一带<code>subMap</code>的Map, 返回一个子树, 它是<code>SortedMap</code>的唯一实现</li><li><code>LinkedHashMap</code>的散列是一个LRU, 没有被使用的数据放在前面</li><li>通过<code>Collection.synchronized</code>可以创建不同的线程同步子类</li><li><code>SoftReference</code>跟<code>WeakReference</code>都可以单独使用, 而<code>PhantomReference</code>必须跟<code>ReferenceQueue</code>一起使用</li><li>普通对象被gc后会进入<code>Finalizable</code>状态, finalize未被调用,  仍就可以有机会复生 (复写finalize), 当finalize调用后,  会进入<code>Finalized</code>状态, 下次GC会被回收</li><li><code>PhantomReference</code>天生就是finalized状态, GC发生后就清掉了</li><li><code>Stack</code>,<code>Vector</code>都是1.0/1.1版本的东西, 为了兼容性而保留了</li><li>1.4之后引入了<code>nio</code>相较于之前的被称之为新IO</li><li>1.1加入的Reader跟Writer是为了国际化兼容16位Unicode字符</li><li><code>BufferedInputFile.read</code>可以读取文件到Reader里, 在进行其他的包装, 如<code>StringReader</code>, <code>BufferedReader</code>, 没有快捷方式.</li><li>写入文本可以使用<code>PrinterWriter</code>简化, 直接<code>writer.println</code></li><li><code>System.out/in/err</code>被称为标准IO, 通过<code>setOut/In/Err</code>可以进行重定向</li><li><code>javap</code>随jdk一起发布做反编译</li><li>旧IO底层已经用nio重构过了</li><li>旧的<code>FileInputStream</code>, <code>FileOutputStream</code>等被修改支持生成一个<code>Channel</code>, Writer跟Reader不支持, 但是Channel有方法可以生成他们</li><li>Channel通过<code>ByteBuffer</code>进行读写, 写之前需要<code>flip</code>准备缓冲区, 读之前需要<code>rewind</code>回到数据头,  再通过<code>asCharBuffer</code>转换后打印</li><li><code>ByteBuffer.flip</code>是将position设置为0, 将limit设置为当前位置, 准备写;  <code>ByteBuffer.rewind</code>是将position设置为0, 并将marker清除, 准备读; <code>mark</code>会设置mark, <code>reset</code>会把position指向mark</li><li>通过ByteBuffer的<code>asCharBuffer</code>或者别的方法, 可以获得所谓缓冲器视图, 对缓冲器进行对应类型的<code>put</code>, 该缓冲器可通过其他as方法切换至其他的窗口进行输出</li><li>如果直接向缓冲器内写入Bytes, 那么无法通过<code>asCharBuffer</code>读出, 必须写入<code>UTF-16BE</code>才对应格式, 按Char读出不会乱码</li><li>通过<code>RandomAccesFile.map</code>可以产生<code>MappedByteBuffer</code>进行内存磁盘映射, 必须指定一个映射范围, 它的效率要比建立在nio之上的旧IO要快</li><li>Object序列化的文件, 必须能在找到类定义的环境下才能被反序列化成功, 否则会ClassNotFoundException</li><li>通过Serializable序列化, 内部有大量反射, 直接将二进制赋值,  不需要通过构造. 如果复写read/writeObject, 或者实现<code>Externalizable</code>接口, 自己实现序列化, 则需要有public默认构造, 没有反射, 效率高</li><li>静态成员变量不能自己序列化</li><li>枚举在编译的时候编译器会给加入<code>values</code>跟单参的<code>valueOf</code>静态方法</li><li>所以枚举向上转型Enum就没有values方法了, 但可以通过Class中<code>getEnumConstant</code>方法反射</li><li>构建枚举的枚举可以通过将枚举Class当构造参数传入枚举对象, 并且通过<code>geEnumConstant</code>覆盖其values</li><li><code>EnumSet.allOf</code>可以传入一个枚举类class, <code>of</code>则是手动传入N个枚举类型</li><li>枚举可以添加自定义方法, 每一个实例独自实现,  但是枚举实例不能像普通类一样作函数参数, 因为每一个实例其实是enum类型本身</li><li>注解不能继承, 注解的字段要么定义默认值, 要么使用时传入, 不能为空</li><li>线程设置为Deamon模式, 主线程结束后就被杀掉了</li><li>Thread可以设置<code>setDefaultUncaughtExceptionHandler</code>, 不设置就会被default处理</li><li>测试资源竞争可以调用<code>Thread.yield</code>增加几率</li><li>Java也提供手动的<code>Lock</code>, return要写在try里确保在finally的unlock之前调用</li><li>如果想实现尝试获取, 不行放弃的话, 需要自己封装<code>ReentrantLock</code>, 使用<code>tryLock</code></li><li>多核处理器上可视性比原子性问题多得多, volatile会解决可视性问题</li><li>volatile如果已经被synchronized防护, 则不需要加; 如果只在一个任务中用, 也不用加; 如果依赖前值, 或者某个域的值, 那也无法工作</li><li>在C++中自加可能是原子性的, 但是Java中肯定不是</li><li><code>synchronized</code>最合理的是锁被调用对象this, 或者加方法上, 这样如果一个线程获得了锁, 其他synchronized的方法也都不能被别的线程调用了</li><li>IO与Synchronized的阻塞无法被打断, 关闭资源才可以释放锁, 并打断线程, 锁阻塞续采用<code>Lock.lockInterruptibly</code>才可以被打断</li><li>线程被中断一般需要有清理逻辑, 通过try/catch/fanilly来做</li><li><code>sleep()</code>, <code>yield()</code>不会释放锁, <code>wait()</code>期间对象锁会释放, 被notify后, 醒之前必须重新获得锁</li><li><code>wait</code>一般跟while循环配合, 因为在即将被唤起之前(调用notify的前后), 可能条件已经发生了改变</li><li>为了防止错过信号, 通常也需要通过while(cindition)来保护wait, 防止死锁</li><li>因为wait会释放锁, 而notify在synchronized区间内, 会在之前获取锁, 而wait被唤醒又会重新获取锁,  所以实际上使用notifyAll也只能唤起在等待的一个任务, 同样, 使用notify的时候, 应使等待条件一致, 如果条件不一致, 则只能使用notifyAll</li><li>可以synchronized锁Object以及wait/notify做同步, 也可以通过<code>ReentrantLock</code>生成condition, 通过await/signal/lock/unlock来操控</li><li>有时候使用一些同步对象也可以简化逻辑, 如<code>BlockingQueue</code></li><li>简单的线程同步也ke已用1.5引入的<code>CountDownLatch</code>做</li><li>相较于CountDown只能计数一边, <code>CyclicBarrier</code>可以重复利用, 第一个参数传入parties个数, 当await数量达到时会停止等待, 并且调用第二个参数Runnable执行, 可以再次触发await, 这样可以形成一个循环, 或者闭环</li><li>除了<code>BlockingQueue</code>之外, 还有其他类似的同步队列, 但需要实现一定的接口, 如<code>DelayBlockingQueue</code>, <code>PriorityBlockingQueue</code></li><li><code>SynchronousQueue</code>的put必须等待take</li><li>常用的Excutor有<code>CachedThreadPool</code>, <code>ScheduledThreadPool</code>, <code>FixedThreadPool</code>等</li><li><code>Semaphore</code>作为信号量, 可以设置次数, 多次acquire, 并通过release来释放信号, 区别于<code>ReentrantLock</code></li><li><code>Exchanger</code>可以作为一个类似管道的东西, 同时传递生产到消费</li><li>一般使用synchronized, 可读性强, 调优用Lock, 简单情况用Atomic, 有性能指标可以替换</li><li><code>CopyOnWriteArrayList</code>内部使用整个数组的副本进行操作, 最终原子替换, 性能高一些, <code>ConcurrentHashMap</code>与<code>ConcurrentLinkededQueue</code>类似, 只不过是部分复制再操作. 这两者读取过程都有乐观锁处理, 所以性能要比synchronized List/Map好, 尤其是在很少写入的情况</li><li>AtomicXXX有一些乐观加锁的函数, 如compareAndSet, 当提供的oldValue发生变化时, set失败</li><li>读写锁(ReentrantReadWriteLock)保证了读取数据的一致性, 当写锁被持有的时候, 读锁将不能获取, 其他时候可多次获取读锁</li><li>更多的时候多线程的问题要通过Task+消息队列, 但这个依赖于平台或者额外复杂的设计</li></ul>]]></content>
    
    <summary type="html">
    
      Thinking in Java
    
    </summary>
    
      <category term="Java" scheme="http://talentprince.github.io/categories/Java/"/>
    
    
      <category term="Note" scheme="http://talentprince.github.io/tags/Note/"/>
    
      <category term="Java" scheme="http://talentprince.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Refresh design pattern</title>
    <link href="http://talentprince.github.io/2019/09/30/Refresh-design-pattern/"/>
    <id>http://talentprince.github.io/2019/09/30/Refresh-design-pattern/</id>
    <published>2019-09-30T08:06:52.000Z</published>
    <updated>2020-09-08T04:28:35.768Z</updated>
    
    <content type="html"><![CDATA[<p>多年后, 再次翻阅设计模式书籍, 将每种模式的要点总结于此, 需要本身有一定设计模式基础, 再结合要点, 帮助更好理解与运用.</p><a id="more"></a><ul><li><p>策略模式 (Strategy)</p><ul><li>附加功能单独抽象不同接口</li><li>功能以组合方式引入抽象类</li><li>抽象类封装功能模块各调用</li><li>实现类可在构造中配置功能具体实现</li></ul></li><li><p>观察者模式 (Observer)</p><ul><li>被订阅者持有所有订阅者</li><li>数据更新可以直接推送</li><li>数据更新也可以通知加拉取</li><li>大程度解耦观察者与被订阅者</li></ul></li><li><p>装饰器模式 (Decorator)</p><ul><li>装饰器接口的简单实现叫做组件</li><li>持有组件对象的叫做装饰器</li><li>装饰是从里层的装饰器开始</li><li>最里层的装饰器会持有原始组件</li><li>各层通过对持有的底层对象进行包装完成所谓装饰并返回给上层</li><li>理论上可以做到一层套一层无穷尽</li></ul></li><li><p>工场方法模式 (Factory Method)</p><ul><li>解耦产品的实现与使用</li><li>产品需要进行抽象</li><li>工场方法定义创建产品的接口</li><li>工场方法内还可以封装使用过程</li><li>子工场配置自己的创建逻辑</li><li>工场方法常常与抽象工场结合</li><li>抽象工场定义了一组产品的创建</li><li>工厂方法的实现又用这些产品创建或组件具体的大产品</li><li>工厂方法通过继承来实现</li><li>抽象工场通过组合来实现(传入)</li></ul></li><li><p>单例模式 (Singleton)</p><ul><li>全局实例注意内存</li><li>多线程需要特殊照顾</li></ul></li><li><p>命令模式 (Command)</p><ul><li>解耦发请求者与执行请求者</li><li>命令内部可以直接执行也可以代理给被封装在内的接收者</li><li>命令支持撤销</li><li>宏命令包含多个命令同时调用</li></ul></li><li><p>适配器模式 (Adapter)</p><ul><li>对象适配器以组合来实现</li><li>类适配器以多继承来实现</li><li>新旧系统共用可双向适配</li></ul></li><li><p>外观模式 (Facade)</p><ul><li>从抽象层次看与适配器很像</li><li>外观模式创建新的简单接口</li><li>适配器模式使用已存在接口</li><li>新接口包装多个系统模块简化调用</li><li>老接口包装其他系统达到兼容</li></ul></li><li><p>模板方法模式 (Template Method)</p><ul><li>模板实现算法, 子类实现步骤</li><li>子类与父类尽量不能成环</li><li>好莱坞模式为子类全为回调方法</li><li>有默认实现的为钩子方法</li><li>策略用组合封装算法,模板用继承封装算法</li><li>工厂方法是特殊的模板方法</li></ul></li><li><p>迭代器模式 (Iterator)</p><ul><li>解耦游走数组而不要关心具体类型</li><li>集合类都有自己的迭代器</li><li>一般的迭代器具备hasNext与next两个方法</li><li>聚合器持有数据并创建迭代器</li></ul></li><li><p>组合模式 (Composite)</p><ul><li>组合模式的节点分为子节点与叶节点</li><li>子与叶都实现了同样的组合接口,所谓透明性</li><li>子节点会额外实现add与get</li><li>为了叶节点安全也可以具有不同接口</li><li>组合模式可以与迭代器共生</li><li>迭代器需要配合栈来实现树的遍历</li><li>子节点可以实现空迭代器来减少Null判断</li></ul></li><li><p>状态模式 (State)</p><ul><li>与策略模式类图相似</li><li>状态接口定义状态切换行为</li><li>所有状态实现统一接口</li><li>状态机定义并持有所有状态</li><li>状态机储存当前状态</li><li>状态切换由不同状态自己控制</li><li>状态内通过持有的状态机来切换下一状态</li></ul></li><li><p>代理模式 (Proxy)</p><ul><li>可分为远程代理与虚拟代理</li><li>与装饰者很像</li><li>代理更多的是控制真实对象的访问, 解耦客户与真实对象, 也可能帮助创建真实对象</li><li>装饰器更多是增加行为, 而且不创建对象</li><li>可通过工厂方法返回主体的代理</li><li>与适配器很像</li><li>代理不改变接口, 适配器改变接口</li><li>保护代理可以限制访问部分接口,更像适配器</li></ul></li><li><p>复合模式 (Compound)</p><ul><li>多用几种</li><li>比如MVC就融合了策略,组合,适配器等</li></ul></li></ul><hr><ul><li><p>一些冷门模式</p></li><li><p>桥接模式 (Bridge)</p><ul><li>与策略模式很像</li><li>主体都依赖于功能组件的抽象</li><li>策略模式的主体是具体算法的实现</li><li>桥接模式的主更抽象,需要子类来实现不同算法</li><li>可以做到主体和功能组件解耦</li><li>增加了复杂度</li></ul></li><li><p>生成器 (Builder)</p><ul><li>封装复杂对象的创建过程</li><li>隐藏内部实现</li><li>创建时需要对所创对象有更多认识</li></ul></li><li><p>责任链 (Resposibility)</p><ul><li>简单理解为一个Handler的对象链</li><li>比如很多程序里常用的Dispatcher链</li><li>或者很多系统启动时需要加载的数据链</li><li>不能保证一定会有对象对数据进行处理</li></ul></li><li><p>享元 (Flyweight)</p><ul><li>多个同样的实例可被一个方法控制, 就可以封装在一起轮询数组进行处理</li><li>但是不能有独立不同行为了</li></ul></li><li><p>解释器 (Intepretor)</p><ul><li>主要是做简单固定语法解析</li><li>抽象解释接口, 并实现多个解释器</li><li>如And, Or之类的, 可相互嵌套.</li><li>如果语法复杂, 种类繁多, 会不太适合</li></ul></li><li><p>中介者 (Mediator)</p><ul><li>解耦不同对象</li><li>它们只需要通知中介者, 中介者根据不同状态来控制整个逻辑</li><li>可能会让中介者逻辑过于复杂</li></ul></li><li><p>备忘录 (Momento)</p><ul><li>将对象的储存抽出来, 更好的维护了业务的内聚</li><li>一般会提供储存与获取接口</li><li>储存过程可能会耗时</li><li>可能需要考虑序列化</li></ul></li><li><p>原型 (Prototype)</p><ul><li>提供复制对象的方法</li><li>比如clone</li><li>如果对象层次深,复制起来可能复杂</li></ul></li><li><p>访问者 (Visitor)</p><ul><li>解耦对象与每个对象的具体操作, 如对电脑的不同部件进行不同操作</li><li>在对象种类变化小而操作变化大的时候使用</li><li>每一个对象实现visitor接口, 接受(accept)一个visitor,并把自己传给visitor (visit)</li><li>缺点是具体元素对访问者暴露, 而不是抽象接口</li></ul></li></ul><hr><p>有很多种分类方式, 不必拘泥, 也可忽略.</p><ul><li><p>分类方式 I</p><ul><li>创建型<ul><li>单例</li><li>抽象工厂</li><li>工厂方法</li><li>生成器</li><li>原型</li></ul></li><li>行为型<ul><li>模板方法</li><li>迭代器</li><li>状态</li><li>策略</li><li>观察者</li><li>命令</li><li>解释器</li><li>中介者</li><li>访问者</li><li>备忘录</li><li>责任链</li></ul></li><li>结构型<ul><li>装饰器</li><li>代理</li><li>外观</li><li>组合</li><li>适配器</li><li>桥接</li><li>享元</li></ul></li></ul></li><li><p>分类方式 II</p><ul><li>类<ul><li>模板方法</li><li>工厂方法</li><li>适配器</li><li>解释器</li></ul></li><li>对象<ul><li>单例</li><li>抽象工厂</li><li>装饰器</li><li>代理</li><li>外观</li><li>组合</li><li>适配器</li><li>迭代器</li><li>状态</li><li>策略</li><li>观察者</li><li>命令</li><li>桥接</li><li>享元</li><li>生成器</li><li>中介者</li><li>访问者</li><li>备忘录</li><li>责任链</li><li>原型 </li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      Design Pattern
    
    </summary>
    
      <category term="Design Pattern" scheme="http://talentprince.github.io/categories/Design-Pattern/"/>
    
    
      <category term="Note" scheme="http://talentprince.github.io/tags/Note/"/>
    
      <category term="Design Pattern" scheme="http://talentprince.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Chernobyl, 切尔诺贝利, 車諾比</title>
    <link href="http://talentprince.github.io/2019/07/09/Chernobyl/"/>
    <id>http://talentprince.github.io/2019/07/09/Chernobyl/</id>
    <published>2019-07-09T08:06:52.000Z</published>
    <updated>2020-06-22T09:44:59.476Z</updated>
    
    <content type="html"><![CDATA[<p>虽然八季的权游的草草收尾让HBO被骂了个惨, 但是后续推出的Mini剧<code>切尔诺贝利</code>却以9.6的高分一绝红尘, 让大家对于人类历史上最大的核灾难有了形象生动的认识. <code>谎言的代价</code>, 一开始的旁白便以此为切入, 展开了整部剧的画面.</p><p>趁着热度, 我并没有先看这部西方指导的剧集, 而是分别看了美国拍的纪录片<a href="https://movie.douban.com/subject/3057368/" target="_blank" rel="noopener">抢救車諾比</a>, 俄罗斯的奇幻片<a href="https://movie.douban.com/subject/26214079/" target="_blank" rel="noopener">切尔诺贝利 禁区</a>, 以及乌克兰的电视剧<a href="https://movie.douban.com/subject/25834316/" target="_blank" rel="noopener">飞蛾</a>, 这三部剧让我从三个不同角度, 或者说是阵营去感知那段历史, 充分满足了我的好奇心, 也填补了我的很多困惑, 以及帮助了我更好的去思考时代的变迁. (Warning!!!后面会有一些剧透)</p><a id="more"></a><p>也许有人疑惑为何会对切尔诺贝利感兴趣, 说来可能会比较牵强, 首先作为一个社会主义工人阶级的后代, 对苏联有着一段莫名其妙的亲切感, 而这场核灾难在某种意义上来说是苏联的掘墓人, 这话也不是我说的, 是苏联最后一个总书记戈尔巴乔夫后来讲的. 其次在我的童年所生活过的几个地方, 都是类似于普里皮亚季这样的因为有某个工厂或者机构而盛极一时的地方, 而后又因为各种原因突然衰败, 最终被废弃, 成为小朋友们探险的场所. 再次作为半个历史的爱好者, 感慨过汉唐之兴衰, 民国之兴衰, 有时也会仰望星空, 感知人类的渺小, 感叹谁主沉浮.</p><center> <img src="https://res.cloudinary.com/dtn0pkdmg/image/upload/c_scale,w_600/v1562660097/old_vhuod3.jpg" alt="old_photo"> </center><p>距离1986年4月26号凌晨已经过去33年, 当我试图去寻找这个当年的苏联模板城市的资料时, 绝大部分都只有图片的对比, 不过最终还是找到了一个名为<code>苏联最好城市普里皮亚季</code>的<a href="https://www.bilibili.com/video/av30022920" target="_blank" rel="noopener">简短的视频</a>, 透过这段视频, 依稀可以感受到这个人口五万的城市曾经的生机勃勃与辉煌.</p><center> <img src="https://res.cloudinary.com/dtn0pkdmg/image/upload/v1562660465/map_m9wltl.gif" alt="map"> </center><p>普里皮亚季, 是切尔诺贝利西北方因为核电站而修建的城市, 兴建于1970年, 距离当时苏维埃乌克兰首府基辅(Kiev)一百公里, 人口将近五万, 平均年龄只有26岁, 聚集了大量的苏联技术青年, 一号核反应堆于1977年启用, 爆炸的四号反应堆是83年启用的, 并且一共规划了6座核电站. 整个城市修建了一家医院、一个公园、一座火车站、三家诊所、三个文化中心、二十一所学校、三个室内游泳馆、十个体育馆、十个射击场、35个体育场、25家商场和店铺、27个小餐馆, 就连基辅这等大城市的富贵们也会驱车来普里皮亚季的商场买西方最新上市的Dior香水, 不过这些繁华的景象, 都没有在目前的影视剧, 纪录片中有过多的描述, 留给人们印象最深的还是灾难本身的恐惧, 以及现在普里皮亚季废墟与鬼城的形象.</p><p>为了了解俄罗斯对于切尔诺贝利的视角, 我首先看的是<a href="https://movie.douban.com/subject/26214079/" target="_blank" rel="noopener">切尔诺贝利 禁区</a>这部俄剧, 俄剧在国内非常冷门, 但是这部剧居然达到近乎9分, 并且好评如潮. 大致的剧情是一群俄罗斯青年被一个偷钱的怪人引诱到了切尔诺贝利的普里皮亚季, 后来他们无意中通过一个设备穿越到了爆炸发生之前, 第一季的最后他们改变了过去, 导致回来的时候苏联并没有解体而成为世界上最强大的国家. 还记得印象最深的是女一号无意中从废墟穿越回过去, 一片欣欣向荣的景象让我感觉到心潮澎湃, 好希望灾难从未发生. 再后来他们真的阻止了爆炸的发生, 苏联又回来了, 男主穿越回来的第一瞬间, 便看到普里皮亚季大街上熙熙攘攘带着红领巾的小朋友, 看到这里, 我竟然莫名其妙的有一些激动. 虽然第二季最后一切又回归现实, 站在我们面前的依旧是现在的俄罗斯联邦. 整部剧里除了穿越还有一些惊悚成分, 例如普里皮亚季的高辐射成为了被称作<code>禁区</code>的物质, 它具备一定的超能力, 可以制造幻想, 并且期望将来这里的人杀死. 我还很好奇的查了一下拍摄资料, 原来他们从未实景拍摄过, 因为辐射会危害健康, 不过透过演员的FB看到了一张他们在普里皮亚季大门的合照, 可能最新的情节去采景了? 非常期待今年10月份上映的大电影.</p><center> <img src="https://res.cloudinary.com/dtn0pkdmg/image/upload/c_scale,w_600/v1562660192/%E7%A6%81%E5%8C%BA_t8wr6a.jpg" alt="禁区"> </center><p>俄剧的制作虽然不如美剧华丽, 但俄国作为切尔诺贝利事件的主要参与者, 一些细节足矣窥伺出他们的态度. 比如在前往切尔诺贝利途中被警察恶意扣留, 必须得用金钱进行贿赂, 或许侧面反映了大家对于目前俄罗斯腐败的不满. 当大家阻止了爆炸的发生, 苏联重振熊威, 成为世界霸主, 连互联网都变成了俄联网, iPhone8都变成了俄Phone8, 足矣见得大家对苏联大国地位的怀念, 以及切尔诺贝利对苏联的巨大影响. 由于历史被改变, 86年的核爆炸转移到了美国, 美国又爆发了内战, 可以看出俄方对于美国的态度还是非常敌对的. 而后一行人又穿越回美国阻止了核爆, 一切又回到正轨, 也表明了俄罗斯人不愿意利用灾难转移来恢复大国地位… 或许这些都是我想多了, 不过他们脑洞之大令人佩服.</p><p>乌克兰, 作为苏联三巨头之一, 一直都是附庸的地位, 乌克兰脱离苏联后也一直都表现浓厚的反俄情绪, 但<a href="https://movie.douban.com/subject/25834316/" target="_blank" rel="noopener">飞蛾</a>改变了一些我对乌克兰人的认知, 这部剧以平民视角出发, 客观真实以及浪漫的记录了灾难给人们的影响. 剧情是以苏军上校的女儿艾丽娅与士兵巴沙的生死之恋为主线, 士兵巴沙作为上校的下属来给艾丽娅送信, 两人对上了眼. 可是没过多久核爆发生, 上校坚持亲自驾机查看爆炸情况, 飞机受到强大的电离辐射坠毁, 成为孤儿的艾丽娅精神崩溃, 士兵巴沙变成为她的唯一依托, 可惜巴沙作为清理者(Liquidator)在四号核电站楼顶受到了致命的辐射, 他不愿被送往莫斯科, 私自逃离营帐与艾丽娅在已经空城的普里皮亚季度过了人生最浪漫的一天. 巴沙最后死在了莫斯科第六医院, 而艾丽娅没有接受医院的劝说堕胎, 电视剧的最后是艾丽娅的女儿来到了普里皮亚季废墟参观旅游, 在已经锈迹斑斑的电话亭里找到了当时她父母为躲避清城人员时刻的字, “艾丽娅 &amp; 巴沙”. </p><center> <img src="https://res.cloudinary.com/dtn0pkdmg/image/upload/c_scale,h_480/v1562660274/%E9%A3%9E%E8%9B%BE_q8ogvx.jpg" alt="飞蛾"> </center><p>这部四级的电视剧以”飞蛾”为名, 寓意飞蛾扑火, 与第一集核爆当晚灯光下的成群飞蛾在不明真相的人群中死亡想呼应. 整部剧没有丝毫讽俄的成分, 涉及到几个核爆重点事件也都是结合剧情改编的合情合理. 比如上校执意驾驶飞机查看爆炸情况坠机牺牲, 而他刚刚从阿富汗战场回来, 已经接受到了上级命令可以休假回家看望女儿, 并且上级也极力劝阻. 可见这里对苏军的英勇还是非常认可, 凸显了在亲情面前, 国家更为重要. 类似的剧情还有艾丽娅的姐姐在去医院找对象的途中发现人手不够主动帮忙, 在已知有辐射的情况下没有退缩, 在受到二次辐射后被送往莫斯科, 最后不幸去世. 当然也有像艾丽娅姐姐的未婚夫得知有辐射便谎称有家中有事逃回基辅, 在被未婚妻的爷爷(苏军老兵)鄙视后, 又硬着头皮回到普里皮亚季, 他始终犹豫不决, 胆战心惊, 慌乱中还是克服障碍, 参与了撤离人员难产接生. 这些在现在看来都算是所谓的正能量, 可歌可泣的东西, 也反映了从国家到平民大家都是国难当头, 上下一心. 针对于普里皮亚季的描写, 大致也与我查到的资料相符, 这些都可以从艾丽娅与巴沙逃回空城看得到. 他们分别去了幼儿园, 姐姐家中, 以及衣服店与理发馆. 印象最深的就是姐姐家中的暖水瓶与我们小时候(90年代)家中的红色铁皮那款一模一样, 电视冰箱等家电一应俱全, 幼儿园里环境优雅设施齐全, 衣服店里琳琅满目, 理发馆里海报女郎发型时尚, 广场还有冷饮外卖摊, 饮料自助机等等. 然而这一切最终还是化为乌有, 只留下了锈迹斑斑的”艾丽娅 &amp; 巴沙”, 令人惋惜.</p><p>除去影视剧的表现, 可能纪录片更能真实详细的反应事情的经过, 事件发生后的第五年, 苏联解体, 目前唯一一部<a href="https://movie.douban.com/subject/3057368/" target="_blank" rel="noopener">称得上纪录片的还是美国拍摄的</a>, 片中收集了大量珍贵的影像资料, 采访视频, 值得一看. 片子最初是以欢快的普里皮亚季生活开始的, 茁壮成长的青少年, 干净整洁的城市规划, 街头推着婴儿车的年轻人. 片中采访了几乎所有利害相关的人, 比如当时苏联最高领导人戈尔巴乔夫, 俄方的摄像师(参与拍摄屋顶清理石墨), 挖掘隧道的煤炭工人, 直升机救援队军方负责人, 从普里皮亚季撤出的居民等等. 从高官到平民, 无一不表露出对灾难的遗憾以及对救援行动的肯定. </p><center> <img src="https://res.cloudinary.com/dtn0pkdmg/image/upload/c_scale,h_480/v1562660344/%E6%8A%A2%E6%95%91%E8%BD%A6%E8%AF%BA%E6%AF%94_z43euo.jpg" alt="抢救"> </center><p>印象比较深刻的是挖掘隧道的工人说他从不后悔, 因为总该有人要去做这件事, 不是他们也会是别人. 拍摄清理者的摄影师也以第一人称的视角描述了苏联军人如何蚂蚁搬家的将楼顶所有的石墨清理干净, 为石棺的修建打好基础, 强大的辐射在照片下方留下的印记永远被记录了下来. 戈尔巴乔夫称整个救援行动花了180亿卢布, 折合180亿美元, 我也去查了一下当时的数据, 81-85年整个苏联的赤字平均就180亿, 而86年到89年上升到了690亿, 随后石油大跌也对苏联的经济雪上加霜.</p><p><code>一个国家的消亡, 或许也是造就英雄被遗忘的重要原因</code>. 与日本福岛核事故的处理, 显然苏共中央的决策与行动力是非常值得肯定的. 4月26日凌晨核爆发生, 26日当天中央便派技术检测人员去现场测量数据, 26日晚确定必须撤离所有群众, 并连夜调集了一千多辆大巴准备进行疏散, 27日十一时开始疏散居民, 总共耗时三小时, 并且派遣军方直升机进行投放铅与硼砂来降低辐射, 将爆炸区周围的辐射从12000伦琴每小时降低到100伦琴. 28日开始疏散10km内的群众, 29日开始疏散30km内的群众, 5月2日划定隔离区并使用铁丝网围起来, 为了防止核燃料烧穿地板接触用于降温的废水而产生更大的爆炸, 在明确高辐射危险的同时, 三名来自三号反应堆的工作人员冒死进入打开消防泵, 抽干了废水 (他们竟然幸存了下来), 5月7号政府决定修建石棺以及人工降温层来防止剩余的依旧燃烧的核燃料可能造成的影响. 年轻的苏联士兵每人工作90秒, 轮班将屋顶残留的高辐射石墨清理出来, 为石棺修建扫清障碍. 5月12号开始动员了1000km外苏联最优秀的一批矿工来切尔诺贝利, 13号他们开始了工作, 仅仅一个月就完成了预计三个月的工作量. 当年12月石棺完工. 前后两年间动员了多大30万人进行清理工作. (说道动员, 想起了红警苏联的动员兵, 100块一个, 口号就是for the Union, for mother Russia, 后面一句有点反苏).</p><center> <img src="https://res.cloudinary.com/dtn0pkdmg/image/upload/c_scale,h_600/v1562662049/compare_xx7dzm.jpg" alt="compare"> </center><p>事故距今已过33年, 也许没有HBO的热播剧, 就不会有更多的人对切尔诺贝利有详尽的了解, 虽然西方价值观下的影片在一定程度上掩盖了民族英雄, 或者说共产主义下的人民英雄的形象, 但它依旧是第一个能震撼的将整个过程呈现在人们面前的影视剧. 在人们指责当局掩盖事实, 阻止人们民众知道真相的同时, 是否考虑过在那个消息不发达的年代, 在资本主义社会主力两大阵营激烈对抗当中, 维稳与防止敌国的渗透更为重要. 面对人类历史上最大的核灾难, 或许只有苏联这样国家才能在最短的时间内调动全国的人力物力, 将损失降到最低.</p><p>而最终历史还是胜利者书写, 牢不可摧的联盟, 红色的CCCP, 也只能停留在记忆当中. </p><center> <img src="https://res.cloudinary.com/dtn0pkdmg/image/upload/v1562660807/cccp_e2sjcd.jpg" alt="CCCP"> </center><p>忘记苏联没良心, 而恢复苏联也决然不再可能.</p>]]></content>
    
    <summary type="html">
    
      Chernobyl, 切尔诺贝利, 車諾比
    
    </summary>
    
      <category term="nonsense" scheme="http://talentprince.github.io/categories/nonsense/"/>
    
    
      <category term="nonsense" scheme="http://talentprince.github.io/tags/nonsense/"/>
    
  </entry>
  
  <entry>
    <title>探究高级的Kotlin Coroutines知识</title>
    <link href="http://talentprince.github.io/2019/02/12/Deep-explore-kotlin-coroutines/"/>
    <id>http://talentprince.github.io/2019/02/12/Deep-explore-kotlin-coroutines/</id>
    <published>2019-02-12T01:14:52.000Z</published>
    <updated>2020-06-22T09:44:59.477Z</updated>
    
    <content type="html"><![CDATA[<p>要说程序如何从简单走向复杂, 线程的引入必然功不可没, 当我们期望利用线程来提升程序效能的过程中, 处理线程的方式也发生了从原始时代向科技时代发生了一步一步的进化, 正如我们的Elisha大神所著文章<a href="https://medium.com/@elye.project/the-evolution-of-android-network-access-1e199fc6e9a2" target="_blank" rel="noopener">The Evolution of Android Network Access</a>中所讲到的, Future可能会是Kotlin Coroutines的时代.</p><a id="more"></a><h3 id="什么是Coroutines"><a href="#什么是Coroutines" class="headerlink" title="什么是Coroutines"></a>什么是Coroutines</h3><p>Coroutines是Kotlin 1.1推出的实验性的一个扩展, 它被定义为一个轻量级的高效的线程框架, 并且在1.3版本正式发布, 去掉Experiment标签.</p><h3 id="如何启动一个Coroutines"><a href="#如何启动一个Coroutines" class="headerlink" title="如何启动一个Coroutines"></a>如何启动一个Coroutines</h3><p>最基础的创建一个Coroutines的方法就是使用<code>launch</code>或者<code>async</code>, 二者的区别是前者返回的是一个<code>Job</code>, 不带结果 而后者可以将结果以<code>Deferred&lt;T&gt;</code>格式返回.</p><p>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val job = launch &#123;</span><br><span class="line">    delay(100)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而通常在Coroutines内执行的函数都会有一个<code>suspend</code>声明, 而有<code>suspend</code>声明的函数也只能在Coroutines Scope中调用.</p><p><code>suspend</code>的意思是这个函数可以被suspend(挂起), 让Coroutines来调度它, 这也是为何Kotlin的<code>delay</code>函数可以不阻塞的进行延迟, 因为它就是一个suspend函数.</p><h3 id="Coroutines与线程的关系"><a href="#Coroutines与线程的关系" class="headerlink" title="Coroutines与线程的关系"></a>Coroutines与线程的关系</h3><p>Coroutines可以简单理解为一个有队列的任务链, 每一个Coroutines都有自己的Context, 而Context又可以决定其运行的线程.</p><p>所以可以看到, 并不是起一个Coroutines就是起了一个线程, 而只是启动了一个在某个Scope下运行的协程(Coroutines)罢了. 这里的Scope (CoroutineScope) 内部包含了一个 Context (CoroutineContext).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface CoroutineScope &#123;</span><br><span class="line">    public val coroutineContext: CoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只是通过<code>launch</code>来启动一个协程, 那它将会运行在Parent Scope所定义的线程中, 但是如果使用<code>GlobalScope.launch</code>来启动一个协程, 它将会使用线程池中的线程来创建一个协程, 线程池的大小跟CPU的核数相关.</p><p>当然<code>launch</code>也支持自己传入一个CoroutinesContext来控制它运行的线程, 它叫做<code>CoroutineDispatcher</code>, 是Context的子类.</p><p>上面讲了默认的<code>launch</code>会启在父Scope(Context)的线程中, 而<code>launch(Dispatchers.Default)</code>则等于<code>GlobalScope.launch</code>, 还可以通过<code>launch(newSingleThreadContext(&quot;MyOwnThread&quot;))</code>来启动自己的线程, 另外有一个不推荐在general code中出现的<code>launch(Dispatchers.Unconfined)</code>, 它将会运行在第一个进入Suspend状态的线程中.</p><p>可以举一个简单的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val job = launch &#123;</span><br><span class="line">    log(&quot;hehe&quot;)</span><br><span class="line">    delay(1000)</span><br><span class="line">    log(&quot;haha&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个协程是可以完全在main函数里执行完的, 即输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hehe</span><br><span class="line">haha</span><br></pre></td></tr></table></figure><p>因为launch会跑在main的scope中. 如果替换成:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val job = GlobalScope.launch &#123;</span><br><span class="line">    log(&quot;hehe&quot;)</span><br><span class="line">    delay(1000)</span><br><span class="line">    log(&quot;haha&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则只会输出<code>hehe</code>, 因为主线程已经结束.</p><p>这里我们可以通过<code>job.join()</code>来等待子协程执行结束, 这一点跟大家熟知的线程的join是一样.</p><h3 id="如何切换Context"><a href="#如何切换Context" class="headerlink" title="如何切换Context"></a>如何切换Context</h3><p>如果把Context对应到我们平时认为的线程, 那么这个问题可以类比成 <code>如何切换线程</code>.</p><p>答案是使用<code>withContext</code>, 举一个简单的栗子.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">launch(UI) &#123;</span><br><span class="line">    updateUI()</span><br><span class="line">    val result = withContext(IO) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    setView(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它类似于<code>async(IO){ }.await()</code>.</p><h3 id="如何共享资源"><a href="#如何共享资源" class="headerlink" title="如何共享资源"></a>如何共享资源</h3><p>线程与线程之间会涉及到同步与资源竞争的关系, 协程亦是如此.</p><p>通常情况下在线程中我们解决问题的方式是<code>加锁</code>, 而不正确的使用可能会导致性能下降甚至死锁（dead lock. 或者在高级语言中使用已经实现线程安全的数据类型, 来进行夸线程操作。</p><p>而我们的Coroutines自然也考虑到了这一点, 它认为我们<code>不应该以共享资源来进行通信, 而是以通信来进行资源共享</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Do not communicate by sharing memory; instead, share memory by communicating.</span><br></pre></td></tr></table></figure><p>所以它提出了一个叫做<code>Channel</code>的东西来在不同的Coroutines之间进行通信.</p><p>譬如我们期望将一堆数据交给两个并行的协程进行处理, 那么我们可以把数据放进Channel, 其他的协程从这个Channel进行数据读取.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">launch &#123;</span><br><span class="line">    for (o in data) &#123; channel.send(o) &#125;</span><br><span class="line">    channel.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">launch(One) &#123;</span><br><span class="line">    for (o in channel) &#123;</span><br><span class="line">        xxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">launch(Two) &#123;</span><br><span class="line">    for (o in channel) &#123;</span><br><span class="line">        xxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一定要记得关闭channel, 否则从channel读取数据的协程都将会无限挂起等待数据传过来.</p><p>由于Channel本身实现了<code>iterator</code>, 所以直接通过<code>in</code>就可以挨个取出内部的数据.</p><h3 id="ReceiveChannel与SendChannel"><a href="#ReceiveChannel与SendChannel" class="headerlink" title="ReceiveChannel与SendChannel"></a>ReceiveChannel与SendChannel</h3><p>上一个环节提到的协程之间是通过Channel来进行通信, 而Channel本身却是实现了接收管道与发送管道两个接口.</p><p>我们可以通过<code>producer</code>函数来进行生成数据, 提供给别的协程, 因为它的返回值是一个ReceiveChannel.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val channel = produce&lt;XXX&gt;() &#123;</span><br><span class="line">    for (o in data) send(o)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且produce自己会做channel close的处理, 省去我们发送完毕还要掉close的烦恼.</p><p>如果我们多个协程需要发送请求并集中处理, 或者可以叫数据整合, 那么我们可能需要用到<code>actor</code>这个函数, 它的返回值是一个SendChannel.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">val channel = actor&lt;XXX&gt;() &#123;</span><br><span class="line">                consumeEach &#123;</span><br><span class="line">                   xxx     </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">launch(One) &#123;</span><br><span class="line">    channel.send(xxx)</span><br><span class="line">&#125;</span><br><span class="line">launch(Two) &#123;</span><br><span class="line">    channel.send(xxx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>actor</code>返回的SendChannel有点像是一个邮箱, 它会不断的接收数据, 所以必须手动关闭才会停止.</p><h3 id="多个Channel之间数据如何进行选择"><a href="#多个Channel之间数据如何进行选择" class="headerlink" title="多个Channel之间数据如何进行选择"></a>多个Channel之间数据如何进行选择</h3><p>Coroutines推出一个仍在Experiment阶段的关键字<code>select</code>来在多个suspend function中进行选择第一个到达available的, 其实有点像RxJava的concat+first.</p><p>比如我有两个接收Channel, 但是每一个Channel接收到数据的频率不得而知, 我想分别从中得到数据, 这里就需要使用select.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select&lt;Unit&gt; &#123;</span><br><span class="line">    channel1.onReceive &#123;&#125;</span><br><span class="line">    channel2.onReceive &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在配合外围的循环, 就可以做到不断的去接收两个Channel的数据.</p><p>再比如有两个发送Channel都可以处理我的需求, 我也不知道这个时候谁是空闲的, 那也可以通过select来解决.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select&lt;Unit&gt; &#123;</span><br><span class="line">    channel1.onSend(xxx) &#123;&#125;</span><br><span class="line">    channel2.onSend(xxx) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候两个Channel是嵌套使用的.</p><p>比如一个咖啡店, 他们会不断的收到Oder, 只有两个打咖啡的服务员, 咖啡机也只有两个口,  如果我们对这个咖啡店进行抽象. 将Oder存在于一个Channel里, 服务员接收Order并不断的把咖啡递出来, 这也是一个Channel, 咖啡机会不断接收到服务员需要打咖啡的操作, 也这是一个Channel.</p><p>而在这个过程中, 两个服务员会有一个选择, 咖啡机的两个出口也会有一个选择的过程.</p><p>如果抽象成我们的Coroutines代码, 或许会是这个样子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">val orderChannel = producer &#123;</span><br><span class="line">    for (o in orders) send(o)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val waiter1 = producer &#123;</span><br><span class="line">    for (o in orderChannel) &#123; </span><br><span class="line">        pullCoffee(o)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// waiter2 is the same as 1</span><br><span class="line"></span><br><span class="line">val coffeePort1 = actor &#123;</span><br><span class="line">    consumeEach &#123; </span><br><span class="line">        //pass coffee through channel inside order</span><br><span class="line">        it.channel.send(Coffee)</span><br><span class="line">        it.channel.close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// coffeePort2 is the same as 2</span><br><span class="line"></span><br><span class="line">pullCoffee &#123;</span><br><span class="line">    select&lt;Coffee&gt; &#123;</span><br><span class="line">        coffeePort1.onSend(Request(channel)) &#123;</span><br><span class="line">            //get coffee from coffeePort</span><br><span class="line">            channel.recevie()</span><br><span class="line">        &#125;</span><br><span class="line">        coffeePort2.onSend ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while(someCondition) &#123;</span><br><span class="line">    select&lt;Coffee&gt; &#123;</span><br><span class="line">        waiter1.onReceiveOrNull &#123;</span><br><span class="line">            //上菜了</span><br><span class="line">        &#125;</span><br><span class="line">        waiter2.onReceiveOrNull &#123;</span><br><span class="line">            //上菜了</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>协程作为未来non blocking编程的方向, 需要大家花时间去理解, 花时间去尝试, 在此特别推荐这个咖啡小程序帮助大家学习.</p><p><a href="https://medium.com/@jagsaund/kotlin-coroutines-channels-csp-android-db441400965f" target="_blank" rel="noopener">https://medium.com/@jagsaund/kotlin-coroutines-channels-csp-android-db441400965f</a></p><p>以及官方的Overview</p><p><a href="https://kotlinlang.org/docs/reference/coroutines-overview.html" target="_blank" rel="noopener">https://kotlinlang.org/docs/reference/coroutines-overview.html</a></p><p>还有个CheatSheet可以参考</p><p><a href="https://blog.kotlin-academy.com/kotlin-coroutines-cheat-sheet-8cf1e284dc35" target="_blank" rel="noopener">https://blog.kotlin-academy.com/kotlin-coroutines-cheat-sheet-8cf1e284dc35</a></p>]]></content>
    
    <summary type="html">
    
      深入解析Kotlin Coroutines 协程
    
    </summary>
    
      <category term="Kotlin" scheme="http://talentprince.github.io/categories/Kotlin/"/>
    
    
      <category term="Android" scheme="http://talentprince.github.io/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://talentprince.github.io/tags/Kotlin/"/>
    
      <category term="Kotlin Coroutines" scheme="http://talentprince.github.io/tags/Kotlin-Coroutines/"/>
    
  </entry>
  
  <entry>
    <title>The year that was 2018</title>
    <link href="http://talentprince.github.io/2018/12/28/The-year-that-was-2018/"/>
    <id>http://talentprince.github.io/2018/12/28/The-year-that-was-2018/</id>
    <published>2018-12-28T02:13:42.000Z</published>
    <updated>2020-06-22T09:44:59.478Z</updated>
    
    <content type="html"><![CDATA[<p>昨天天空飘起了大雪, 今天便又艳阳高照, 空气中透着阵阵寒意, 似乎意味着冬天真的来了, 而且是大摇大摆, 万众瞩目.</p><p>四季分明, 或许不是文明泵发的必要条件, 但一年四季, 朝夕交替, 却的确是我们生活, 成长, 喜怒哀乐的必要条件.</p><p>2018年已余额不足, 恍惚间已迈入而立, 然常常并不曾觉察, 思绪也会偶然停留在学校, 停留在实验室, 停留在北京, 停留在年少轻狂的时代. 或许, 这也就是所说的老了吗?</p><p>在这即将过去的一年中, 发生了太多的改变, 虽然已经过去, 沉积在大脑中的余晖, 依旧令我久久不能平息. 我心痛过, 庆幸过, 欢喜过, 也期待着未来美好的事情会发生.</p> <a id="more"></a><ul><li>心痛:</li></ul><p>自宝宝出生后, 孩儿的娘便病魔缠身, 接二连三, 这对生活质量本已下降的整个家庭来说, 仿佛是异常噩梦, 似乎一切都是设定好的那样, 每次都是离希望的出口就差一步, 便又掉了进去, 肉体上的痛苦夹杂着无形的社会压力, 至今回想起来依旧胆战心惊.</p><p>命运的坎坷似乎也有延续与扩散之意, 老婆刚刚康复上班, 五岁的皮皮却在小区被二把刀熟人女司机杀害, 可惜之余, 大家都讲皮皮完成了它的使命, 现在有小小呆来取代它的位置了, 为了防止这段没好的回忆被遗忘, 我将所有与它有关的记忆记录下来, 来缅怀在特殊时期贡献过欢乐的小动物.</p><ul><li>庆幸:</li></ul><p>曾经有讲过, 这些年来没有什么太值得雀跃的事情, 唯独庆幸的是能把老婆从某邪恶组织解脱出来, 而又不伤毫发. 然而似乎这一年需要感谢上苍的事情不少, 小小呆是一个很乖很可爱很健康的宝宝; 老婆的病也终于康复, 生活中诸多与之相关不悦之事都渐渐烟消云散.</p><ul><li>欢喜:</li></ul><p>说道欢喜, 必定是在不断成长的小小呆, 看着从只会呆呆的躺着到现在到处乱跑, 爬上爬下, 模仿大人, 捉迷藏, 似乎一切都发生的太快了, 回头想想去年他还在妈妈的肚子里呢, 不禁感叹大自然与妈妈的伟大, 生命的美好, 以及未来的无限可期.</p><ul><li>期待:</li></ul><p>期待总会有太多, 然成者去半, 顺利达成者去之又半. 对于现在略显枯燥, 疲敝的生活, 应当宽心面对, 已经苦尽, 何愁甘不来呢. 计划一直都在队列里排着, 所有不顺的节点必将随着小小呆的长大而一一打开, 欢乐不会缺席, 只是有时不被觉察, 又或是感叹太过短暂罢了.</p><p>愿一切趋于美好, 顺利过冬.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天天空飘起了大雪, 今天便又艳阳高照, 空气中透着阵阵寒意, 似乎意味着冬天真的来了, 而且是大摇大摆, 万众瞩目.&lt;/p&gt;
&lt;p&gt;四季分明, 或许不是文明泵发的必要条件, 但一年四季, 朝夕交替, 却的确是我们生活, 成长, 喜怒哀乐的必要条件.&lt;/p&gt;
&lt;p&gt;2018年已余额不足, 恍惚间已迈入而立, 然常常并不曾觉察, 思绪也会偶然停留在学校, 停留在实验室, 停留在北京, 停留在年少轻狂的时代. 或许, 这也就是所说的老了吗?&lt;/p&gt;
&lt;p&gt;在这即将过去的一年中, 发生了太多的改变, 虽然已经过去, 沉积在大脑中的余晖, 依旧令我久久不能平息. 我心痛过, 庆幸过, 欢喜过, 也期待着未来美好的事情会发生.&lt;/p&gt;
    
    </summary>
    
      <category term="nonsense" scheme="http://talentprince.github.io/categories/nonsense/"/>
    
    
  </entry>
  
  <entry>
    <title>Android程序员的Flutter学习笔记</title>
    <link href="http://talentprince.github.io/2018/11/08/Flutter-self-learning-notes-as-an-android-developer/"/>
    <id>http://talentprince.github.io/2018/11/08/Flutter-self-learning-notes-as-an-android-developer/</id>
    <published>2018-11-08T03:17:10.000Z</published>
    <updated>2020-06-22T09:44:59.477Z</updated>
    
    <content type="html"><![CDATA[<p>作为忠实与较资深的Android汪, 最近抽出了一些时间研究了一下Google的亲儿子Flutter, 尚属皮毛, 只能算是个简单的记录吧.</p><p>Google自2017年第一次提出Flutter, 到2018年Beta, 再加之RN的各种风波与问题, 使得Flutter的热度不断上升, 国内不少公司都公布Flutter在其产品中的应用, 如美团, 闲鱼等.</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Flutter作为跨平台框架, 常常被人拿出来与React Native, 以及Xamarin进行对比, 除了大家都是跨平台框架之外且能达到近乎Native的体验之外, Flutter与这两者的原理大不相同.</p><p>让我们来看看这三者的结构图吧.</p><p><img src="/images/react_native.png" alt="React Native"></p><p><img src="/images/xamarin.png" alt="Xamarin"></p><p><img src="/images/flutter.png" alt="Flutter"></p><p>可能有一些复杂, 咱大致解释一下.</p><p>React Native跟Xamarin都是基于mapping native代码来实现所谓的Native体验的框架, 只是RN基于JS引擎 + Bridge与native打交道, 并且在运行时进行绑定, 而Xamarin是基于微软的基于Linux的C#虚拟机mono + JNI与native进行通信.</p><p>这里Android与iOS还是有差别的, 如RN在iOS上JS引擎不支持JIT, 会一定程度影响效率, Xamarin在iOS上可以直接编译成iOS平台可以执行的程序, 所以在实际运行起来的性能是一样的, 唯一的差别就是微软得更快的支持API同步.</p><p>对于Flutter来说, 由于他的渲染引擎使用了Skia直绘, 加上基于C++的Dart引擎, 所以在不同平台上没有差别, 加之其实现了Android Material Design与iOS Cupertino两套UI组件, 所以即便是自绘组件, 看起来还是跟原生的一个样子.</p><p>通过对三种跨平台引擎的大致了解, 我们可以看出来, 他们都达到了一定程度的Native体验, 然则各自都有一定的性能损耗, 比如RN的JS引擎加载JS, 以及Bridge通信的损耗, Xamarin Mono虚拟机与Java通信的损耗, 以及Flutter Skia渲染与Native Android渲染的差异等.</p><h2 id="Flutter笔记"><a href="#Flutter笔记" class="headerlink" title="Flutter笔记"></a>Flutter笔记</h2><h3 id="如何启动一个app"><a href="#如何启动一个app" class="headerlink" title="如何启动一个app"></a>如何启动一个app</h3><p>Android需要在Manfest里面指定带有MAIN action与LAUNCHER category的Activity声明, 而Flutter只需要一行.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void main() =&gt; runApp(MyApp());</span><br></pre></td></tr></table></figure><p>其中MyApp就是一个普通的Widgets(View).</p><h3 id="View-vs-Widgets"><a href="#View-vs-Widgets" class="headerlink" title="View vs Widgets"></a>View vs Widgets</h3><p>Flutter没有View, 与之对应的是Widget, 并且分为StatelessWidgets与StatefulWidgets, 前者是个静态View, 后者是动态通过Data来更新的View.</p><ul><li>Stateless</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">  &apos;I like Flutter!&apos;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>Stateful</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class StatefulText extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  State&lt;StatefulWidget&gt; createState() =&gt; _TextState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _TextState extends State&lt;StatefulText&gt; &#123;</span><br><span class="line">  // Default placeholder text</span><br><span class="line">  String textToShow = &quot;I Like Flutter&quot;;</span><br><span class="line"></span><br><span class="line">  void _updateText() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      // update the text</span><br><span class="line">      textToShow = &quot;Flutter is Awesome!&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">      ...invoke _updateText</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上是因为StatefulWidgets通过调用<code>State</code>的<code>setState</code>方法来触发整个Widgets树的重绘, 并且在重绘之前会调用传进去的<code>(){ ... }</code>block.</p><h3 id="怎么写Layout-XML到哪里去了"><a href="#怎么写Layout-XML到哪里去了" class="headerlink" title="怎么写Layout, XML到哪里去了."></a>怎么写Layout, XML到哪里去了.</h3><p>实际上Flutter没有xml了, 并且是通过Widgets的嵌套来实现一个布局的.</p><p>如:</p><ul><li><code>Center</code>是一个可以把子View放置在中央的容器.</li><li><code>Row</code>对应的就是LinearLayout + Horizontal, <code>Column</code>对应的就是LinearLayout + Vertical, 他们都具备一个属性叫做<code>crossAxisAlignment</code>, 有点类似<code>gravity</code>, 来控制子View相对于父View的位置.</li><li><code>Expanded</code>支持一个类似weight的属性, 叫<code>flex</code>. </li><li><code>Container</code>是一个具有<code>decoration</code>属性的容器, 可以用来控制背景色, border, margin等等.</li><li><code>Stack</code>有点像是一个特殊的RelatetiveLayout或者ConstraintLayout, <code>children</code>属性指定了它的子View, 第一个是Base View, <code>alignment</code>属性指定了后面的子View相对于BaseView的位置, 如<code>alignment: const Alignment(0.6, 0.6)</code>指定了位于BaseView右下角的位置.</li><li><code>ListTile</code>是一个特殊的ListItem, 有三个属性, 分别是左边的Icon (leading), 文字 (title), 以及右边的Icon (trailing).</li><li>还有诸如<code>ListView</code>, <code>GridView</code>, <code>Card</code>等等比较熟悉的Widgets.</li></ul><p>另外有一个类似于我们Activity的Widgets:</p><ul><li>叫做<code>MaterialApp</code>, 可以指定<code>theme</code>, <code>title</code>, 以及子View <code>home</code>, 还有更重要的页面跳转<code>routes</code>.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">      title: &apos;Welcome to Flutter&apos;,</span><br><span class="line">      home: ...,</span><br><span class="line">      routes: &lt;String, WidgetBuilder&gt; ...,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primaryColor: Colors.white</span><br><span class="line">      ),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>还有一个类似于Fragment的:</p><ul><li>叫做<code>Scaffold</code>, 中文意思是<code>脚手架</code>, 它包含一个appBar (ActionBar)与一个body, appBar可以指定title与actions (类似于action button的点击事件).</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(widget.title),</span><br><span class="line">        actions: &lt;Widget&gt;[...],</span><br><span class="line">      ),</span><br><span class="line">      body: ...,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h3 id="如何从父View中Remove一个元素"><a href="#如何从父View中Remove一个元素" class="headerlink" title="如何从父View中Remove一个元素"></a>如何从父View中Remove一个元素</h3><p>答案是没有… 因为在Flutter看来, Widgets的树结构是不可以被更改的, 但是如果想更改, 则是通过StatefulWidgets的方法, 通过setState来更改Data, 触发Widgets重绘, 从而替换掉之前的Widgets.</p><h3 id="喜欢画Canvas的同学怎么办"><a href="#喜欢画Canvas的同学怎么办" class="headerlink" title="喜欢画Canvas的同学怎么办?"></a>喜欢画Canvas的同学怎么办?</h3><p>Flutter同样支持, <code>CustomPaint</code>作为一个 Widgets就支持传入一个实现<code>CustomPainter</code>抽象类的参数, 而<code>CustomPainter</code>的抽象方法也类似于Android View的<code>onDraw</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void paint(Canvas canvas, Size size)</span><br><span class="line"></span><br><span class="line">bool shouldRepaint(CustomPainter oldDelegate)</span><br></pre></td></tr></table></figure><h3 id="如何自定义View"><a href="#如何自定义View" class="headerlink" title="如何自定义View"></a>如何自定义View</h3><p>不用继承, 而使用类似Android ViewGroup的办法, 通过组合(composing)与封装的方法来实现, 通过小Widgets组合成需要的新Widgets.</p><h3 id="页面跳转怎么办-四大组件之一的Intent跑哪里去了"><a href="#页面跳转怎么办-四大组件之一的Intent跑哪里去了" class="headerlink" title="页面跳转怎么办, 四大组件之一的Intent跑哪里去了"></a>页面跳转怎么办, 四大组件之一的Intent跑哪里去了</h3><p>貌似在讲类似于Activity的<code>MaterialApp</code>的时候剧透了… </p><p>就是使用<code>Navigator</code>与<code>Routes</code>来实现界面跳转, 实际上是整个Widgets的替换.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">routes: &lt;String, WidgetBuilder&gt; &#123;</span><br><span class="line">      &apos;/a&apos;: (BuildContext context) =&gt; MyPage(title: &apos;page A&apos;),</span><br><span class="line">      &apos;/b&apos;: (BuildContext context) =&gt; MyPage(title: &apos;page B&apos;),</span><br><span class="line">      &apos;/c&apos;: (BuildContext context) =&gt; MyPage(title: &apos;page C&apos;),</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">Navigator.of(context).pushNamed(&apos;/b&apos;);</span><br></pre></td></tr></table></figure><h3 id="如何处理外部的Intent"><a href="#如何处理外部的Intent" class="headerlink" title="如何处理外部的Intent"></a>如何处理外部的Intent</h3><p>实际上还是需要在Flutter App的Android壳子中注册这个filter, 然后在FlutterActivity中拿到存下来, </p><p>FlutterView初始化后再通过Bridge, 官方叫<code>MethodChannel</code>从Java里获取,进行下一步逻辑.</p><p>可以看个简单的例子.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">new MethodChannel(getFlutterView(), &quot;app.channel.shared.data&quot;).setMethodCallHandler(</span><br><span class="line">      new MethodCallHandler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onMethodCall(MethodCall call, MethodChannel.Result result) &#123;</span><br><span class="line">          if (call.method.contentEquals(&quot;getSharedText&quot;)) &#123;</span><br><span class="line">            result.success(sharedText);</span><br><span class="line">            sharedText = null;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">getSharedText() async &#123;</span><br><span class="line">    var sharedData = await platform.invokeMethod(&quot;getSharedText&quot;);</span><br><span class="line">    if (sharedData != null) &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        dataShared = sharedData;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="常用的startActivityForResult怎么办"><a href="#常用的startActivityForResult怎么办" class="headerlink" title="常用的startActivityForResult怎么办."></a>常用的startActivityForResult怎么办.</h3><p>这个Flutter有完全对应的办法, 而且用起来很方便, 结合之前说的页面跳转:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map xxx = await Navigator.of(context).pushNamed(&apos;/xxx&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Navigator.of(context).pop(&#123;xxx&#125;);</span><br></pre></td></tr></table></figure><h3 id="异步怎么办-runOnUiThread-哪里去了"><a href="#异步怎么办-runOnUiThread-哪里去了" class="headerlink" title="异步怎么办, runOnUiThread()哪里去了"></a>异步怎么办, runOnUiThread()哪里去了</h3><p>Flutter有点像JS, 是一个单线程模式, 所以只是通过模拟来构建简单的异步, 关键字就是类似于kotlin coroutines一样, 通过<code>await</code>+<code>async</code>来处理.</p><p>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loadData() async &#123;</span><br><span class="line">    response = await http.get(xxx);</span><br><span class="line">    setState(() &#123;xxx&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是由于它的单线程, 所以无法做很长的阻塞操作, 像http请求的延迟正常情况可能都是毫秒级的, 但是数据的处理等, 可能就得秒级了.</p><p>这也是RN在线程方面的做android程序的一个痛点, Flutter采用了比较容易想到的曲线救国的办法, 提供了一个叫<code>Isolate</code>的对象, 它实际是一个基于socket的数据通道, 相当于把数据放在一个独立的进程进行处理, 然后再通过socket发送回程序进程, 还记得进程间通信办法之一的<code>管道</code>吗…</p><p>具体API可以参考文档<a href="https://flutter.io/docs/get-started/flutter-for/android-devs" target="_blank" rel="noopener">1…</a>,<a href="https://docs.flutter.io/flutter/dart-isolate/Isolate-class.html" target="_blank" rel="noopener">2…</a>.</p><h3 id="Flutter-替代OkHttp的网络库"><a href="#Flutter-替代OkHttp的网络库" class="headerlink" title="Flutter 替代OkHttp的网络库"></a>Flutter 替代OkHttp的网络库</h3><p>自带了http库, 直接<code>http.get(url)</code>, 在线程部分的代码实例里也有涉及.</p><p>通过类似gradle的文件<code>pubspec.yaml</code>引入.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  ...</span><br><span class="line">  http: ^0.12</span><br></pre></td></tr></table></figure><p><code>^</code>表示不升大版本, 并取最新版本, 比gradle的+要范围更小.</p><h3 id="常见的LCE-Loading-Content-Error-里面的Loading怎么show"><a href="#常见的LCE-Loading-Content-Error-里面的Loading怎么show" class="headerlink" title="常见的LCE(Loading Content Error)里面的Loading怎么show"></a>常见的LCE(Loading Content Error)里面的Loading怎么show</h3><p>Flutter有一个widget叫做<code>ProgressIndicator</code>, 比如我们期望有一个转圈圈的Loading界面在数据加载出来之前.</p><p>我们就可以通过StatefulWidgets, 根据数据, 或者List Widgets的个数 (如果是显示一个List的话)来判断是否显示Loading, 使用子类<code>CircularProgressIndicator</code>, 来替换页面的Widgets.</p><p>当然也是通过setState(() {…})来触发界面刷新的, 可以在initState()内触发加载数据的异步操作.</p><h3 id="不同分辨率的图片资源怎么放"><a href="#不同分辨率的图片资源怎么放" class="headerlink" title="不同分辨率的图片资源怎么放"></a>不同分辨率的图片资源怎么放</h3><p>这个有点像iOS了, 即有1x,2x,3x:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">images/my_icon.png       // Base: 1.0x image</span><br><span class="line">images/2.0x/my_icon.png  // 2.0x image</span><br><span class="line">images/3.0x/my_icon.png  // 3.0x image</span><br></pre></td></tr></table></figure><p>不一样的一点还需要添加到类似gradle的文件<code>pubspec.yaml</code>里.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assets:</span><br><span class="line"> - images/my_icon.jpeg</span><br></pre></td></tr></table></figure><h3 id="字符串怎么存储"><a href="#字符串怎么存储" class="headerlink" title="字符串怎么存储"></a>字符串怎么存储</h3><p>Flutter没有像Android的<code>string.xml</code>的东西, 目前来说最好的就就是存成静态字符串.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Strings &#123;</span><br><span class="line">  static String welcomeMessage = &quot;Welcome To Flutter&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Text(Strings.welcomeMessage)</span><br></pre></td></tr></table></figure><h3 id="Gradle变成什么了"><a href="#Gradle变成什么了" class="headerlink" title="Gradle变成什么了"></a>Gradle变成什么了</h3><p>前面说网络库, 图片资源的时候提到过, 提供了一个叫<code>pubspec.yaml</code>的文件, 具体支持的规则可以查看<a href="https://www.dartlang.org/tools/pub/pubspec" target="_blank" rel="noopener">这个文档</a>.</p><h3 id="Fragment与Activity呢"><a href="#Fragment与Activity呢" class="headerlink" title="Fragment与Activity呢?"></a>Fragment与Activity呢?</h3><p>之前做过类比, 如<code>MaterialApp</code>有点类似于Activity, 而<code>Scaffold</code>都点类似Fragment, 实际上他们两个都是Flutter的Widgets, 也就是说其实只有View的概念了.</p><h3 id="还有生命周期吗"><a href="#还有生命周期吗" class="headerlink" title="还有生命周期吗?"></a>还有生命周期吗?</h3><p>Flutter有一个叫做<code>WidgetsBinding</code>的可以提供类似生命周期的回调.</p><p>四种状态<code>inactive</code> (iOS专用), <code>paused</code>(相当于onPause, 退后台), <code>resumed</code>(相当于onPostResume, 到前台), <code>suspending</code>(android专用, 相当于onStop).</p><p>一般在StatefulWidgets的State中注册与反注册.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line"> void initState() &#123;</span><br><span class="line">   super.initState();</span><br><span class="line">   WidgetsBinding.instance.addObserver(this);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> void dispose() &#123;</span><br><span class="line">   WidgetsBinding.instance.removeObserver(this);</span><br><span class="line">   super.dispose();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="ScrollView-vs-ListView"><a href="#ScrollView-vs-ListView" class="headerlink" title="ScrollView vs ListView"></a>ScrollView vs ListView</h3><p>Flutter没有ScrollView, 合并到了ListView, 通过ListView.builder创建的ListView提供了View复用的逻辑.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ListView.builder(</span><br><span class="line">          itemCount: widgets.length,</span><br><span class="line">          itemBuilder: (BuildContext context, int position) &#123;</span><br><span class="line">            return Text(xxx);</span><br><span class="line">          &#125;))</span><br></pre></td></tr></table></figure><p>其中itemBuilder有点像Android ListView的getView, 官方文档说它会自动回收Element给你, 但是事实上每次你都需要根据position生成新的Widgets, 所以呢应该是Flutter在内部回收了之前的Widgets并在你重新创建的时候又用上了.</p><p>BTW, 通过ListView构造来显示就不具备这种特性, 所以大量数据需要用Builder.</p><h3 id="Flutter横竖屏怎么玩"><a href="#Flutter横竖屏怎么玩" class="headerlink" title="Flutter横竖屏怎么玩."></a>Flutter横竖屏怎么玩.</h3><p>因为它实际上还是借助了Android程序的壳子, 所以如果AndroidManifect定义了<code>android:configChanges=&quot;orientation|screenSize&quot;</code>, 则Flutter会自己hanlde.</p><h3 id="怎么处理Gesture"><a href="#怎么处理Gesture" class="headerlink" title="怎么处理Gesture"></a>怎么处理Gesture</h3><p>Flutter提供了<code>GestureDetector</code>, 它相当于一个Container, 将我们期望接收手势的Widgets放进去, 再实现事件回调就行了.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GestureDetector(</span><br><span class="line">        child: FlutterLogo(</span><br><span class="line">          size: 200.0,</span><br><span class="line">        ),</span><br><span class="line">        onTap: () &#123;</span><br><span class="line">          print(&quot;tap&quot;);</span><br><span class="line">        &#125;,</span><br><span class="line">      )</span><br></pre></td></tr></table></figure><p>它同样支持其他的手势, 如<code>onDoubleTap</code>等等等.</p><h3 id="字体怎么弄"><a href="#字体怎么弄" class="headerlink" title="字体怎么弄"></a>字体怎么弄</h3><p>首先需要在<code>pubspec.yaml</code>里面配置需要的字体库:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fonts:</span><br><span class="line">   - family: MyCustomFont</span><br><span class="line">     fonts:</span><br><span class="line">       - asset: fonts/MyCustomFont.ttf</span><br><span class="line">       - style: italic</span><br></pre></td></tr></table></figure><p>然后在Text的<code>style</code>属性进行配置.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">        &apos;This is a custom font text&apos;,</span><br><span class="line">        style: TextStyle(fontFamily: &apos;MyCustomFont&apos;),</span><br><span class="line">      )</span><br></pre></td></tr></table></figure><h3 id="Hint哪里去了-错误信息怎么输出"><a href="#Hint哪里去了-错误信息怎么输出" class="headerlink" title="Hint哪里去了, 错误信息怎么输出"></a>Hint哪里去了, 错误信息怎么输出</h3><p>对于输入框的Hint基本一致, 可能就是换了个名字, 一看便知.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">    decoration: InputDecoration(hintText: &quot;This is a hint&quot;, errorText: _getErrorText()),</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Flutter在视图渲染上另辟蹊径, 性能优势凸显, 在跨平台框架属于一匹黑马, 又有Google撑腰, 值得在Mobile勤耕多年的同学入手. </p><p>由于作者曾经从事过2年的Webkit开发工作, 拜读了Flutter的渲染模式, 很像是Webkit/Chrome/Blink的思路, 通过查证, 起草者确实有大批同样的人, 如果你还没有入坑RN, 或许Flutter可以作为跨平台方案学习的首选哦. </p><p>同样Google自己也有很多Plugin去支持更多扩展功能, 如GPS, Camera, SharePreference, Database. 还例如Firebase这种亲儿子级的服务也是全面支持Flutter. 这些都可以通过<a href="https://pub.dartlang.org" target="_blank" rel="noopener">Dartlang</a>来查询.</p><p>当然也可以自己去开发需要的Plugin来适配需要的功能, 基于的技术就是上面有提的<code>MethodChannel</code>, NDK的支持也是同样的道理.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://flutter.io/docs/get-started/flutter-for/android-devs" target="_blank" rel="noopener">https://flutter.io/docs/get-started/flutter-for/android-devs</a></p>]]></content>
    
    <summary type="html">
    
      Android程序员 Flutter学习笔记 Flutter self-learning notes as an android developer
    
    </summary>
    
      <category term="Flutter" scheme="http://talentprince.github.io/categories/Flutter/"/>
    
    
      <category term="Android" scheme="http://talentprince.github.io/tags/Android/"/>
    
      <category term="Flutter" scheme="http://talentprince.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>如何正确使用Espresso来测试你的Android程序</title>
    <link href="http://talentprince.github.io/2018/09/30/How-to-correctly-use-android-espresso-to-test-your-UI/"/>
    <id>http://talentprince.github.io/2018/09/30/How-to-correctly-use-android-espresso-to-test-your-UI/</id>
    <published>2018-09-30T02:12:48.000Z</published>
    <updated>2020-06-22T09:44:59.477Z</updated>
    
    <content type="html"><![CDATA[<p>UI测试在Android平台上一直都是一个令人头痛的事情, 由于大家平时用的很少, 加之很多文档的缺失, 如果很多东西从头摸索,势必踩坑无数.</p><p>自Android24正式淘汰掉了<a href="https://developer.android.com/reference/android/test/InstrumentationTestCase" target="_blank" rel="noopener">InstrumentationTestCase</a>(位于android.test包), 推出<a href="https://developer.android.com/training/testing/espresso/" target="_blank" rel="noopener">Espresso</a>(位于android.support.test包), Google一直致力于降低UI测试的门槛.</p><p>了解测试金字塔的同学可能知道,UI测试属于功能测试(Functional Test), 或者按照其他的划分也属于集成测试(Integration Test), Google推出了<a href="https://developer.android.com/training/testing/ui-automator" target="_blank" rel="noopener">UIAutomator</a>与<a href="https://developer.android.com/training/testing/espresso" target="_blank" rel="noopener">Espresso</a>来分别处理跨App间的测试(<a href="https://zh.wikipedia.org/wiki/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">黑盒测试</a>)以及App内的测试(<a href="https://zh.wikipedia.org/wiki/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">白盒测试</a>).</p><p>测试步骤类似,分为:</p><ul><li>查找元素</li><li>触发行为</li><li>检测结果</li></ul><p>本文分为三部分, 第一部分简单介绍如何使用Espresso, 第二部分分析如何处理诸如异步, 依赖注入, 程序结构对UI测试的影响以及提供解决办法, 第三部分提供源码以及一些Reference的地址.</p><a id="more"></a><h2 id="Part-I"><a href="#Part-I" class="headerlink" title="Part I"></a>Part I</h2><h3 id="如何配置"><a href="#如何配置" class="headerlink" title="如何配置"></a>如何配置</h3><p>1.需要在gradle的dependencies里添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.2&apos;</span><br><span class="line">androidTestImplementation &apos;com.android.support.test:runner:1.0.2&apos;</span><br><span class="line">androidTestImplementation &apos;com.android.support.test:rules:1.0.2&apos;</span><br></pre></td></tr></table></figure><p>2.在gradle的android.defaultConfig里指定TestRunner</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br></pre></td></tr></table></figure><p>3.书写测试文件,通过<code>AndroidJUnit4</code>来跑即可,使用Activity Rule来启动你的Activity.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Rule</span><br><span class="line">@JvmField</span><br><span class="line">var activityTestRule: ActivityTestRule&lt;MainActivity&gt; = ActivityTestRule&lt;MainActivity&gt;()</span><br></pre></td></tr></table></figure><p>4.添加测试.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onView(withText(&quot;Hello world!&quot;)).check(matches(isDisplayed()));</span><br></pre></td></tr></table></figure><p>5.运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew connectedAndroidTest</span><br></pre></td></tr></table></figure><p>或在IDE中进行运行.</p><p>以上步骤写的比较简略, 如果第一次使用, 可参考<a href="https://developer.android.com/training/testing/espresso/setup" target="_blank" rel="noopener">官方文档</a>.</p><h2 id="Part-II"><a href="#Part-II" class="headerlink" title="Part II"></a>Part II</h2><h3 id="貌似已经会了-打钩-x"><a href="#貌似已经会了-打钩-x" class="headerlink" title="貌似已经会了, 打钩[x]?"></a>貌似已经会了, 打钩[x]?</h3><p>对于简单的UI其实上面的5步已经完全足够,  这也是Espresso好用的地方,  将UI测试写的跟普通的Unit Test一样简单.</p><p>但是随着你的UI变得复杂, 很多问题接踵而至.</p><p>其根本原因在于, Espresso系统在处理内置UI渲染(包括WebView)的异步操作都没有问题, 它会等待页面的渲染与加载, 而你自己如果有异步逻辑, 可能测试进程不会等待其完成而结束, 导致测试失败.</p><p>而采用Unit Test将无论是RxJava的Scheduler或者是Excutor替换成同一个线程的方法没法在UI Test中使用. 原因是UI操作只能在创建它的线程使用(UI 线程), 而如果你用了网络或者Room之类的数据库, 它又无法在UI线程使用, 相互矛盾, 进退两难.</p><p>所以这个时候就需要使用Espresso提供的<a href="https://developer.android.com/training/testing/espresso/idling-resource" target="_blank" rel="noopener">IdleResource</a>, 来通知系统是否Idle或者Busy.</p><h3 id="什么时候该使用IdleResource"><a href="#什么时候该使用IdleResource" class="headerlink" title="什么时候该使用IdleResource"></a>什么时候该使用IdleResource</h3><p>其实IdleResource的官方文档里面有指出, 如果你的测试里有使用:</p><ul><li>Thread.sleep()</li><li>Retry</li><li>CountDown …</li></ul><p>来保证你的测试工作正常, 那么意味着你应该使用IdleResource了.</p><p>或许刚刚接触Espresso的你可能还没有意识到问题所在, 还没有使用Work Around的方法来解决问题, 换个角度来说可能更好理解.</p><p>如果你所测试程序里有使用:</p><ul><li>Databinding</li><li>LiveData</li><li>通过非AsyncTask实现的异步操作</li><li>Fragment跳转</li><li>等等…</li></ul><p>那么就意味着你需要使用IdleResource来保证你的测试能顺利进行, 否则Test Case可能在程序异步操作未执行时就已经关闭了.</p><h3 id="如何使用IdleResource"><a href="#如何使用IdleResource" class="headerlink" title="如何使用IdleResource"></a>如何使用IdleResource</h3><p><a href="https://developer.android.com/training/testing/espresso/idling-resource" target="_blank" rel="noopener">IdleResource</a>的三个关键接口都非常Straigtforward.</p><p>1.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun getName(): String</span><br></pre></td></tr></table></figure></p><p>每一个IdleResource都应该有唯一的Name来注册到系统里, 不能重复.</p><p>2.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun isIdleNow(): Boolean</span><br></pre></td></tr></table></figure></p><p>Espresso会从UI线程调用, 通过这个方法来获得是否进入Idle状态.</p><p>3.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun registerIdleTransitionCallback(callback: IdlingResource.ResourceCallback)</span><br></pre></td></tr></table></figure></p><p>当该IdleResource被使用时, Espresso会注册该callback, 当background job执行完毕后, 需要调用callback.onTransitionToIdle()通知(<strong>如果已经是Idle状态, 调用也不影响, 所以很多简单的实现都是将这个调用放在isIdleNow中, 判断已经idle就调用, 虽然google的best practice里说不要这样</strong>), 该调用会通知UI线程, 并可以在任何线程调用.</p><p>在使用IdleResource的时候, 通常是通过注册Rule来驱动的, 这个就需要继承<code>TestWatcher</code>.</p><p>复写它的starting与finished方法, 通过<code>IdlingRegistry.getInstance().register</code>与<code>IdlingRegistry.getInstance().unregister</code>来注册/反注册IdleReource, 当然可能需要在finished的时候drain掉所有在运行的Task.</p><p>给一个简单的例子把.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class SampleIdleResourceRule : TestWatcher() &#123;</span><br><span class="line">    private val idlingResource: IdlingResource = xxx</span><br><span class="line">    </span><br><span class="line">    override fun starting(description: Description?) &#123;</span><br><span class="line">        IdlingRegistry.getInstance().register(idlingResource)</span><br><span class="line">        super.starting(description)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override fun finished(description: Description?) &#123;</span><br><span class="line">        //drain all the pending task here if needed.</span><br><span class="line">        IdlingRegistry.getInstance().unregister(idlingResource)</span><br><span class="line">        super.finished(description)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="举个IdleResource的例子吧"><a href="#举个IdleResource的例子吧" class="headerlink" title="举个IdleResource的例子吧."></a>举个IdleResource的例子吧.</h3><p>1.使用LiveData等Archtecture Component组件</p><p>我们知道LiveData是一个订阅系统, 是必涉及后台线程, 比较方便的是它自己内部已经调用了IdleResource来增加/减少后台job, 所以直接使用系统提供的<a href="https://developer.android.com/reference/android/support/test/espresso/idling/CountingIdlingResource" target="_blank" rel="noopener">CountingTaskExecutorRule</a>.</p><p>由于Resource name不能重复, 所以为了绕过这个检测, 需要继承<code>CountingTaskExecutorRule</code>来复写getName.</p><p>具体可以参考google的<a href="https://github.com/googlesamples/android-architecture-components/blob/1c91038b55d52fe1006b3b4c6436003f4da29c4f/GithubBrowserSample/app/src/androidTest/java/com/android/example/github/util/TaskExecutorWithIdlingResourceRule.kt#L31" target="_blank" rel="noopener">TaskExecutorWithIdlingResourceRule</a>.</p><p>Google还提供了Databinding的Rule, 可以参考.</p><p>2.等待弹框结束</p><p>一般情况下我们使用DialogFragment来弹框, 如果我们去check一些text被dialog遮挡, 就必须等待其消失后在进行检查.</p><p>这时我们可以通过<code>findFragmentByTag</code>来检测该弹框是否dismiss.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class DialogIdlingResource(</span><br><span class="line">        private val manager: FragmentManager, </span><br><span class="line">        private val tag: String) : IdlingResource &#123;</span><br><span class="line">    private var resourceCallback: IdlingResource.ResourceCallback? = null</span><br><span class="line"></span><br><span class="line">    override fun getName(): String = &quot;xxx&quot;</span><br><span class="line"></span><br><span class="line">    override fun registerIdleTransitionCallback(callback: IdlingResource.ResourceCallback?) &#123;</span><br><span class="line">        resourceCallback = callback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun isIdleNow(): Boolean &#123;</span><br><span class="line">        val idle = manager.findFragmentByTag(tag) == null</span><br><span class="line">        if (idle) &#123;</span><br><span class="line">            resourceCallback?.onTransitionToIdle()</span><br><span class="line">        &#125;</span><br><span class="line">        return idle</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.Delegate Executors/Scheduler</p><p>如果有异步处理逻辑, 大多都位于Repository/ViewModel层, 这部分会被Mock, 但也有一些UI逻辑可能会用到Excecutor. 如RecyclerView的DiffUtil, 需要传入一个Executor来做异步Diff, 这时我们就需要一个Excecutor的IdlingResource, 并把它里面的Delegate赋值给UI.</p><p>这部分可以参考Google GithubBrowser Sample的<a href="https://github.com/googlesamples/android-architecture-components/blob/1c91038b55d52fe1006b3b4c6436003f4da29c4f/GithubBrowserSample/app/src/androidTest/java/com/android/example/github/util/CountingAppExecutorsRule.kt#L32" target="_blank" rel="noopener">CountingAppExecutorsRule</a>.</p><h3 id="应该怎么测试-需要测试什么"><a href="#应该怎么测试-需要测试什么" class="headerlink" title="应该怎么测试, 需要测试什么?"></a>应该怎么测试, 需要测试什么?</h3><p>虽然Espresso测试是集成测试,  但是由于涉及到异步逻辑导致Test Case无法按照预期进行的问题时而存在, 且有时候无法通过IdlingResource来解决.</p><p>比如涉及到多个Fragment的跳转, 就会发生在Fragment未打开时Test Case就挂掉的情况.</p><p>再比如使用RxJava, 在Espresso3.x + RxJava2.x的情况下, 即便将Scheduler代理给IdlingResource也无法保证整个业务流程完整走下来, 异步操作仍无法完整运行, 具体问题可参考Jake大神RxIdler的<a href="https://github.com/square/RxIdler" target="_blank" rel="noopener">Issue</a>.</p><p>所以测试起来就有一些原则需要遵守, 才能保证整个流程的可测性.</p><ul><li>最好对每一个Fragment进行单独测试, Mock所依赖的部分, 如网络, 数据模块, 如果涉及Fragment跳转逻辑, 通过继承来复写进行测试.</li><li>如果使用了RxJava, 需要将其封装在Repository或者Presenter/ViewModel中进行整体的Mock.</li><li>如果使用了Dagger2.android进行自动注入, 最好对测试部分自定义TestRunner提供一个空的Application来Disable注入, 对所测试Fragment注入对象进行手动赋值.</li><li>如果Activity有注入逻辑, 最好将其解耦到Fragment, 因为Espresso的Activity是通过ActivityRule来启动, 无法进行直接手动注入.</li><li>如果无法Move到Fragment, 或者不想… 那就需要在测试里构建自己的Dagger Component, 对于使用Dagger2.android自动注入的, 还需要手动创建Fake的DispatchingAndroidInjector完成手动注入.</li><li>如果未使用Dagger2.android, 通过AndroidInjector来注入的, 可以忽略与注入相关的item.</li></ul><h3 id="能再讲的仔细一些吗"><a href="#能再讲的仔细一些吗" class="headerlink" title="能再讲的仔细一些吗?"></a>能再讲的仔细一些吗?</h3><p>1.单独测试Fragment的好处是可以解耦Fragment之间的跳转, 往往Fragment都是UI流程中的一个环节, 当逻辑完成时会跳向下一Fragment. 可以创建一个空Activity来专门用于显示该Fragment, 并且在测试的setUp里commit该Fragment.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class TestActivity &#123;</span><br><span class="line">    fun showFragment()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RunWith(AndroidJUnit4::class)</span><br><span class="line">class XXXFragmentTest &#123;</span><br><span class="line">    @Rule</span><br><span class="line">    @JvmField</span><br><span class="line">    val activityRule = ActivityTestRule(XXXFragment::class.java)</span><br><span class="line">    </span><br><span class="line">    @Before</span><br><span class="line">    fun init() &#123;</span><br><span class="line">        //1. init fragment</span><br><span class="line">        //2. assign mock data</span><br><span class="line">        activityRule.showFragment(xxx)  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    fun testXXX() &#123;</span><br><span class="line">        xxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.由于常常会需要继承需要测试的Fragment来复写一些类, 对于使用Dagger.android自动注入的, 该子Fragment又未通过<code>@ContributesAndroidInjector</code>进行注册, 往往需要自定义TestRunner, 然后手动注入Fragment.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class CustomTestRunner : AndroidJUnitRunner() &#123;</span><br><span class="line">    override fun newApplication(...) &#123;</span><br><span class="line">        return ...TestApp:class...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        testInstrumentationRunner &quot;xxx.CustomTestRunner&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestApp : Application() &#123;&#125;</span><br><span class="line"></span><br><span class="line">@RunWith(AndroidJUnit4::class)</span><br><span class="line">class XXXFragmentTest &#123;</span><br><span class="line">    //activity rule</span><br><span class="line">    ...</span><br><span class="line">    val testFragment = TestFragment()</span><br><span class="line">    </span><br><span class="line">    @Before</span><br><span class="line">    fun init() &#123;</span><br><span class="line">        testFragment.xxx = mockXXX</span><br><span class="line">        ...</span><br><span class="line">        activityRule.activity.showFragment(testFragment)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    fun testXXX() &#123;</span><br><span class="line">        onView...check(...)</span><br><span class="line">        assertTrue(testFragment.isXXXShow)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class TestFragment : XXXFragment() &#123;</span><br><span class="line">        var isXXXShow = false</span><br><span class="line">        override fun showXXX() &#123;</span><br><span class="line">            isXXXShow = true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.如果Activity有注入逻辑与业务逻辑, 并且不想抽到Fragment中去, 则需要创建Fake的Injector保证可以完成注入, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun createFakeInjector(block: T.() -&gt; Unit): DispatchingAndroidInjector&lt;Activity&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RunWith(AndroidJUnit4::class)</span><br><span class="line">class XXXActivityTest &#123;</span><br><span class="line">    @Rule</span><br><span class="line">    @JvmField</span><br><span class="line">    var activityRule = object : ActivityTestRule&lt;XXX&gt;(XXX::class.java) &#123;</span><br><span class="line">       val app = ...get application</span><br><span class="line">       app.dispatchingAndroidInjector = createFakeInjector&lt;XXX&gt;() &#123;</span><br><span class="line">           //手动注入</span><br><span class="line">           xxx =  mockXXX</span><br><span class="line">           `when`(xxx).thenReturn(xxx)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.为了支持需要通过继承Fragment来完成测试的Case, 还需要对测试模块创建自己的Component来注册从而进行Fake Injector的创建 (类似3, 只是Application/Activity可能为Test版本).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Grale</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    kaptAndroidTest &apos;com.google.dagger:dagger-android-processor:2.X&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Component(modules = [</span><br><span class="line">    AndroidInjectionModule::class,</span><br><span class="line">    AndroidSupportInjectionModule::class,</span><br><span class="line">    ...主App所注册的所有Module,</span><br><span class="line">    TestActivityModule::class])</span><br><span class="line">interface TestCompnent &#123;</span><br><span class="line">    fun inject(xxx: XXX)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Module</span><br><span class="line">abstract class TestActivityModule &#123;</span><br><span class="line">  //通过`ContributesAndroidInjector`注册你的TestActivity, 以及TestFragment  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestApp : Application(), HasActivityInjector &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    lateinit var injector: DispatchingAndroidInjector&lt;Activity&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestActivity : Activity(), HasSupportFragmentInjector &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    lateinit var injector: DispatchingAndroidInjector&lt;Fragment&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Part-III"><a href="#Part-III" class="headerlink" title="Part III"></a>Part III</h2><h3 id="如果还不是很明白可以查看代码"><a href="#如果还不是很明白可以查看代码" class="headerlink" title="如果还不是很明白可以查看代码"></a>如果还不是很明白可以查看代码</h3><p>Disable注入的在这里:<br><a href="https://github.com/googlesamples/android-architecture-components/tree/master/GithubBrowserSample" target="_blank" rel="noopener">Google的Demo GithubBrowser</a></p><p>跟注入相关的在这里:<br><a href="https://github.com/mengdd/DribbbleClient" target="_blank" rel="noopener">自己的Demo</a></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://proandroiddev.com/activity-espresso-test-with-daggers-android-injector-82f3ee564aa4" target="_blank" rel="noopener">https://proandroiddev.com/activity-espresso-test-with-daggers-android-injector-82f3ee564aa4</a></li><li><a href="https://github.com/SabagRonen/dagger-activity-test-sample" target="_blank" rel="noopener">https://github.com/SabagRonen/dagger-activity-test-sample</a></li><li><a href="https://github.com/googlesamples/android-architecture-components/tree/master/GithubBrowserSample" target="_blank" rel="noopener">https://github.com/googlesamples/android-architecture-components/tree/master/GithubBrowserSample</a></li><li><a href="https://developer.android.com/training/testing/espresso/idling-resource" target="_blank" rel="noopener">https://developer.android.com/training/testing/espresso/idling-resource</a></li><li><a href="http://blog.sqisland.com/2015/07/espresso-wait-for-dialog-to-dismiss.html" target="_blank" rel="noopener">http://blog.sqisland.com/2015/07/espresso-wait-for-dialog-to-dismiss.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      如何使用Android Espresso测试UI
    
    </summary>
    
      <category term="Android" scheme="http://talentprince.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://talentprince.github.io/tags/Android/"/>
    
      <category term="Espresso" scheme="http://talentprince.github.io/tags/Espresso/"/>
    
      <category term="UI Automation Test" scheme="http://talentprince.github.io/tags/UI-Automation-Test/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #319</title>
    <link href="http://talentprince.github.io/2018/07/27/Android-Weekly-Issue-319/"/>
    <id>http://talentprince.github.io/2018/07/27/Android-Weekly-Issue-319/</id>
    <published>2018-07-27T01:00:01.000Z</published>
    <updated>2020-06-22T09:44:59.475Z</updated>
    
    <content type="html"><![CDATA[<p>July 22nd, 2018</p><h2 id="Android-Weekly-Issue-319"><a href="#Android-Weekly-Issue-319" class="headerlink" title="Android Weekly Issue #319"></a><a href="http://androidweekly.net/issues/issue-319" target="_blank" rel="noopener">Android Weekly Issue #319</a></h2><p>本期内容包括MotionLayout如何做动画的介绍,Kotlin when完备性的实现,以及如何Move一些Gradle的东西到Kotlin,还包括一个比较好的Kotlin Test库,以及如何用LiveData整合不同数据源,还有一个轻量级的Kotlin Eventbus的推荐.</p><p>Lib部分有Jake大神的Android与Chrome Extension的android sdk查看器,还有一个android黄瓜测试生成工具等…</p><a id="more"></a><h1 id="NOTES"><a href="#NOTES" class="headerlink" title="NOTES"></a>NOTES</h1><h2 id="Creating-Animations-With-MotionLayout-for-Android"><a href="#Creating-Animations-With-MotionLayout-for-Android" class="headerlink" title="Creating Animations With MotionLayout for Android "></a><a href="https://code.tutsplus.com/tutorials/creating-animations-with-motionlayout-for-android--cms-31497" target="_blank" rel="noopener">Creating Animations With MotionLayout for Android </a></h2><p>通过定义MotionLayout布局xml,指定定义好的MotionScene就可以完成动画.</p><p>MotionScene内可以定义ConstraintSet指定位置,然后定义Transition指定起始Constraint,也可以指定KeyFrameSet包含多个KeyPostion,或者KeyCircle.</p><p>还可以绑定事件,OnClick,OnSwipe来启动动画.</p><h2 id="When-is-“when”-exhaustive"><a href="#When-is-“when”-exhaustive" class="headerlink" title="When is “when” exhaustive? "></a><a href="https://medium.com/@ataulm/til-when-is-when-exhaustive-31d69f630a8b" target="_blank" rel="noopener">When is “when” exhaustive? </a></h2><p>为了防止大家写when的时候忘记写else导致问题,作者想出来了一些好办法.</p><p>如when {}.let{}或者扩展方法返回自己.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val &lt;T&gt; T.exhaustive: T</span><br><span class="line">    get() = this</span><br></pre></td></tr></table></figure><h2 id="Android-Studio-Taming-the-interface"><a href="#Android-Studio-Taming-the-interface" class="headerlink" title="Android Studio - Taming the interface "></a><a href="https://jeroenmols.com/blog/2018/07/16/androidstudioshortcuts3/" target="_blank" rel="noopener">Android Studio - Taming the interface </a></h2><p>AS的一些快捷键,有一些很多人没注意到的,如小窗口的大小调整,等等.配有动图.</p><h2 id="Becoming-Google-Certified-Associate-Android-Developer"><a href="#Becoming-Google-Certified-Associate-Android-Developer" class="headerlink" title="Becoming Google Certified Associate Android Developer "></a><a href="https://medium.com/@sodiqOladeni/becoming-google-certified-associate-android-developer-907bdb61d79f" target="_blank" rel="noopener">Becoming Google Certified Associate Android Developer </a></h2><p>Google推出了149美元考助理安卓工程师的认证,24小时完成一个project并提交,如果通过在线10分钟回答5个问题,就可以轻松通过…</p><p>如果不通过可以免费补考,如果还不过那就得交钱了…</p><p>只考安卓四大组件,不考语言知识,因为安卓更重要的是框架组件..</p><h2 id="Maintainable-Architecture-–-Daily-Forecast"><a href="#Maintainable-Architecture-–-Daily-Forecast" class="headerlink" title="Maintainable Architecture – Daily Forecast "></a><a href="https://blog.stylingandroid.com/maintainable-architecture-daily-forecast/" target="_blank" rel="noopener">Maintainable Architecture – Daily Forecast </a></h2><p>系列最后一节,主要讲了如何注入你的ViewModel,还给出了demo地址.</p><h2 id="Cloud-Continuous-Integration-on-Android-with-Kotlin-Project"><a href="#Cloud-Continuous-Integration-on-Android-with-Kotlin-Project" class="headerlink" title="Cloud Continuous Integration on Android with Kotlin Project "></a><a href="https://proandroiddev.com/cloud-continuous-integration-on-android-with-kotlin-project-8d6f12cbf0c4" target="_blank" rel="noopener">Cloud Continuous Integration on Android with Kotlin Project </a></h2><p>文章介绍了如何大家CI,本篇作者使用的是Travis,并且添加了Jacoco生成覆盖率报告,并且push到Codecov.io上.</p><p>最后当然不要忘记加高大上的badge到你的README…</p><h2 id="Moving-Your-Gradle-Build-Scripts-to-Kotlin"><a href="#Moving-Your-Gradle-Build-Scripts-to-Kotlin" class="headerlink" title="Moving Your Gradle Build Scripts to Kotlin "></a><a href="https://pspdfkit.com/blog/2018/moving-your-gradle-build-scripts-to-kotlin/" target="_blank" rel="noopener">Moving Your Gradle Build Scripts to Kotlin </a></h2><p>本篇文章实际上是个标题党,与之前介绍的用Kotlin DSL写gradle的<a href="https://antonioleiva.com/kotlin-dsl-gradle/" target="_blank" rel="noopener">文章</a>不太一样.</p><p>这篇文章只是自己定义了一个plugin,并且可以在自己的buildSrc里面用kotlin声明一些变量, 然后在gradle里面去调用,比如说dependencies的版本.</p><p>之前的那篇文章使用了gradle 4.5.1以上的新特性,然后将gradle后面加上后缀kts即可,当然在buildSrc里面声明变量的同时还需要引用<code>kotlin-dsl</code>插件.这样你的kts文件里就可以写成kotlin dsl风格了.这是题外话…可以查看#283的文章.</p><h2 id="Data-Driven-Testing-with-KotlinTest"><a href="#Data-Driven-Testing-with-KotlinTest" class="headerlink" title="Data Driven Testing with KotlinTest "></a><a href="https://proandroiddev.com/data-driven-testing-with-kotlintest-a07ac60e70fc" target="_blank" rel="noopener">Data Driven Testing with KotlinTest </a></h2><p>作者推荐一个叫<a href="https://github.com/kotlintest/kotlintest" target="_blank" rel="noopener">KotlinTest</a>的库可以提供很多有趣的assert方法.</p><p>来支持他自己的Data driven test的理念,来做数据的对比.</p><p>如forAll可以添加很多组数据,然后通过shouldBe进行判断.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">forAll(</span><br><span class="line">    row(...)</span><br><span class="line">) &#123; ... -&gt;</span><br><span class="line">   ... shouldBe ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reactive-patterns-using-Transformations-and-MediatorLiveData"><a href="#Reactive-patterns-using-Transformations-and-MediatorLiveData" class="headerlink" title="Reactive patterns using Transformations and MediatorLiveData "></a><a href="https://medium.com/google-developers/livedata-beyond-the-viewmodel-reactive-patterns-using-transformations-and-mediatorlivedata-fda520ba00b7" target="_blank" rel="noopener">Reactive patterns using Transformations and MediatorLiveData </a></h2><p>作者介绍了如何用MediatorLiveData+Transformations来实现RxJava类似于zip的功能来进行combine不同的DataSource.</p><p>在这之前作者介绍了使用LiveData过程中的一些注意事项以及解决办法.</p><p>如是否去Share一个LiveData需要值得考虑它会导致的问题,使用MediatorLiveData添加外部source会导致泄露,使用switchMap去解决问题的时候也一定注意需要在构造的时候用,因为map/switchMap都会创建新的LiveData,等等.</p><p>最后一句话写到,如果使用了AutoDisposal的Rxjava第三方控件,就没必须这么用LiveData了.</p><h2 id="Delegate-your-Lifecycle-to-Kotlin"><a href="#Delegate-your-Lifecycle-to-Kotlin" class="headerlink" title="Delegate your Lifecycle to Kotlin "></a><a href="https://blog.blueapron.io/delegate-your-lifecycle-to-kotlin-17c1d0d876c9" target="_blank" rel="noopener">Delegate your Lifecycle to Kotlin </a></h2><p>为了防止一些Activity或者Fragment的变量有跟生命周期同等的初始化与销毁,使用Kotlin的<code>by</code>来交给代理来改变它的Value,代理通过很多方式都可以监听生命周期,如LifecycleObserver,或者RxLifeCycle,来实现setValue.</p><h2 id="KDispatcher-simple-and-light-weight-event-bus-for-Kotlin"><a href="#KDispatcher-simple-and-light-weight-event-bus-for-Kotlin" class="headerlink" title="KDispatcher simple and light-weight event bus for Kotlin "></a><a href="https://medium.com/@sphc/kdispatcher-simple-and-light-weight-event-bus-for-kotlin-e0fa4aaea1c7" target="_blank" rel="noopener">KDispatcher simple and light-weight event bus for Kotlin </a></h2><p>一个Kotlin的轻量EventBus,而且是与平台无关的,backend也可以用.</p><h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="wearfaceutils"><a href="#wearfaceutils" class="headerlink" title="wearfaceutils "></a><a href="https://github.com/purposebakery/wearfaceutils" target="_blank" rel="noopener">wearfaceutils </a></h2><p>Android Wear 表盘</p><h2 id="pickle"><a href="#pickle" class="headerlink" title="pickle "></a><a href="https://github.com/fourlastor/pickle" target="_blank" rel="noopener">pickle </a></h2><p>Android 黄瓜测试代码生成器.</p><h2 id="kotlintest"><a href="#kotlintest" class="headerlink" title="kotlintest "></a><a href="https://github.com/kotlintest/kotlintest" target="_blank" rel="noopener">kotlintest </a></h2><p>一个kotlin test framework, 可以写出 shouldBe should之类的assert.</p><h2 id="SdkSearch"><a href="#SdkSearch" class="headerlink" title="SdkSearch "></a><a href="https://github.com/JakeWharton/SDKSearch" target="_blank" rel="noopener">SdkSearch </a></h2><p>Jake Wharton大哥的android app跟chrome扩展,查询android sdk的.</p><h2 id="ketro"><a href="#ketro" class="headerlink" title="ketro "></a><a href="https://smilecs.github.io/ketro/" target="_blank" rel="noopener">ketro </a></h2><p>Retrofit + LiveData的组合.</p><h2 id="KDispatcher"><a href="#KDispatcher" class="headerlink" title="KDispatcher "></a><a href="https://github.com/Rasalexman/KDispatcher" target="_blank" rel="noopener">KDispatcher </a></h2><p>Kotlin轻量级Event Bus</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Kotlin" scheme="http://talentprince.github.io/tags/Kotlin/"/>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin Delegate" scheme="http://talentprince.github.io/tags/Kotlin-Delegate/"/>
    
      <category term="Kotlin Test" scheme="http://talentprince.github.io/tags/Kotlin-Test/"/>
    
      <category term="Gradle" scheme="http://talentprince.github.io/tags/Gradle/"/>
    
      <category term="LiveData" scheme="http://talentprince.github.io/tags/LiveData/"/>
    
      <category term="MotionLayout" scheme="http://talentprince.github.io/tags/MotionLayout/"/>
    
      <category term="Shortcut" scheme="http://talentprince.github.io/tags/Shortcut/"/>
    
      <category term="Kotlin Eventbus" scheme="http://talentprince.github.io/tags/Kotlin-Eventbus/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #318</title>
    <link href="http://talentprince.github.io/2018/07/15/Android-Weekly-Issue-318/"/>
    <id>http://talentprince.github.io/2018/07/15/Android-Weekly-Issue-318/</id>
    <published>2018-07-15T01:00:01.000Z</published>
    <updated>2020-06-22T09:44:59.474Z</updated>
    
    <content type="html"><![CDATA[<p>July 15th, 2018</p><h2 id="Android-Weekly-Issue-318"><a href="#Android-Weekly-Issue-318" class="headerlink" title="Android Weekly Issue #318"></a><a href="http://androidweekly.net/issues/issue-318" target="_blank" rel="noopener">Android Weekly Issue #318</a></h2><p>本期内容包括Jetpack NavigationUI的介绍, FAT AAR的讨论, Realm迁移到Kotlin的方案,以及如何通过MVI+DataBinding来写程序.还包含DSL改造Android Dialog以及Kotlin scope function的详细解读.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="Android-Jetpack-NavigationUI"><a href="#Android-Jetpack-NavigationUI" class="headerlink" title="Android Jetpack - NavigationUI "></a><a href="https://proandroiddev.com/android-jetpack-navigationui-a7c9f17c510e" target="_blank" rel="noopener">Android Jetpack - NavigationUI </a></h2><p>文章简单介绍了如何将NavigationView或者BottomNavigation与JetPack提供的Navigation控件连起来,通过定义<navigation> xml来实现自动跳转.</navigation></p><h2 id="Why-We-Need-“fat”-AARs-for-Android-Libraries"><a href="#Why-We-Need-“fat”-AARs-for-Android-Libraries" class="headerlink" title="Why We Need “fat” AARs for Android Libraries "></a><a href="https://handstandsam.com/2018/07/13/why-we-need-fat-aars-for-android-libraries/" target="_blank" rel="noopener">Why We Need “fat” AARs for Android Libraries </a></h2><p>Gradle aar不支持打包所有依赖,一般情况下可以使用一个叫做FAT aar的插件,但是已经不更新了.</p><p>还可以通过transitive来让gradle下载依赖,但是作者的疑问在于如果依赖也是不公开的就没办法了.</p><p>Google已经表示3.3会考虑加这个功能.</p><h2 id="Maintainable-Architecture-–-UI-Layer"><a href="#Maintainable-Architecture-–-UI-Layer" class="headerlink" title="Maintainable Architecture – UI Layer "></a><a href="https://blog.stylingandroid.com/maintainable-architecture-five-day-forecast-ui-layer/" target="_blank" rel="noopener">Maintainable Architecture – UI Layer </a></h2><p>继上次介绍数据层,这篇文章介绍了一个Weather App如何使用MVVM实现UI Layer.</p><h2 id="Migrating-your-Realm-to-Kotlin-–-Blue-Apron-Engineering"><a href="#Migrating-your-Realm-to-Kotlin-–-Blue-Apron-Engineering" class="headerlink" title="Migrating your Realm to Kotlin – Blue Apron Engineering "></a><a href="https://blog.blueapron.io/migrating-your-realm-to-kotlin-ee0fa5fc29b" target="_blank" rel="noopener">Migrating your Realm to Kotlin – Blue Apron Engineering </a></h2><p>文章介绍了如何将Realm迁移到Kotlin.</p><ul><li>为了不想让主键为空导致Kotlin nullable变量使用起来需要进行let之类的null check,所以给与初始化值,但是一定要加Migration逻辑保证数据库迁移正确.</li><li>可以通过一些Helper function加!!来避免Null check</li><li>Extension function包装关键字<code>in</code>,因为它是kotlin的关键字.</li></ul><h2 id="Model-View-Intent-amp-Data-Binding"><a href="#Model-View-Intent-amp-Data-Binding" class="headerlink" title="Model-View-Intent &amp; Data Binding "></a><a href="https://proandroiddev.com/model-view-intent-data-binding-39c7a6a6512f" target="_blank" rel="noopener">Model-View-Intent &amp; Data Binding </a></h2><p>作者通过一个登陆页面介绍了如何使用了MVI+DataBinding,适合初步了解MVI的机制以及Reducer的思想.</p><h2 id="Social-Network-Integration-on-Android"><a href="#Social-Network-Integration-on-Android" class="headerlink" title="Social Network Integration on Android "></a><a href="https://www.raywenderlich.com/191933/social-network-integration-on-android" target="_blank" rel="noopener">Social Network Integration on Android </a></h2><p>作者介绍了如何使用诸如FB Twitter这样的social media sdk来实现自己app内的登录与分享.</p><h2 id="Kotlin-Demystified-What-are-‘scope-functions’-and-why-are-they-special"><a href="#Kotlin-Demystified-What-are-‘scope-functions’-and-why-are-they-special" class="headerlink" title="Kotlin Demystified: What are ‘scope functions’ and why are they special? "></a><a href="https://medium.com/google-developers/kotlin-demystified-scope-functions-57ca522895b1" target="_blank" rel="noopener">Kotlin Demystified: What are ‘scope functions’ and why are they special? </a></h2><p>作者介绍了Kotlin里面的scope functions,其实就是let/run/with/apply/also.</p><p>作者的总结比较复杂,其实有一个比较简单的图可以清楚了解之间的关系.</p><p>如果你需要返回本身,就使用apply或者also,其区别就是使用this或者it.</p><p>如果你不需要返回本身,又想要做null判断,那就是用T.run或者let,当然区别也是this或者it.</p><p>如果你即不需要返回本身,又不用判断null,那就用with或者run,区别也是this或者it.</p><h2 id="Seedbank-—-discover-machine-learning-examples"><a href="#Seedbank-—-discover-machine-learning-examples" class="headerlink" title="Seedbank — discover machine learning examples "></a><a href="https://medium.com/tensorflow/seedbank-discover-machine-learning-examples-2ff894542b57" target="_blank" rel="noopener">Seedbank — discover machine learning examples </a></h2><p>可以在线的试一试Machine Learning</p><h2 id="From-Java-Builders-to-Kotlin-DSLs"><a href="#From-Java-Builders-to-Kotlin-DSLs" class="headerlink" title="From Java Builders to Kotlin DSLs "></a><a href="https://kotlinexpertise.com/java-builders-kotlin-dsls/" target="_blank" rel="noopener">From Java Builders to Kotlin DSLs </a></h2><p>教大家如何把Dialog Builder改造成Kotlin DSL,使用起来非常炫酷.</p><p>其实大家也都清楚了,就是通过Extension Function.</p><p>具体可以去看看作者的对比,DSL化后使用起来跟CSS一样,花括号套起来就实现了Dialog.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">draw &#123;</span><br><span class="line">    drawerLayout = xxxx</span><br><span class="line">    onItemClick &#123;</span><br><span class="line">        xxxxx</span><br><span class="line">    &#125;</span><br><span class="line">    onOpen &#123;</span><br><span class="line">        Toast.xxxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="android-face-detector"><a href="#android-face-detector" class="headerlink" title="android-face-detector "></a><a href="https://github.com/husaynhakeem/android-face-detector" target="_blank" rel="noopener">android-face-detector </a></h2><p>实时面部识别的lib,使用的Firebase ML kit.</p><h2 id="UnderlinePageIndicator"><a href="#UnderlinePageIndicator" class="headerlink" title="UnderlinePageIndicator "></a><a href="https://github.com/dcampogiani/UnderlinePageIndicator" target="_blank" rel="noopener">UnderlinePageIndicator </a></h2><p>类似于系统design的TabLayout那种效果.</p><h2 id="Seedbank"><a href="#Seedbank" class="headerlink" title="Seedbank "></a><a href="https://tools.google.com/seedbank/" target="_blank" rel="noopener">Seedbank </a></h2><p>在线测试ML的.</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="Realm" scheme="http://talentprince.github.io/tags/Realm/"/>
    
      <category term="Kotlin DSL" scheme="http://talentprince.github.io/tags/Kotlin-DSL/"/>
    
      <category term="MVI" scheme="http://talentprince.github.io/tags/MVI/"/>
    
      <category term="DataBinding" scheme="http://talentprince.github.io/tags/DataBinding/"/>
    
      <category term="Jetpack" scheme="http://talentprince.github.io/tags/Jetpack/"/>
    
      <category term="Navigation" scheme="http://talentprince.github.io/tags/Navigation/"/>
    
      <category term="AAR" scheme="http://talentprince.github.io/tags/AAR/"/>
    
      <category term="Scope Functions" scheme="http://talentprince.github.io/tags/Scope-Functions/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #317</title>
    <link href="http://talentprince.github.io/2018/07/08/Android-Weekly-Issue-317/"/>
    <id>http://talentprince.github.io/2018/07/08/Android-Weekly-Issue-317/</id>
    <published>2018-07-08T11:00:01.000Z</published>
    <updated>2020-06-22T09:44:59.474Z</updated>
    
    <content type="html"><![CDATA[<p>July 8th, 2018</p><h2 id="Android-Weekly-Issue-317"><a href="#Android-Weekly-Issue-317" class="headerlink" title="Android Weekly Issue #317"></a><a href="http://androidweekly.net/issues/issue-317" target="_blank" rel="noopener">Android Weekly Issue #317</a></h2><p>本期主要内容包括”重磅”的Udacity放弃RN(其实是因为他们RN写的那个Feature不要了),还包括如七部使用Google Page Lib,如何用Room设计与创建可维护的数据库等Code Guide的文章,以及Android P字体渲染,放大镜,Google新版Universal Music Play Sample,还有Retrofit如何工作,如何通过Kotlin Extension Generation来改善Dagger Butterknife使用体验,等等.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="State-of-Kotlin"><a href="#State-of-Kotlin" class="headerlink" title="State of Kotlin "></a><a href="https://pusher.com/state-of-kotlin" target="_blank" rel="noopener">State of Kotlin </a></h2><p>Kotlin状态的一些列数据,包括它的使用率,渗透率,在项目中的应用率等多种多样的数据,并且可以订阅.</p><p>一切数据表明,Kotlin在过去的一年中发展迅速,使用量Double,并且好评如潮.</p><h2 id="How-does-Retrofit-work"><a href="#How-does-Retrofit-work" class="headerlink" title="How does Retrofit work "></a><a href="https://medium.com/@theneckmaster/how-does-retrofit-work-6ecad1bb683b" target="_blank" rel="noopener">How does Retrofit work </a></h2><p>文章讲述了Retrofit如何工作,实际上是通过Proxy而非Processor去生成代码来实现的.文章表示在运行速度与编译速度上的Compromise是一个值得思考的问题.</p><h2 id="Exploring-Android-P-Magnifier"><a href="#Exploring-Android-P-Magnifier" class="headerlink" title="Exploring Android P: Magnifier "></a><a href="https://medium.com/@hitherejoe/exploring-android-p-magnifier-ddfd06bdecbe" target="_blank" rel="noopener">Exploring Android P: Magnifier </a></h2><p>Android P提供了放大镜功能,并且TextView默认就实现了.<br>国内用户应该不是很陌生,几年前国内的一些大Android浏览器厂商在WebView里面也有类似的功能,不过主要是Android copy了 iOS的默认属性…</p><h2 id="Tracking-Android-app-metrics"><a href="#Tracking-Android-app-metrics" class="headerlink" title="Tracking Android app metrics "></a><a href="https://medium.com/@emmaguy/tracking-android-app-metrics-431cbea2113d" target="_blank" rel="noopener">Tracking Android app metrics </a></h2><p>文章介绍了CI上使用<a href="http://www.stathat.com/manual/start" target="_blank" rel="noopener">StatHat</a>上传APK的一些数据,比如size等,然后发现问题后通过<a href="http://danger.systems/ruby/" target="_blank" rel="noopener">Danger</a>给Github的PR上面发出报警.</p><p>这两个都是Ruby的应用.</p><h2 id="Kotlin-extension-function-generation"><a href="#Kotlin-extension-function-generation" class="headerlink" title="Kotlin extension function generation "></a><a href="https://medium.com/the-fabulous/kotlin-extension-methods-generation-15b5e6499dc8" target="_blank" rel="noopener">Kotlin extension function generation </a></h2><p>文章介绍了自己给Dagger与Butterknife写的ktx.</p><p>由于Dagger使用了生成文件进行注入,所以必须先编译一边才能通过Compiler生成文件,使用起来不便.</p><p>而ButterKnife使用了反射通过类名将自己Generate的辅助类在运行时创建,我们想消除这个反射.</p><p>这些原因都因为Processor只能生成文件,而无法改变已有文件.</p><p>所以作者使用了Kotlin Extension,首先在Lib里定义了一些Mock的接口,所以编译之前可以调用这些空实现.而在编译过程中,Compiler会生成对应的扩展方法,这样Dagger与Butterknife的问题都得以解决.</p><h2 id="What’s-new-for-text-in-Android-P"><a href="#What’s-new-for-text-in-Android-P" class="headerlink" title="What’s new for text in Android P "></a><a href="https://android-developers.googleblog.com/2018/07/whats-new-for-text-in-android-p.html?linkId=53827942" target="_blank" rel="noopener">What’s new for text in Android P </a></h2><p>Android P在TextView上下了狠功夫,增加了很多功能.</p><ul><li>PrecomputedText</li></ul><p>复杂字体Font在显示的时候实际上90%的时间都耗费在Measure计算上, 可以在后台线程通过<code>PrecomputedText</code>计算,然后在UI线程set</p><ul><li>Magnifier</li></ul><p>放大镜,上篇有提到.TextView自己默认实现了.</p><ul><li>Smart Linkify</li></ul><p>TextView方按选中可以通过Google的ML处理解析,提供可能相关的应用显示在Copy Cut Paste旁边,这一切都是通过<code>TextClassifier</code>实现的.</p><ul><li>Line Height &amp; Baseline Alignment</li></ul><p>提供了几个Attribute控制文字行高,以及baseline的top与bottom margin.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app:lineHeight</span><br><span class="line">app:firstBaselineToTopHeight</span><br><span class="line">app:lastBaselineToBottomHeight</span><br></pre></td></tr></table></figure><h2 id="React-Native-A-retrospective-from-the-mobile-engineering-team-at-Udacity"><a href="#React-Native-A-retrospective-from-the-mobile-engineering-team-at-Udacity" class="headerlink" title="React Native: A retrospective from the mobile-engineering team at Udacity"></a><a href="https://engineering.udacity.com/react-native-a-retrospective-from-the-mobile-engineering-team-at-udacity-89975d6a8102" target="_blank" rel="noopener">React Native: A retrospective from the mobile-engineering team at Udacity</a></h2><p>Udacity也放弃了RN,看了整片博客,感觉是他们可能只是为了凑个热度.</p><p>首先他们放弃的最主要原因是他们就一个Feature用了RN,而且当时也是因为它很独立,然后尝试了RN,现在这个Feature不用了,就删掉了.</p><p>然后他们的Android Dev细数了RN的十宗罪,但是都是我们大概能想到的.</p><p>比如实际上两个平台尤其android还是需要通过改code来修bug或者特殊需求,RN与native互通麻烦,RN导致CI编译长,包增大,启动变慢,RN文档欠缺,代码变更太快,自身bug多,不同设备不同表现,遇到问题常常需要改源码等等等等.</p><p>而之所以当初要使用,主要原因是为了省事,可惜后来发现还是费事了,所以以后再也不会考虑RN了.</p><h2 id="Automated-testing-will-set-your-engineering-team-free"><a href="#Automated-testing-will-set-your-engineering-team-free" class="headerlink" title="Automated testing will set your engineering team free "></a><a href="https://medium.com/azimolabs/automated-testing-will-set-your-engineering-team-free-a89467c40731" target="_blank" rel="noopener">Automated testing will set your engineering team free </a></h2><p>作者介绍了他们的应用是如何保证质量的,答案就是写测试,一般feature手工只测一遍,剩下就得自动化测试.</p><p>测试他们分为三类, UT是开发来写, 基本覆盖每一个函数,集成测试用Robolectric是QA负责来写,End to End test使用Espresso,Instrument Test等,整个跑下来不能超过三小时.</p><h2 id="Compiler-based-security-mitigations-in-Android-P"><a href="#Compiler-based-security-mitigations-in-Android-P" class="headerlink" title="Compiler-based security mitigations in Android P "></a><a href="https://android-developers.googleblog.com/2018/06/compiler-based-security-mitigations-in.html?linkId=53786461" target="_blank" rel="noopener">Compiler-based security mitigations in Android P </a></h2><p>从Android P开始基于Clang编译器做了很多优化,提升了稳定性,降低了被攻击的风险.</p><p>如CFI (Control Flow Integrity<br>) 技术,主要是增加了虚函数指针偏移指向地址的检查,如果发现指向非法地址就会终止编译.</p><p>IOS (Integer Overflow Sanitization<br>) 技术会检测有符号或者无符号的Integer在算法中溢出的问题,并且优化后运用到了一些库的编译中,如libui, libnl,libexif等…</p><h2 id="7-steps-to-implement-Paging-library-in-Android"><a href="#7-steps-to-implement-Paging-library-in-Android" class="headerlink" title="7 steps to implement Paging library in Android "></a><a href="https://proandroiddev.com/8-steps-to-implement-paging-library-in-android-d02500f7fffe" target="_blank" rel="noopener">7 steps to implement Paging library in Android </a></h2><p>文章介绍了如何使用Google Architecture Component里面的Page来实现分页加载.</p><p>总共有七步,关键是实现PageKeyedDataSource接口封装MutableLiveData. 实现DataSource.Factory将DataSource封装成Factory.</p><p>然后就可以通过LivePagedListBuilder来生成数据了.</p><h2 id="A-New-Universal-Music-Player"><a href="#A-New-Universal-Music-Player" class="headerlink" title="A New Universal Music Player "></a><a href="https://android-developers.googleblog.com/2018/06/a-new-universal-music-player.html?linkId=53783436" target="_blank" rel="noopener">A New Universal Music Player </a></h2><p>鉴于大家对Google的Universal Music Player的喜爱,推出V2版,采用Kotlin与MVVM的架构,但是还有一些小功能没有加进来.</p><h2 id="Publishing-your-library-to-jCenter-from-Android-Studio"><a href="#Publishing-your-library-to-jCenter-from-Android-Studio" class="headerlink" title="Publishing your library to jCenter from Android Studio "></a><a href="https://android.jlelse.eu/publishing-your-android-kotlin-or-java-library-to-jcenter-from-android-studio-1b24977fe450" target="_blank" rel="noopener">Publishing your library to jCenter from Android Studio </a></h2><p>作者在网上找如何上传jcenter,找了很多说法不一的,所以一怒之下自己写了一篇.</p><h2 id="Maintainable-Architecture-–-Five-Day-Forecast-Data-Layer"><a href="#Maintainable-Architecture-–-Five-Day-Forecast-Data-Layer" class="headerlink" title="Maintainable Architecture – Five Day Forecast Data Layer "></a><a href="https://blog.stylingandroid.com/maintainable-architecture-five-day-forecast-data-layer/" target="_blank" rel="noopener">Maintainable Architecture – Five Day Forecast Data Layer </a></h2><p>作者通过实现一个天气预报软件的数据库,来介绍如何设计以及使用正确的方案来确保软件架构正确与维护的成本.</p><p>PS:使用的是Room.</p><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="RecyclerView-FastScroller"><a href="#RecyclerView-FastScroller" class="headerlink" title="RecyclerView-FastScroller "></a><a href="https://github.com/quiph/RecyclerView-FastScroller" target="_blank" rel="noopener">RecyclerView-FastScroller </a></h2><p>Kotlin写的快速滑动的滚动条,按照首字母.</p><h2 id="vector-analog-clock"><a href="#vector-analog-clock" class="headerlink" title="vector-analog-clock "></a><a href="https://github.com/TurkiTAK/vector-analog-clock" target="_blank" rel="noopener">vector-analog-clock </a></h2><p>Vector实现的石英表,适配各种屏幕.</p><h2 id="androme"><a href="#androme" class="headerlink" title="androme "></a><a href="https://github.com/anpham6/androme" target="_blank" rel="noopener">androme </a></h2><p>可以将带JS的HTML5页面转换为多个Android Layout.</p><h2 id="android-UniversalMusicPlayer"><a href="#android-UniversalMusicPlayer" class="headerlink" title="android-UniversalMusicPlayer "></a><a href="https://github.com/googlesamples/android-UniversalMusicPlayer" target="_blank" rel="noopener">android-UniversalMusicPlayer </a></h2><p>Google重写的UAMP</p><h2 id="LazyDatePicker"><a href="#LazyDatePicker" class="headerlink" title="LazyDatePicker. "></a><a href="https://github.com/lopspower/LazyDatePicker" target="_blank" rel="noopener">LazyDatePicker. </a></h2><p>替代系统DatePicker的一个第三方组件.</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="Jetpack" scheme="http://talentprince.github.io/tags/Jetpack/"/>
    
      <category term="Page" scheme="http://talentprince.github.io/tags/Page/"/>
    
      <category term="React Native" scheme="http://talentprince.github.io/tags/React-Native/"/>
    
      <category term="Kotlin Extension" scheme="http://talentprince.github.io/tags/Kotlin-Extension/"/>
    
      <category term="Android P" scheme="http://talentprince.github.io/tags/Android-P/"/>
    
      <category term="Universal Music Player" scheme="http://talentprince.github.io/tags/Universal-Music-Player/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #316</title>
    <link href="http://talentprince.github.io/2018/07/01/Android-Weekly-Issue-316/"/>
    <id>http://talentprince.github.io/2018/07/01/Android-Weekly-Issue-316/</id>
    <published>2018-07-01T11:00:01.000Z</published>
    <updated>2020-06-22T09:44:59.474Z</updated>
    
    <content type="html"><![CDATA[<p>July 1st, 2018</p><h2 id="Android-Weekly-Issue-316"><a href="#Android-Weekly-Issue-316" class="headerlink" title="Android Weekly Issue #316"></a><a href="http://androidweekly.net/issues/issue-316" target="_blank" rel="noopener">Android Weekly Issue #316</a></h2><p>本期内容包含教你使用Kotlin通过Annotation Processor生成代码文件, JetPack中的Android KTX, 以及升级到Target26所需要注意的东西,还包含如何使用KTX简化AndroidX里面的Slice的Build,以及如何通过MotionLayout方便实现动画的系列,还有MLKit中扫条形码的Lib介绍,以及一些譬如Kotlin MVVM, Koin依赖注入做Test, UI Test去除动画,入行一年感受,DialogFLow来做面试机器人等等的有趣内容.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="Generating-Code-via-Annotations-in-Kotlin"><a href="#Generating-Code-via-Annotations-in-Kotlin" class="headerlink" title="Generating Code via Annotations in Kotlin "></a><a href="https://willowtreeapps.com/ideas/generating-code-via-annotations-in-kotlin" target="_blank" rel="noopener">Generating Code via Annotations in Kotlin </a></h2><p>文章介绍了如果用Kotlin来写Annotation Processor生成代码.</p><p>两个关键的Lib</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\\ Code generation library for kotlin, highly recommended</span><br><span class="line">implementation &apos;com.squareup:kotlinpoet:0.7.0&apos;</span><br><span class="line"></span><br><span class="line">\\ configuration generator for service providers</span><br><span class="line">implementation &quot;com.google.auto.service:auto-service:1.0-rc4&quot;</span><br><span class="line">kapt &quot;com.google.auto.service:auto-service:1.0-rc4&quot;</span><br></pre></td></tr></table></figure><ul><li>首先需要通过<code>annotation class</code>定义自己的Annotation.</li><li>其实继承<code>AbstractProcessor</code>实现自己的Processor, 通过<code>@AutoService</code>注册到系统的<code>Processor.class</code>上去.复写<code>process</code>方法生成代码.</li></ul><h2 id="Android-KTX-Android-development-with-Kotlin"><a href="#Android-KTX-Android-development-with-Kotlin" class="headerlink" title="Android KTX - Android development with Kotlin "></a><a href="https://kotlinexpertise.com/android-ktx-kotlin/" target="_blank" rel="noopener">Android KTX - Android development with Kotlin </a></h2><p>之前已经有不少Kotlin的语法糖了,这次JetPack推出的是Android官方的KTX,其主要实现原理就是通过给已有的Framework添加很多方法或者变量的Extension.</p><p>类似于Anko, 支持的列表在<a href="https://developer.android.com/kotlin/ktx" target="_blank" rel="noopener">这里</a>,当然对于类似的Project, 学习是一个过程.</p><h2 id="Remember-remember…-to-target-API-26-on-November"><a href="#Remember-remember…-to-target-API-26-on-November" class="headerlink" title="Remember, remember… to target API 26 on November! "></a><a href="https://medium.com/@fabionegri/remember-remember-to-target-api-26-on-november-7ce4fdde2c08" target="_blank" rel="noopener">Remember, remember… to target API 26 on November! </a></h2><p>文章列举了要逐步将Target升级到26所需要注意的东西.</p><p>Marshmallow 6.0 Level 23</p><ul><li>Runtime Permission</li><li>删除了Apache Http Client</li><li>从OpenSSL到BoringSSL</li><li>删除<code>Notification.setLatestEventInfo()</code></li></ul><p>Nougat 7.0 Level 24</p><ul><li>限制后台网络,删除了<code>CONNECTIVITY_ACTION</code>广播通知,以及Intent中的 <code>ACTION_NEW_PICTURE</code>与<code>ACTION_NEW_VIDEO</code>.</li><li>App外无法通过<code>file://</code>访问私有文件.</li><li>链接非NDK的Lib不行了.</li></ul><p>Nougat 7.1 Level 25</p><ul><li>App Shortcuts</li><li>支持Image到Keyboard里,通过<a href="https://developer.android.com/guide/topics/text/image-keyboard" target="_blank" rel="noopener">Commit Content API</a>.</li><li>添加了<code>android:roundIcon</code></li></ul><p>Oreo 8.0 Leve26</p><ul><li>必须通过<code>startForeground</code>和<code>startForegroundService</code>来启动前台的服务,无法启动后台服务.</li><li>移除了几乎所有的隐式广播,除了<a href="https://developer.android.com/guide/components/broadcast-exceptions" target="_blank" rel="noopener">部分</a>.</li><li>后台位置信息收到限制,推荐使用GCM的<code>FusedLocationProviderClient</code>或者<code>Geofencing</code>.</li><li>必须制定Notification Channel,否则收不到通知.</li></ul><h2 id="My-first-weeks-as-an-Android-Dev"><a href="#My-first-weeks-as-an-Android-Dev" class="headerlink" title="My first weeks as an Android Dev "></a><a href="https://engineering.udacity.com/my-first-weeks-as-an-android-dev-e956ee49418d" target="_blank" rel="noopener">My first weeks as an Android Dev </a></h2><p>介绍了自己第一周做Android开发的经历,面对自己的任务,接触到了譬如<code>Design</code>,<code>ConstraintLayout</code>,<code>Data Binding &amp; ViewModel</code>, <code>DI</code>,以及<code>Kotlin</code>的东西,有点应接不暇.</p><h2 id="Espresso-animations-disabled-flag"><a href="#Espresso-animations-disabled-flag" class="headerlink" title="Espresso animations disabled flag "></a><a href="https://github.com/ghostbuster91/espresso-animations-disabled-test" target="_blank" rel="noopener">Espresso animations disabled flag </a></h2><p>通过设置flag来禁止测试中动画, 方便测试.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testOptions &#123;</span><br><span class="line">    animationsDisabled = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exploring-Firebase-MLKit-on-Android-Barcode-Scanning-Part-Three"><a href="#Exploring-Firebase-MLKit-on-Android-Barcode-Scanning-Part-Three" class="headerlink" title="Exploring Firebase MLKit on Android: Barcode Scanning (Part Three) "></a><a href="https://medium.com/@hitherejoe/exploring-firebase-mlkit-on-android-barcode-scanning-part-three-cc6f5921a108" target="_blank" rel="noopener">Exploring Firebase MLKit on Android: Barcode Scanning (Part Three) </a></h2><p>文章介绍了用Firebase的VisionBarcode来扫条形码.</p><h2 id="Introducing-Slice-Builders-KTX"><a href="#Introducing-Slice-Builders-KTX" class="headerlink" title="Introducing Slice Builders KTX "></a><a href="https://medium.com/google-developers/introducing-slice-builders-ktx-2218ebde356" target="_blank" rel="noopener">Introducing Slice Builders KTX </a></h2><p>Android Slice是最新推出的AndroidX里面的控件,主要是给Google Search App来提供一些类似Google Assistant的那种UI,支持静态与动态的布局.</p><p>KTX也推出了对该组件的支持,以便通过Kotlin来简化Slice Build使用过程.</p><p>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list(context, sliceUri, ListBuilder.INFINITY) &#123;</span><br><span class="line">        row &#123;</span><br><span class="line">           setTitle(&quot;Hello world&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Building-an-Action-to-Solve-a-Real-World-Problem-Part-1-Plan-amp-Design"><a href="#Building-an-Action-to-Solve-a-Real-World-Problem-Part-1-Plan-amp-Design" class="headerlink" title="Building an Action to Solve a Real World Problem: Part 1, Plan &amp; Design "></a><a href="https://medium.com/google-developers/building-an-action-to-solve-a-real-world-problem-part-1-plan-design-2a701fa004c8" target="_blank" rel="noopener">Building an Action to Solve a Real World Problem: Part 1, Plan &amp; Design </a></h2><p>通过Dialogflow等一系列技术搭建了一个给面试者出题的训练系统,根据对话提供不同的题目.</p><h2 id="Introduction-to-MotionLayout-part-I"><a href="#Introduction-to-MotionLayout-part-I" class="headerlink" title="Introduction to MotionLayout (part I) "></a><a href="https://medium.com/google-developers/introduction-to-motionlayout-part-i-29208674b10d" target="_blank" rel="noopener">Introduction to MotionLayout (part I) </a></h2><p>介绍了Google最新的ConstraintLayout 2.0的子类<code>MotionLayout</code>的使用,它可以通过在xml文件里定义的<code>MotionScene</code>来指定一些动画.</p><p>这些都是通过<code>TransitionManager</code>完成的,它会自己计算开始与结束之间的位置,完成动画,有点像Activity之间的SharedElement Transition Animation.</p><h2 id="Testing-with-Koin"><a href="#Testing-with-Koin" class="headerlink" title="Testing with Koin "></a><a href="https://proandroiddev.com/testing-with-koin-ade8a46eb4d" target="_blank" rel="noopener">Testing with Koin </a></h2><p>通过Koin依赖注入框架来简化Kotlin Test里面的mock注入.</p><h2 id="MVVM-with-Kotlin"><a href="#MVVM-with-Kotlin" class="headerlink" title="MVVM with Kotlin "></a><a href="https://proandroiddev.com/mvvm-with-kotlin-android-architecture-components-dagger-2-retrofit-and-rxandroid-1a4ebb38c699" target="_blank" rel="noopener">MVVM with Kotlin </a></h2><p>介绍了Kotlin下Android的MVVM的全套实践,包含了DataBinding, Retrofit, Dagger等等.</p><h2 id="Introducing-adb-enhanced-A-swiss-army-knife-for-Android-development"><a href="#Introducing-adb-enhanced-A-swiss-army-knife-for-Android-development" class="headerlink" title="Introducing adb-enhanced: A swiss army knife for Android development "></a><a href="https://ashishb.net/tech/introducing-adb-enhanced-a-swiss-army-knife-for-android-development/" target="_blank" rel="noopener">Introducing adb-enhanced: A swiss army knife for Android development </a></h2><p>一个Python的应用, enhance的adb,可以方便的进行clean安装,节能模式,doze模式的调试等等.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install adb-enhanced</span><br></pre></td></tr></table></figure><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="ColorPickerView"><a href="#ColorPickerView" class="headerlink" title="ColorPickerView "></a><a href="https://github.com/skydoves/ColorPickerView" target="_blank" rel="noopener">ColorPickerView </a></h2><p>一个选择颜色的picker view</p><h2 id="adb-enhanced"><a href="#adb-enhanced" class="headerlink" title="adb-enhanced "></a><a href="https://github.com/ashishb/adb-enhanced" target="_blank" rel="noopener">adb-enhanced </a></h2><p>上面介绍的加强型Adb</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="Google IO" scheme="http://talentprince.github.io/tags/Google-IO/"/>
    
      <category term="Kotlin Espresso" scheme="http://talentprince.github.io/tags/Kotlin-Espresso/"/>
    
      <category term="Navigation Architecture Component" scheme="http://talentprince.github.io/tags/Navigation-Architecture-Component/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #315</title>
    <link href="http://talentprince.github.io/2018/06/24/Android-Weekly-Issue-315/"/>
    <id>http://talentprince.github.io/2018/06/24/Android-Weekly-Issue-315/</id>
    <published>2018-06-24T07:00:01.000Z</published>
    <updated>2020-06-22T09:44:59.474Z</updated>
    
    <content type="html"><![CDATA[<p>June 24th, 2018</p><h2 id="Android-Weekly-Issue-315"><a href="#Android-Weekly-Issue-315" class="headerlink" title="Android Weekly Issue #315"></a><a href="http://androidweekly.net/issues/issue-315" target="_blank" rel="noopener">Android Weekly Issue #315</a></h2><p>本篇内容包括,Android P的优先级队列管理,Yelp性能测试系列最后一篇帧率监控,以及近期比较火的Airbnb下一步移动战略,还包含连接Clould IoT Core的Library介绍,ML Kit文字识别,与如何从AndroidJob迁移到WorkManager.还有一篇如何搭建面试机器人的介绍,以及尚在早期的Kotlin Native跨平台数据库的概况等.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="Exploring-Android-P-Priority-Buckets"><a href="#Exploring-Android-P-Priority-Buckets" class="headerlink" title="Exploring Android P: Priority Buckets "></a><a href="https://medium.com/google-developer-experts/exploring-android-p-priority-buckets-d34d12059d36" target="_blank" rel="noopener">Exploring Android P: Priority Buckets </a></h2><p>这次Google IO Android P推出了Priority Buckets来提供更好的电池管理.</p><p>通过使用频率,将App分为<code>Active</code>,<code>Working Set</code>,<code>Frequent</code>,<code>Rare</code>,<code>Never</code>几个级别, 不同级别会对Jobs还有Alarms有不同的最大延时.</p><p>分组是动态改变的.</p><h2 id="My-checklist-for-fixing-build-issues"><a href="#My-checklist-for-fixing-build-issues" class="headerlink" title="My checklist for fixing build issues "></a><a href="https://medium.com/@mikewolfson/android-studio-is-borked-my-checklist-for-fixing-build-issues-e41a9dd8cba8" target="_blank" rel="noopener">My checklist for fixing build issues </a></h2><p>作者的AndroidTest里面Import都无法识别了,提示<code>Cannot find symbol</code>,解决办法是清掉一些缓存.</p><p>包括本地Gradle,Project idea与gradle,以及AS的Cache…而后解决了.</p><h2 id="Understanding-the-emotions-of-users-through-NLP"><a href="#Understanding-the-emotions-of-users-through-NLP" class="headerlink" title="Understanding the emotions of users through NLP "></a><a href="https://medium.com/azimolabs/understanding-the-emotions-of-users-through-natural-language-processing-4535ff90f50b" target="_blank" rel="noopener">Understanding the emotions of users through NLP </a></h2><p>作者讲解了通过Firebase functions platform + Google Cloud Natural搭建一个App的客服系统.</p><h2 id="Introducing-Billingx"><a href="#Introducing-Billingx" class="headerlink" title="Introducing Billingx "></a><a href="https://ryanharter.com/blog/introducing-billingx/" target="_blank" rel="noopener">Introducing Billingx </a></h2><p>Google唯一渠道实现App内购买的API就是Billing Library,但是对于测试者来说使用起来很麻烦,而且直到2018 Google I/O也没有新的动作.</p><p>之前也分享过一个叫做<a href="https://github.com/NYTimes/Register" target="_blank" rel="noopener">Register</a>,通过Mock,实现了本地的测试,但是会在Production Apk中引入没必要的代码.</p><p>作者自己封装了一个叫<a href="https://github.com/pixiteapps/billingx" target="_blank" rel="noopener">BillingX</a>的库,提供了空实现给Production版,通过<code>releaseImplementation</code>引入.</p><h2 id="Text-Recognition-with-ML-Kit"><a href="#Text-Recognition-with-ML-Kit" class="headerlink" title="Text Recognition with ML Kit "></a><a href="https://www.raywenderlich.com/197292/text-recognition-with-ml-kit" target="_blank" rel="noopener">Text Recognition with ML Kit </a></h2><p>介绍了这次ML Kit中的云端文字识别API,通过Firebase服务Enable,可以实现图片中文字的<code>in-cloud text recognition</code>,不想掏钱可以试用哦,选择Blaze Plan按需缴费,头1000次请求免费的.</p><h2 id="Publishing-your-Android-Kotlin-or-Java-library-to-mavenCentral"><a href="#Publishing-your-Android-Kotlin-or-Java-library-to-mavenCentral" class="headerlink" title="Publishing your Android, Kotlin or Java library to mavenCentral "></a><a href="https://medium.com/@vanniktech/publishing-your-android-kotlin-or-java-library-to-mavencentral-e22f343b9659" target="_blank" rel="noopener">Publishing your Android, Kotlin or Java library to mavenCentral </a></h2><p>大家平时常用的<a href="https://github.com/chrisbanes/gradle-mvn-push" target="_blank" rel="noopener">Chris Banes</a>的脚本要迁移到Kotlin上还要做一些改动,作者自己弄了一份,并且把它做成了plugin,只需要加到自己的plugin dependencies里面就行了.</p><h2 id="Performance-Improvements-for-Search-on-The-Yelp-Android-App-Part-3"><a href="#Performance-Improvements-for-Search-on-The-Yelp-Android-App-Part-3" class="headerlink" title="Performance Improvements for Search on The Yelp Android App - Part 3 "></a><a href="https://engineeringblog.yelp.com/2018/06/android-search-perf-improvements-part-3.html" target="_blank" rel="noopener">Performance Improvements for Search on The Yelp Android App - Part 3 </a></h2><p>本篇为系列文章的最后一部分,主要介绍了CI上面的Performance如何检测系统帧率变化.</p><p>Yelp通过<a href="https://developer.android.com/reference/android/view/FrameMetrics.html" target="_blank" rel="noopener">FrameMetrics API</a>来获取帧率信息,低于16ms就是快帧,高于就是慢帧,他们会对装有信息的JSON进行分析,其中dopped frame会列出各个部分所消耗的时间.</p><p>最后又总结了整个性能提升过程中所采取的措施,除去这节的Performance Monitoring来防止Regression导致的问题,还包括之前的减少主线程工作,异步inflating layout,对搜索结果view model的caching等.</p><h2 id="Android-Things-client-library-for-Google-Cloud-IoT-Core"><a href="#Android-Things-client-library-for-Google-Cloud-IoT-Core" class="headerlink" title="Android Things client library for Google Cloud IoT Core "></a><a href="https://android-developers.googleblog.com/2018/06/android-things-client-library-for.html?linkId=53347194" target="_blank" rel="noopener">Android Things client library for Google Cloud IoT Core </a></h2><p>为广大IoT爱好者带来福音,client library提供了硬件设备轻松连接google Cloud IoT Core,通过几行代码,便可以轻松的上传传感器信息到云端进行控制.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.google.android.things:cloud-iot-core:1.0.0&apos;</span><br></pre></td></tr></table></figure><p>由于硬件设备所在的环境多变,library还提供了很多错误处理机制,数据信息缓存等.</p><h2 id="How-to-Migrate-from-Android-Job-to-WorkManager"><a href="#How-to-Migrate-from-Android-Job-to-WorkManager" class="headerlink" title="How to Migrate from Android-Job to WorkManager "></a><a href="https://articles.caster.io/android/how-to-migrate-from-android-job-to-workmanager/" target="_blank" rel="noopener">How to Migrate from Android-Job to WorkManager </a></h2><p>作者以前用的是Evernote搞的AndroidJob,本篇介绍了他如何迁移到google最新的WorkManager上面.</p><p>基本使用方法跟AndroidJob类似,Woker通过<code>OneTimeWorkRequestBuilder</code>去build单发事件,通过<code>PeriodicWorkRequestBuilder</code>去build周期性事件,通过<code>setInputData</code>可以添加一些数据,通过<code>setConstraints</code>添加约束,如网络要求等,通过<code>WorkManager.getInstance().enqueue</code>讲Work加入队列.</p><p>Work触发时会执行<code>doWork</code>方法, 返回值<code>Worker.Result.SUCCESS</code>表示成功,类对象<code>inputData</code>可以获取传进来的数据.</p><h2 id="What’s-Next-for-Mobile-at-Airbnb"><a href="#What’s-Next-for-Mobile-at-Airbnb" class="headerlink" title="What’s Next for Mobile at Airbnb "></a><a href="https://medium.com/airbnb-engineering/whats-next-for-mobile-at-airbnb-5e71618576ab" target="_blank" rel="noopener">What’s Next for Mobile at Airbnb </a></h2><p>作者介绍了在Airbnb放弃RN之后下一步要走的路线.</p><ul><li>通过<a href="https://airbnb.design/building-a-visual-language/" target="_blank" rel="noopener">DSL</a>定义跨平台统一的设计语言,实现<code>Server-Driven Rendering</code>,通过自己开发的基于Sketch的设计软件<a href="https://github.com/airbnb/Lona/" target="_blank" rel="noopener">Lona</a>做到一套设计生成不同平台的代码.当然这一切都是在Build的时候做的.</li><li>基于之前的<a href="https://github.com/airbnb/epoxy" target="_blank" rel="noopener">Epoxy</a>,推出新的<code>MvRx</code>,并且支持Android与iOS,Android上是对RecyclerView的封装,可以更方便的实现复杂List的渲染.</li><li>通过<a href="https://developer.android.com/studio/build/build-variants#product-flavors" target="_blank" rel="noopener">gradle product flavors</a>来实现编译速度的提升,只去下载自己关心的Module.</li></ul><h2 id="SQLite-on-Kotlin-Native"><a href="#SQLite-on-Kotlin-Native" class="headerlink" title="SQLite on Kotlin/Native "></a><a href="https://medium.com/@kpgalligan/sqlite-on-kotlin-native-9bcf47854cae" target="_blank" rel="noopener">SQLite on Kotlin/Native </a></h2><p><a href="https://github.com/touchlab/knarch.db/tree/96bb6a2e370bd90d2b42d46b23ba1b2e74b0d4ff" target="_blank" rel="noopener">Knarch</a>, Kotlin跨平台数据库的一个非常早起的版本.很多地方还不成熟,尤其是对Android的支持,如何架构还在讨论总,在使用过程中,多线程也是个问题.</p><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="SaveState"><a href="#SaveState" class="headerlink" title="SaveState "></a><a href="https://github.com/PrototypeZ/SaveState" target="_blank" rel="noopener">SaveState </a></h2><p>保存状态的一个库,相较于Icepick支持Kotlin.</p><h2 id="morph-bottom-navigation"><a href="#morph-bottom-navigation" class="headerlink" title="morph-bottom-navigation "></a><a href="https://github.com/tommybuonomo/morph-bottom-navigation" target="_blank" rel="noopener">morph-bottom-navigation </a></h2><p>基于Bottom Navigation的一个库,有比较好看的动画效果.</p><h2 id="gradle-maven-publish-plugin"><a href="#gradle-maven-publish-plugin" class="headerlink" title="gradle-maven-publish-plugin "></a><a href="https://github.com/vanniktech/gradle-maven-publish-plugin" target="_blank" rel="noopener">gradle-maven-publish-plugin </a></h2><p>支持kotlin的maven发布插件.</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="Priority Bucket" scheme="http://talentprince.github.io/tags/Priority-Bucket/"/>
    
      <category term="Cloud IoT Core" scheme="http://talentprince.github.io/tags/Cloud-IoT-Core/"/>
    
      <category term="ML Kit" scheme="http://talentprince.github.io/tags/ML-Kit/"/>
    
      <category term="WorkManager" scheme="http://talentprince.github.io/tags/WorkManager/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #310</title>
    <link href="http://talentprince.github.io/2018/06/13/Android-Weekly-Issue-310/"/>
    <id>http://talentprince.github.io/2018/06/13/Android-Weekly-Issue-310/</id>
    <published>2018-06-13T01:00:01.000Z</published>
    <updated>2020-06-22T09:44:59.474Z</updated>
    
    <content type="html"><![CDATA[<p>May 20th, 2018</p><h2 id="Android-Weekly-Issue-290"><a href="#Android-Weekly-Issue-290" class="headerlink" title="Android Weekly Issue #290"></a><a href="http://androidweekly.net/issues/issue-310" target="_blank" rel="noopener">Android Weekly Issue #290</a></h2><p>本期既有本次Google IO对于Play Console的更新简介, 又有数篇对于简化UI Test的工具与方法的介绍,还有JetPack Worker Manager的推介,以及如何仅仅通过Firebase快速搭建一个自己的Instgram小App,当然还有一篇关于Google最新的Navigation Architecture Component的介绍,精彩内容不容错过.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="Rxify-The-startWith-MVI-pitfall"><a href="#Rxify-The-startWith-MVI-pitfall" class="headerlink" title="Rxify : The startWith { MVI } pitfall "></a><a href="https://medium.com/@ragdroid/rxify-the-startwith-mvi-pitfall-68764ae8946d" target="_blank" rel="noopener">Rxify : The startWith { MVI } pitfall </a></h2><p>在实现MVI返回State Intent的时候, 可以通过startWith可以添加一些初始化状态,它就类似于concat,将一个新的Observable与之结合,再通过onErrorReturn返回一个错误的状态,保证我们的chain的完备性.</p><h2 id="Discover-everything-new-in-the-Google-Play-Console"><a href="#Discover-everything-new-in-the-Google-Play-Console" class="headerlink" title="Discover everything new in the Google Play Console "></a><a href="https://android-developers.googleblog.com/2018/05/io-2018-everything-new-in-google-play.html" target="_blank" rel="noopener">Discover everything new in the Google Play Console </a></h2><p>最新的GoogleIO更新了Play Console的新功能,有一些还是挺厉害的.</p><ul><li>App Bundle, 就是你的res可以根据设备加载,比如图片资源,对于xxxdpi的设备就下载一份,语言包也类似.</li><li>提升了质量检测过程, 通过100个内部测试机运行你upload的程序,还有各种report与analysis帮助你分析潜在问题.</li><li>dashboard以及一些数据呈现更加优化,还可以通过acquisition report获得更多信息,如用户从哪里得到的你的app等等.</li><li>提升用户订阅服务,通过Billing Library可以轻松实现订阅服务,在Subscriptions Center可以轻松管理用户的订阅订单,还有详细的report帮你分析多种订阅之间的时间,地点等等因素的关系.</li><li>八月份之前必须得Target到26了.</li></ul><h2 id="Kakao-how-to-make-UI-testing-great-again"><a href="#Kakao-how-to-make-UI-testing-great-again" class="headerlink" title="Kakao - how to make UI testing great again "></a><a href="https://medium.com/@ilyalim/kakao-how-to-make-ui-testing-great-again-19972cf13740" target="_blank" rel="noopener">Kakao - how to make UI testing great again </a></h2><p>Kakao是一个kotlin的UI测试框架,基于Espresso,可以大幅度简化使用Espresso的过程,通过Lambda以及Kakao内置的一些操作符,完成测试.</p><p>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> screen &#123;</span><br><span class="line">      content &#123; isVisible() &#125;</span><br><span class="line"></span><br><span class="line">      textViewSmall &#123;</span><br><span class="line">          isVisible()</span><br><span class="line">          hasAnyText()</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Best-Practices-for-Unit-Testing-in-Kotlin"><a href="#Best-Practices-for-Unit-Testing-in-Kotlin" class="headerlink" title="Best Practices for Unit Testing in Kotlin "></a><a href="https://blog.philipphauer.de/best-practices-unit-testing-kotlin/" target="_blank" rel="noopener">Best Practices for Unit Testing in Kotlin </a></h2><p>作者提了好几条建议来提升Kotlin测试的体验</p><ul><li>使用JUnit5的<code>@TestInstance(Lifecycle.PER_CLASS)</code>来避免出现一些静态field,这些静态field主要是为了保证在整个测试类中只初始化一次,而JUnit4每一个Test都会重新创建新的Class.取而代之的是可以使用<code>init{}</code>加<code>@BeforeEach</code>.</li><li>使用JUnit5的<code>@Nested</code>包装测试类中一些特殊的模块,使之更加清晰.</li><li>使用<code></code>(backticks)去自定义方法名.</li><li><a href="http://joel-costigliola.github.io/assertj/" target="_blank" rel="noopener">AssertJ</a>依旧好使.</li><li>使用<a href="https://github.com/nhaarman/mockito-kotlin" target="_blank" rel="noopener">Mokito-Kotlin</a>跟<a href="http://mockk.io/" target="_blank" rel="noopener">MockK</a>来做mock</li></ul><h2 id="Exploring-Moshi’s-Kotlin-Code-Gen"><a href="#Exploring-Moshi’s-Kotlin-Code-Gen" class="headerlink" title="Exploring Moshi’s Kotlin Code Gen "></a><a href="https://medium.com/@sweers/exploring-moshis-kotlin-code-gen-dec09d72de5e" target="_blank" rel="noopener">Exploring Moshi’s Kotlin Code Gen </a></h2><p>Moshi是一个JSON解析库,文章介绍了1.6版本使用了新的Kotlin代码生成器,更好的处理了类似<code>Mutablility</code>,<code>Nullability</code>,<code>in/out</code>等等的问题,感兴趣可以自己看一下.</p><h2 id="Life-with-without-services-and-WorkManager"><a href="#Life-with-without-services-and-WorkManager" class="headerlink" title="Life with/without services and WorkManager "></a><a href="https://medium.com/google-developer-experts/services-the-life-with-without-and-worker-6933111d62a6" target="_blank" rel="noopener">Life with/without services and WorkManager </a></h2><p>随着Android对于内存管理的越来越严格,首先是26以上Service无法在后台<code>startService</code>被限制,而系统提供的<code>JobScheduler</code>在23以下有问题,而<code>JobDispatcher</code>又需要Google Service…让人甚是苦恼.</p><p>值得高兴的是,Google最近推出的强大的JetPack里面的<code>WorkerManager</code>将解决这个问题.</p><p>它内部融合了<code>JobScheduer</code>,<code>JobDispather</code>,<code>AlarmManager</code>等等,并提供了两种Woker,<code>OneTime</code>跟<code>Periodic</code>.让后台操作变得非常轻松.</p><h2 id="A-year-as-Android-Engineer"><a href="#A-year-as-Android-Engineer" class="headerlink" title="A year as Android Engineer "></a><a href="https://proandroiddev.com/a-year-as-android-engineer-55e2a428dfc8" target="_blank" rel="noopener">A year as Android Engineer </a></h2><p>文章介绍了作者从一个QA转型为一个Android Dev,并找到新工作的经历,可以当故事看看…</p><h2 id="The-missing-migration-guide-to-the-Gradle-Kotlin-DSL"><a href="#The-missing-migration-guide-to-the-Gradle-Kotlin-DSL" class="headerlink" title="The missing migration guide to the Gradle Kotlin DSL "></a><a href="https://github.com/jnizet/gradle-kotlin-dsl-migration-guide" target="_blank" rel="noopener">The missing migration guide to the Gradle Kotlin DSL </a></h2><p>一个REAMME,介绍了如何从Gradle迁移到Kotlin DSL,喜欢Kotlin的朋友们可以对照着迁移了,一步两步.</p><h2 id="Build-an-Instagram-Like-Android-App-Using-Google-Firebase"><a href="#Build-an-Instagram-Like-Android-App-Using-Google-Firebase" class="headerlink" title="Build an Instagram-Like Android App Using Google Firebase "></a><a href="https://dragosholban.com/2018/05/13/build-an-instagram-like-android-app-using-google-firebase/" target="_blank" rel="noopener">Build an Instagram-Like Android App Using Google Firebase </a></h2><p>通过Firebase搭建一个类似Instgram的App.</p><p>通过Firebase Authenicate来实现登录认证,通过Firebase Storage来实现图片上传,通过Firebase Database来实现数据存储.</p><p>自己只需要实现简单的UI,便可以完成简易化的Ins,是不是很开森.</p><h2 id="A-problem-like-Navigation"><a href="#A-problem-like-Navigation" class="headerlink" title="A problem like Navigation "></a><a href="https://medium.com/a-problem-like-maria/a-problem-like-navigation-e9821625a70e" target="_blank" rel="noopener">A problem like Navigation </a></h2><p>介绍了Google最新推出的Navigation Archtecture Component,来处理Fragment之间的跳转,通过定义xml中的<code>action</code>,就可以完成跳转,通过定义<code>argument</code>就可以完成值传递,以及定义<code>deepLink</code>,可以轻松支持Deeplink.</p><h2 id="Pleasant-fun-painless-delightful-Espresso-testing-with-Kotlin"><a href="#Pleasant-fun-painless-delightful-Espresso-testing-with-Kotlin" class="headerlink" title="Pleasant fun painless delightful Espresso testing with Kotlin "></a><a href="https://medium.com/@Zhuinden/pleasant-fun-painless-delightful-espresso-testing-with-kotlin-3ffeda58d45c" target="_blank" rel="noopener">Pleasant fun painless delightful Espresso testing with Kotlin </a></h2><p>一个基于Kakao(Kotlin DSL for Espresso)的Kotlin Espresso库,用于简化UI test的书写.</p><p>如可以直接通过Id来索引View直接perform操作,而不必在通过<code>onView</code>…<code>withId</code>…<code>perform</code>来搞的很长.</p><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="MockK"><a href="#MockK" class="headerlink" title="MockK "></a><a href="http://mockk.io/ANDROID" target="_blank" rel="noopener">MockK </a></h2><p>kotlin的Mock lib</p><h2 id="espresso-helper"><a href="#espresso-helper" class="headerlink" title="espresso-helper "></a><a href="https://github.com/Zhuinden/espresso-helper" target="_blank" rel="noopener">espresso-helper </a></h2><p>Espresso的Kotlin封装</p><h2 id="Kakao"><a href="#Kakao" class="headerlink" title="Kakao "></a><a href="https://github.com/agoda-com/Kakao" target="_blank" rel="noopener">Kakao </a></h2><p>上面那个库基于的,也是对于Espresso的封装.</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="Google IO" scheme="http://talentprince.github.io/tags/Google-IO/"/>
    
      <category term="Kotlin Espresso" scheme="http://talentprince.github.io/tags/Kotlin-Espresso/"/>
    
      <category term="Navigation Architecture Component" scheme="http://talentprince.github.io/tags/Navigation-Architecture-Component/"/>
    
  </entry>
  
</feed>
