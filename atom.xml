<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Weyoung&#39;s Blog</title>
  
  <subtitle>Nothing can prevent is going to be</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://talentprince.github.io/"/>
  <updated>2020-10-27T04:30:36.661Z</updated>
  <id>http://talentprince.github.io/</id>
  
  <author>
    <name>Prince Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Refresh Clean Code</title>
    <link href="http://talentprince.github.io/2020/10/27/Refresh-Clean-Code/"/>
    <id>http://talentprince.github.io/2020/10/27/Refresh-Clean-Code/</id>
    <published>2020-10-27T04:26:45.000Z</published>
    <updated>2020-10-27T04:30:36.661Z</updated>
    
    <content type="html"><![CDATA[<p>这是一本被前辈称赞, 另一个马丁的知名著作, 被赋予学习如何写出漂亮代码的教皇级手册, 最近(再)浏览, 有诸多感受.</p><p>总结一下就是如果你是新手, 可能看优秀的open source学习更好; 如果你是老手, 可能他说的东西要么你会觉得太啰嗦, 要么你会觉得例子太细节, 太教条, 无法举一反三.</p><p>不过一些General的要点思想我摘录了出来, 有些还包括个人的观点, 记录在此, 以备查阅.</p><a id="more"></a><ul><li>勒布朗(LeBlanc)法则, Later equals never</li><li>代码如果烂了就会越来越烂, 所谓破窗原理, 以前老是也提过叫代码腐化</li><li>命名<ul><li>命名应该合理, 成员变量不用加前缀, 靠高亮就很好</li><li>接口加前缀I也不太好, 不如实现加Imp</li><li>方法命名最好使用动词或动词短语</li><li>多使用计算机领域的词汇</li><li>有时候命名在语境里才有意义, 有时候变量命名也不需要重复语境</li></ul></li><li>函数<ul><li>函数短小一些比较易懂, 20行内最佳</li><li>if/else/while代码块封装函数, 只有一行最好 (有点激进?)</li><li>一个函数只干一件事情</li><li>复杂的switch试图用多态取代, 然后封装在抽象工厂里</li><li>同一类型函数命名风格应该一致, 使用描述性的语句描述比难懂的短词更好</li><li>一元函数最普遍, 标识函数(参数为boolean)的不如分成两个函数, 二元函数尽可能转换成一元函数</li><li>参数太多可能需要封装类了</li><li>好名字的函数一般是动词, 或者动词+关键字</li><li>函数一般要么做事, 要么回答事, 不可兼得 (其实也不一定, 比如很多返回boolean状态的函数)</li><li>推荐使用异常代替错误代码</li><li>最好将try/catch单独抽入一个函数 (如Android代码会对RemoteService调用进行类似封装, 吃掉exception)</li><li>使用枚举表示错误码会让改动变得繁琐 (重新导入或者编译部署), 大家都依赖这个枚举, 应该用异常与继承取代</li><li>不要重复, 偶尔可以考虑AOP这类的方法解决</li></ul></li><li>注释<ul><li>注释少要比注释多有用, 注释多说明代码糟糕 (其实分情况吧)</li><li>有目的性的注释还是有用的, 比如阐述, 放大, 警告, 定期维护的TODO等</li><li>如果代码不用, 不要注释掉, 直接删掉</li></ul></li><li>格式<ul><li>横向, 竖向对齐, 间隔, 缩进等. 其实目前formater已经很强大了, 养成良好的format习惯, 渐渐的写出来的代码就会像直接format后一样</li></ul></li><li>对象与数据结构<ul><li>面向过程与面向对象对立, 前者容易加函数, 不容易加对象, 后者容易加对象, 而不容易加函数</li><li>理想情况下, Law of Demeter认为, 类不应该操作对象内部的东西, 如不应该操作函数返回对象的方法. 目的只是为了降低复杂度, 认为这样将私有变量公开化, 增加了重构的难度, 如添加新函数, 方法等, 将数据结构与对象逻辑耦合在一起.</li><li>针对于上面的问题, 原则应该是对象暴露行为, 隐藏数据, 数据结构暴露数据</li></ul></li><li>错误处理<ul><li>Java特色的受控异常(Checked Exception), 必须得被catch, 对受控异常的修改会引起上层所有调用方法的改动, 尽量不要使用, 其他语言只有RuntimeException</li><li>可以包装第三方逻辑, 封装自己的异常类, 简化为只catch一种异常</li><li>简化使用也可以将异常处理完全封装进去, 返回特例即可</li><li>轻易不要返回null, 传入null</li><li>代码的坚固与干净不冲突, 所以添加一些check, throw相应的Exception也合理</li></ul></li><li>边界<ul><li>所谓边界就是自己可以控制到的程序与第三方的边界, 通常需要通过封装的办法来划清边界, 限制那些无法控制的第三方, 如直接Wrapper或者Adapter模式等</li></ul></li><li>单元测试<ul><li>测试需要整洁, 需要跟随代码一起更新, 测试的最大用途是保证你后续的修改有信心</li><li>测试的整洁主要讲的是可读性, 即分为三个环节, build-&gt;operate-&gt;check, 可以把繁杂的准备封装起来</li><li>测试API是渐渐重构演进过来的, 也不可能是起初就设计出来</li><li>有人建议每个测试一个assert, 但是这样会有很多重复的代码, 不过可以利用<code>Template Method</code>来解决. 不过也不一定必须一个, 做到最小化就可以了</li><li>整洁还有五条规则, Fast, Independent, Repeatable, Self-Validation, Timely</li><li>这里讲到TDD的好处, 主要是帮助你覆盖更多的测试, 如果写完再测, 发现测不了, 就不写了.</li></ul></li><li>类 <ul><li>类应该短小, 权责应该足够单一, 内聚性应该高</li><li>如果期望抽走一部分逻辑, 最好连相关函数参数也抽走</li><li>简化类的过程应该小步, 每一步都运行测试一下</li><li>类的精简是为了更好的体现开闭原则, 整体结构为修改而设计</li><li>类应依赖于接口, 不依赖实现, 可以隔离修改, 符合依赖倒置原则, 类似策略模式</li></ul></li><li>系统<ul><li>构造与使用分开, 通过依赖注入等</li><li>通过AOP, Proxy的方式, 无侵入性的插入逻辑</li><li>系统如果充分模块化, 领域之间相互直接松耦合, 最为理想, 就可以通过测试来驱动</li><li>DSL的使用可以平衡领域与技术</li></ul></li><li>迭代<ul><li>代码是在不断迭代中进步的, 比如通过抽函数, 运用设计模式等</li></ul></li><li>并发<ul><li>应该尽可能分离并发代码与其他代码</li><li>尽可能让线程之间独立, 不要有共享</li><li>线程模型有典型的生产者与消费者, 读者与作者, 宴席哲学家模型, 分别用来说明互斥, 读写, 竞争死锁等特例</li><li>锁定代码块应该尽可能小</li><li>线程最好可插拔, 遵循单一权责, 分离线程与其他代码,  测试先保证除线程之外的逻辑</li><li>最后一张通过实例来介绍并发代码如何重构的比较清晰</li></ul></li><li>逐步改进<ul><li>这片使用了一个例子, 先采用蛮干进行重构发现越来越难, 后来采用逐步的办法, 还写的很细节,  但是比较Tricky的地方是, 这里提出的每步改动都通过测试来印证, 然后保证测试通过, 或者补充一个测试, 让代码通过, 但是所谓TDD部分只有思想, 老代码既然写的不好, 测试是如何出来的, 如何做到Cover全的. 如果假设在一个有比较好测试覆盖的基础上重构, 我感觉即便蛮力也不会太差…</li></ul></li><li>JUnit<ul><li>比较神奇的一章, 感觉更像是用一个算法类的重构来说明如何把代码改简单, 但是开头先介绍了100%覆盖的Junit测试长什么样子… 感觉作者是想说以前的人做的还不错, 都用JUnit给覆盖全了, 还是可以重构的更漂亮的, 所以感觉标题不太好</li></ul></li><li>重构SerialDate<ul><li>跟上一个对比, 这个测试覆盖不全, 所以在补测试的过程中进行重构, 还发现了缺陷, 又最终把代码改清晰了. 不过同样由于太过细节, 一些重构理论也很教条, 如果想通过看别人重构的例子来学习如果写简洁的代码, 不如直接看优秀的代码是怎么写的</li></ul></li><li>味道<ul><li>里面类比了很多Bad Smell, 同样是很细节, 比如太多, 太死, 太复杂, 重复, 不一致, 耦合, 测试不足等, 提供的Tips大多的中心思想就是抽, 封装, 单一职责, 命名清晰</li><li>提到使用*来避免过长import, 不过这个与现在流行的lint检测违背, 可以因为以前都是手动, 通配符简单吧.</li><li>不要通过继承来使用常量, 还提到不要用静态常量, 用枚举, 这个也与当前的思想有出入, 现在经常将Java的enum太冗余, 不必要时可以用常量</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      Clean Code
    
    </summary>
    
      <category term="Clean Code" scheme="http://talentprince.github.io/categories/Clean-Code/"/>
    
    
      <category term="Note" scheme="http://talentprince.github.io/tags/Note/"/>
    
      <category term="Clean Code" scheme="http://talentprince.github.io/tags/Clean-Code/"/>
    
  </entry>
  
  <entry>
    <title>Java与Android知识点总结</title>
    <link href="http://talentprince.github.io/2020/09/08/Android-Points/"/>
    <id>http://talentprince.github.io/2020/09/08/Android-Points/</id>
    <published>2020-09-08T04:25:31.000Z</published>
    <updated>2020-09-08T04:41:19.807Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看关于Java以及Android开发相关知识点的视频, 有的非常细节, 有的则很概括, 本人也通过查阅文档对一些知识点进行了补充, 将其要点总结于此, 以供日后查阅.</p><a id="more"></a><ul><li>Char<ul><li>Char两个字节, 里面使用UTF-16编码</li><li>String的length是字符占据的长度, 而不是字符个数, python3.3以后已经改成实际个数了, 如果在微博输入一个emoj, 就会减2/3个字符</li><li>Java9会优化字符存储, 字母会用Byte来存字母, 而不是以前的2个字节</li><li>Unicode是字符集, 而不是编码</li><li>ASCII (Windows上简体中文用GB2312), Unicode (只规定了二进制代码, 不规定如何存, Windows上用UCS-2), UTF8 (1~4表示一个字符), UTF16 (UCS-2的父集, 2/4字节)</li></ul></li><li>String<ul><li>栈中的String, 使用<code>CONSTANT_Utf8_info</code>来存储, 长度为u2即两个字节长度, 所以最多65534个字节 (Java编译器用了&lt;而不是&lt;=, Kotlin没问题), 最终储存在方法区内的常量池</li><li>对于汉字, 得通过Utf8编码才知道占用字节, 这里使用了&gt;MAX所以可以存入65535/3个汉字</li><li>堆中的长度跟Int.Max一样, 有些虚拟机有头部保留, 可能为Max - 8</li></ul></li><li>方法绑定<ul><li>Java方法重载, 编译期就决定了, 调用声明类型</li><li>但是Groovy调用实际类型, 因为它先反射你的变量得到实际类型, 再调用</li><li>C++非虚方法只会调用声明类型方法, 虚方法只有指针调用时才触发虚绑定, C++对象本身赋值会触发赋值/复制构造, 进行裁剪, 所以无法触发绑定</li><li>Java方法都是虚方法, 覆写会动态绑定, 调用实际类型</li><li>注解扩展<ul><li>Target<ul><li>限制注解使用位置, 如METHOD, FIELD, TYPE(class/interface)等</li></ul></li><li>Retention<ul><li>约束其生命周期<ul><li>SOURCE 只会在代码里, 编译后丢失</li><li>CLASS 会保留在源码里, 但是不会加载到虚拟机, 如Override, Deprecate</li><li>RUNTIME 加载JVM,  运行时可通过反射用</li></ul></li></ul></li></ul></li></ul></li><li>Java泛型<ul><li>为了兼容性, Java用了假泛型, 类型擦出</li><li>基本类型无法作为泛型类型, 必须装箱拆箱, Android可以用SparseArray省去装箱</li><li>静态方法没法用类泛型, 因为会早于类实例化, 但可以自己定义方法泛型</li><li>即便有泛型, 1.5以后强转开销还在</li><li>Gson的TypeToken<x>(){}.getType()就是通过getGenericReturnType等方法拿到运行时泛型信息, 前提得<code>- keepattributes Signature</code>保存泛型签名<ul><li>TypeToken的构造为protected, 通过创建其匿名内部类调用getType方法</li></ul></x></li><li>Retrofit的接口定义Call<x>泛型信息也是通过类似方法</x></li><li>Kotlin反射原理来自最终的注解Metadata, 反射得把<code>kotlin.Metadata{*;}</code>给keep了</li><li>混淆扩展<ul><li>keep 类所有东西都保留</li><li>keepclassmembers 指定的成员保留, 比如方法, 类成员</li><li>keepclasseswithmember 保留满足条件(含某成员或者方法)的类</li></ul></li></ul></li><li>onActivityResult<ul><li>不能使用简单回调是因为activity可能重建, 回调匿名类持有的已经不是显示出来的</li><li>新API里通过prepareCall/launch或者直接ActivityResultRegistry注册</li><li>改造回调办法<ul><li>基于DummyFragment实现回调 <ul><li>将回调存在一个地方, 再次返回调用新Fragment的onResult时将回调中的activity替换成新的</li></ul></li><li>基于AOP<ul><li>AOP hook住所有activiy的onResult, callback存全局map</li></ul></li><li>基于Hook<ul><li>向ActivityThread的handler callback里加入自己的handler, 然后拿出返回的activty进行回调</li></ul></li></ul></li></ul></li><li>线程停止<ul><li>stop/suspend被废弃了<ul><li>stop主要是因为stop后会释放所有线程锁, 这样其他线程就获取一些被保护的变量获取不一致的状态, 因为数据没有机会清理</li><li>suspend主要因为可能会造成死锁, 或者卡主其他的线程</li></ul></li><li>正常的中断方式<ul><li>boolean</li><li>interupt</li></ul></li><li>中断<ul><li>interrupted()<ul><li>静态方法, 获取当前线程,  读取后状态清空, 除非等到下一次打断信号</li></ul></li><li>isInterrupted()<ul><li>状态清除前一直是true</li></ul></li><li>Java层调用interrupted其实底层给<code>interrupted_</code>加锁并置位</li><li>除非用了sleep, 一般用boolean标志位就够了, boolean需要加上volatile, 并且比底层操作性能高</li></ul></li></ul></li><li>线程安全<ul><li>Java内存模型<ul><li>每一个线程都有内存副本, 更改完副本后, JMM会控制刷新主内存, 其他共享该内存的线程会去主内存拉去状态, 更新副本. 类似于线程一向线程二发消息.</li><li>JVM的内存会被分为, 线程栈区跟堆区.<ul><li>本地变量原始类型, 放在栈区, 对象类型引用在栈区, 实际对象在堆区</li><li>对象成员方法中的变量, 全部在栈区, 即便对象本身在堆区</li><li>对象的成员变量, 不管什么类型, 都在堆区</li><li>静态类本身与变量都会在堆区</li></ul></li><li>堆区的变量是多个线程共享的</li><li>volatile变量JMM会在写入字段后插入指令, 保证写入时其他线程也能看到更新</li><li>Java5以后提出happens-before模型, 保证前一个操作执行结果对后一个可见<ul><li>同一个线程, 顺序执行</li><li>解锁操作与随后的加锁操作</li><li>volatile的写入与其他线程的读取</li><li>传递性, A-hb-B, B-hb-C, 则A-hb-C</li></ul></li></ul></li><li>可变资源线程共享<ul><li>共享不可变资源</li><li>不共享资源<ul><li>函数不使用外部内存</li><li>ThreadLocal<ul><li>弱引用</li><li>定义全局静态final</li><li>避免存储大量对象<ul><li>因为它内部的map使用的开放定址, hash值为magicnumber的倍数</li></ul></li><li>用完即时移除<ul><li>因为它自己得线程退出才移除</li></ul></li></ul></li></ul></li><li>共享可变<ul><li>遵循原则<ul><li>可见性<ul><li>volitale防止操作副本</li><li>final防止重排序</li><li>加锁, 锁释放时会刷新主内存</li></ul></li><li>原子<ul><li>++不是原子操作, 因为会把原值放进tmp内再加</li><li>通过加锁保证</li><li>使用CAS指令, 如Unsafe.compareAndSwapInt<ul><li>这个方法得通过反射Unsafe内的<code>theUnsafe</code>得到实例</li><li>方法swap成功返回true, 否则返回false</li></ul></li><li>AtomicInteger等</li><li>AtomicReferenceFieldUpdater</li></ul></li><li>禁止重排序<ul><li>final可以禁止重排序, 保证赋值操作在构造体内完成</li><li>1.5之后, volitale也能保证改造函数一定在赋值操作之前调用, 写单例必须加上volatile</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>ConcurrentHashMap<ul><li>HashTable是全表加锁</li><li>优化进程<ul><li>1.5 分段加锁, 必要时加锁</li><li>1.6 优化二次hash算法</li><li>1.7 段懒加载, volatile加cas</li><li>1.8 摒弃段, 基于hashmap实现并发</li></ul></li></ul></li><li>AtomicReference与AtomicReferenceFieldUpdater<ul><li>ARFU指向前者, 占用16字节(压缩指针)或者24个字节 </li><li>ARFU使用反射, 创建一个静态的用于原子赋值, 节省内存</li><li>AR使用更简单</li><li>kotlin by lazy(PUBLICATION)使用的就是ARFU</li></ul></li><li>异步代码<ul><li>异步不一定快, 如果是CPU密集型可能会更慢, 因为切换需要消耗</li><li>通过RxJava解决回调低于, 注意异常处理, 以及disposable的处理, 如使用AutoDisposable</li><li>通过Kotlin协程处理, 参考AutoDiaposable写自动cancel, 通过class AutoDisposable(view, job): Job by job, OnAttachStateChangeListener的扩展+代理, 保证不改变原本launch的返回值为Job, 且可链式调用添加Listener控制cancel</li></ul></li><li>CPU架构适配(native)<ul><li>普通开发者与sdk开发者考虑问题不同, sdk要尽可能全, 并且优化体积</li><li>架构分为mips64/mips(废弃了) x86_64/x86(兼容armeabi) armeabi-v7a/v8a/armeabi</li><li>优先去对应目录找so, 如果不全, 则加载失败, 如果一个都没提供, 则会自动找兼容</li><li>简单的使用v7a最通用的so</li><li>复杂一些把不同的架构都放在armeabi里, 通过代码来加载对应, 获取优化, 如libmath.so</li><li>混用限于同一种位数, 比如都是32位 (arm与v7), 如果v8a机器加载armeabi中的v8a库则会以32位加载出问题</li><li>太大的so库又不是启动项则可以后期增量下载</li><li><code>-fvisibility=hidden</code>隐藏符号表, 只公开必要, <code>-fno-exceptions -fno ftti</code>用处不大可以去掉, 不要使用iostream使用android log, 可以通过gc-sections去除无用代码, 如cflags<code>-ffunction-sections</code> <code>-fdata-sections</code>, 以及ldflags<code>-WL</code> <code>--gc-sections</code></li><li>也可以使用官方的splits { abi {} }分包</li></ul></li><li>JNI绑定<ul><li>分静态绑定与动态绑定<ul><li>全部可见占用符号表, 名字写死, 但是AS可以跳转 </li><li>动态绑定(env-&gt;RegisterNative)任何时候都可以触发, 可以覆盖静态绑定</li></ul></li><li>需要暴露的JNI方法通过<code>extern &quot;C&quot; JNIEXPORT void JNICALL</code>进行声明<ul><li><code>JNIEXPORT</code>设置了函数的visibility为default</li><li><code>JNICALL</code>在某些平台上有定义, 如Windows定义了函数如何入栈等惯例规则</li></ul></li></ul></li><li>JNI数据传递<ul><li>指针通过long传递</li><li>字符串传递<ul><li>GetStringUTFChars/ReleaseStringUTFChars<ul><li>const char* Modified-UTF-8字节流, <code>\0</code>编码为0xc080, 不影响c字符串结尾</li></ul></li><li>GetStringChars/ReleaseStringChars<ul><li>const jchar* 自动处理字节序转换, Java是大端, C是小端</li></ul></li><li>GetStringUTFRegion/GetStringRegion<ul><li>需要自己开辟内存, 可以控制长短</li></ul></li><li>GetStringCritical/ReleaseStringCritical<ul><li>调用会暂停Jvm Gc 与 其他JNI操作</li></ul></li><li>这些函数大部分第二个参数都是<code>jboolean* isCopy</code>, 告诉你是不是复制的, 虚拟机支持的话, 可以指向Java层的字符串</li></ul></li><li>Local Reference有个数限制, 使用完就释放, 如果个数少可以等函数调用结束自动释放</li><li>ByteBuffer直接在物理内存开辟 (ByteBuffer.allocateDirect), 不需要拷贝, 底层直接通过<code>GetDirectBufferAddress</code>获取指针地址, 但是需要自己处理字节序</li><li>尽可能让底层访问少的Java对象, 减少反射, 多使用基本类型</li></ul></li><li>捕获Native异常<ul><li><code>struct sigaction</code> handler结构体</li><li>调用sigaction(SIGNAL, &amp;handler, &amp;old_hanlders[SIGNAL])设置新的handler, 保存旧的</li><li>然后再新handler内处理不同信号的异常, 处理完再交给oldhandler处理, 类似Java</li><li>对于底层pthread创建的线程, 要通过<code>Jvm-&gt;AttatchCurrentThread</code>来获得新的env, 并且结束后Detach</li><li>如果<code>Jvm-&gt;GetEnv</code>返回JNI_OK, 则可以直接使用, 利用这两个机制创建Helper对象, 析构函数Detach简化Env的获取</li><li>如果Env是attach到native线程上的, 就无法拿到Java层的类了, 就需要通过底层保存的<code>classLoader</code>对象调用findClass来找到jclass</li><li>JNI只有GlobalRef才可以被返回, LocalRef出了函数就被回收了</li><li>需要使用备用栈 (<code>action.sa_flags |= SA_ONSTACK;</code>),  防止SIGSEGV栈循环溢出无法拿到</li><li>通过独立线程收集, 通过libcorkscrew.so(4.1-5.0),libunwind.so(5.0+)</li><li>通过线程对应Java崩溃堆栈, 分析问题</li></ul></li><li>只有C/C++才能编译so吗<ul><li>只要符合规定就可以运行<ul><li>静态绑定<ul><li>符号表可见</li><li>命名符合报名_类名_方法名</li><li>符号使用extern C修饰, 不能用C++</li></ul></li><li>动态绑定<ul><li>只要在JNI_OnLoad里注册就行</li></ul></li></ul></li><li>可选的编译成native的语言都可以<ul><li>Golang, Rust, Kotlin Native, Scala Native</li></ul></li><li>Kotlin Native<ul><li>@CName静态绑定native函数签名</li><li>JEnv*通过对象包装, CPointer<jnienvvar></jnienvvar></li><li>memScoped可以自动管理内存</li><li>动态注册需要通过<code>staticCFunction(::function)</code>拿到指针然后register</li></ul></li></ul></li><li>Activity启动<ul><li>Activity通过AMP(Proxy/Client)访问AMS<ul><li>解析Activity信息</li><li>处理启动参数</li><li>启动与绑定进程, 通过Zygote fork进程, 以便可以复用资源加快速度</li></ul></li><li>AMS通过ATP(Proxy/Client)#scheduleLaunchActivity返回Activity<ul><li>控制生命周期回调</li></ul></li><li>插件化就是在发起跟结束的时候欺上瞒下, hook发给AMS的信息, 并在返回ActivityThread后改回来</li><li>Bundler有缓冲区, 大小有限制, 数据必须序列化<ul><li>同一个进程就通过全局共享内存传大数据</li><li>进程间则可能需要ContentProvider之类的</li></ul></li><li>Activity跟Fragment都需要无参构造, 系统通过反射创建它<ul><li>new-&gt;attach-&gt;create-&gt;start-&gt;restoreState-&gt;postCreate-&gt;resume-&gt;makeVisible</li><li>attach-&gt;createPhoneWindow</li><li>create-&gt;installDecor (add, setContentView)</li><li>resume-&gt;显示 (status bar, action bar, content view)</li></ul></li><li>转场动画<ul><li>新页面显示之前, 拿到之前页面元素(共享元素)的位置信息, 应用到新元素并播放动画, 达到新页面位置</li></ul></li><li>跨App启动Activity<ul><li>sharedUserId相同, 直接通过Intent.setComponentName来启动</li><li>exported暴露, 公开可见</li><li>定义了私有的的action<ul><li>加上一个自定义permission, 但是必须主应用先安装, 才能申请到权限</li></ul></li><li>暴露的Activity如何防止其他人传未知类型导致crash, 拒绝服务漏洞<ul><li>trycatch包住intent.getExtra</li></ul></li></ul></li><li>Activity传参繁琐<ul><li>通过Builder设置Require以及Optional</li><li>在ActivityLifeCycleCallback的onActivityCreated里注入, 这是被onCreate触发的</li><li>onNewIntent需要单独手动处理</li><li>这些都可以通过注解生成器来生成<ul><li>需要合并父类的fields, 父类可能不需要生成builder</li><li>万一Activity是内部类可能需要特殊处理, 命名会有$</li><li>尽量少生成代码, kotlin与java之间类型的映射</li></ul></li><li>元编程<ul><li>apt (dagger, arouter), bytecode(replugin), generic, reflect, proxy(retrofit)</li></ul></li></ul></li><li>任意位置添加View<ul><li>GC回收<ul><li>被GCRoots持有都不会被回收<ul><li>虚拟机栈, 方法栈</li><li>静态类属性</li><li>常量引用</li><li>Native方法引用</li></ul></li><li>SoftRef<ul><li>内存快满才回收</li></ul></li><li>WeakRef<ul><li>GC一次就回收</li></ul></li></ul></li><li>Activity里面添加<ul><li>因为只有addContentView, 没有remove, 需要拿到decorview</li></ul></li><li>全局View<ul><li>通过window来添加</li></ul></li></ul></li><li>App右滑效果<ul><li>Fragment<ul><li>不涉及Window, View跟随手势</li><li>手势结束判断取消或者归位动画等</li></ul></li><li>Activity<ul><li>顶层Window背景为透明<ul><li>windowBackground</li><li>windowIsTranslucent (如果不设置, window背景会强制被改为不透明)</li></ul></li><li>多个Task<ul><li>在切task后会先显示另一个task最顶层再打开目标</li><li>可以通过偷偷放截图在下面障眼</li></ul></li><li>透明与生命周期<ul><li>看不到是create, 能看到是start, 顶层是resume</li></ul></li><li>SwipeBackActivity<ul><li>必须继承父类</li><li>必须设置windowIsTranslucent<ul><li>设置后下面的activity生命周期会变化, 永远会被绘制, 不会进入onStop </li></ul></li></ul></li><li>优化降低成本<ul><li>改继承为实现接口</li><li>通过隐藏方法在滑动的时候转换透明<ul><li>convertToTranslucent/convertFromTranslucent</li></ul></li></ul></li><li>造轮子, 或者改造现有轮子</li></ul></li></ul></li></ul></li><li>非UI线程更新UI<ul><li>Zygote–main函数–&gt;ActivtyThread-&gt;Loop–退出后–&gt;RuntimeException</li><li>Handler.post-&gt;Looper.loop-&gt;MessageQueue-&gt;Handler.dispatchMessage-&gt;MainThread</li><li>UI变化快需要高效, 所以不能加锁, 所以必须单线程更新</li><li>SurfaceView可以在非UI线程绘制, lockCanvas-&gt;draw-&gt;unLockCanvasAndPost, 主线程只显示, 所以帧率高</li><li>GLSurfaceView是SurfaceView的子类, 有GLThread进行绘制, 死循环不断onDrawFrame</li><li>Handler.postDelay<ul><li>enqueueMessage-&gt;wake-&gt;write</li><li>epoll_wait-&gt;pollOnce-&gt;next(当前时间与消息队列第一条消息时间, 到了就执行, 不到就继续等)-&gt;执行消息</li><li>delay不靠谱, 大于Looper周期基本可靠 (&gt;50ms)</li><li>消息队列优化<ul><li>重复消息过滤</li><li>互斥消息取消</li><li>obtain复用消息, 避免太多触发gc</li><li>IdleHandler, glide3是用它移除ReferenceQueue监听到需要移除的弱引用</li><li>HandlerThread可以自己开线程穿件Looper, 内部已经Loop.prepare+loop过了</li></ul></li></ul></li><li>Looper与ANR<ul><li>Service(20s/200s), Broadcast(10s/60s), ContentProvider(10s), InputDispatch(5s)卡久了就ANR</li><li>AMS-&gt;ActiveService-&gt;到app启动Service, 开始后AS会发一个延迟的消息, scheduleServiceTimeoutLocked, 如果规定时间内没有执行完调用doneExecutingLocked, 就会发送handler message到UI线程, 弹出ANR对话框</li><li>Looper是消息循环, 里面出问题了才会有ANR</li><li>Looper空消息后调用epoll_wait, 等待文件消息, 不占用CPU<ul><li>epoll_ctl建立监听管道, rbtree</li><li>epoll_wait监听就绪列表, rdlist</li></ul></li><li>简单的Handler-Looper<ul><li>Handler内部用了开机后消耗了多少时间, 简单实现可以使用当前时间</li><li>Looper.prepare把对象存放在ThreadLocal里</li><li>Looper.loop启动循环调用next拿消息执行</li><li>MessageQueue可以用现成的DelayQueue来实现<ul><li>取消息阻塞类似于MessageQueue的nativePollOnce</li><li>不过take阻塞底层通过<code>pthread_cond_timeout</code>来实现</li><li>Android为何不使用DelayQueue<ul><li>没有合适的remove, android通过msg里的token(obj)移除</li><li>自己实现底层, 自由度更高</li><li>MessageQueue对单线程读取优化, 只有Looper现成读, 提前读取下一条消息</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>避免OOM <ul><li>选择合适的数据结构<ul><li>SparseArray+ArrayMap<ul><li>数量少于1000, 增删不频繁就用, 扩容慢, 还能缩容</li><li>内存复用, </li></ul></li></ul></li><li>整形替代枚举 4byte vs 24byte<ul><li>@IntDef限制类型, 只能提示不能阻止, kotlin也不支持</li><li>inline class</li></ul></li><li>图片使用<ul><li>选择合适分辨率, 注意原始分辨率与缩放关系<ul><li>xxhdpi放的匹配图片放入hdpi里面会缩放2倍, 占用更多内存</li></ul></li><li>bitmap使用重采样, 缩略图</li></ul></li><li>不用帧动画, 用代码实现</li><li>谨慎使用多进程, 因为进程本身分配了很多内存</li><li>使用NDK内存跳出JVM限制</li><li>5R原则<ul><li>Reduce, Reuse, Recycle, Refactor, Revalue</li></ul></li><li>图片如何缓存<ul><li>三级缓存</li><li>获取成本 缓存成本 缓存价值(命中率) 随着时间的变化</li><li>LRU(对应的还有LFU), 最近使用交换位置排在最后, 干掉最开始不常用的<ul><li>LRU内部有一些private的算法统计字段xxxCount</li><li>LRU线程安全, 采用短锁</li><li>LRU内部使用LinkedHashMap, accessOrder设置true会自动发访问过的放最后</li></ul></li></ul></li><li>图片占用内存大小<ul><li>根据dpi抽象出canvas层, 在不同设备上进行缩放</li><li>getByteCount应该占用内存</li><li>getAllocationByteCount实际占用, 当小图复用大图时</li><li>预先计算<ul><li>宽<em>高</em>像素编码位数</li><li>高dpi手机拿低dpi文件夹下的, 图片会变大 (scale=屏幕dpi/图片目录dpi + 0.5f)</li></ul></li><li>inSampleSize采样大变小, 矩阵变换小变大</li><li>使用svg, rgb_565, 9-patch, 不用图</li><li>通过assets中透明的indexed-png+rgb565强行加载index-8类型<ul><li>因为skia库中对于透明的565格式返回图本身</li><li>该类型不能通过Bitmap创建Canvas, 不能放入缩放目录</li><li>8.1底层开始被移除了</li></ul></li></ul></li></ul></li><li>Android P隐藏API<ul><li>@hide的函数可以通过自编jar骗过编译器</li><li>private的只能使用反射<ul><li>setAccessible绕过权限控制, 还可以修改final变量</li></ul></li><li>API名单<ul><li>白名单</li><li>浅灰名单 反射依旧可以用</li><li>深灰名单<ul><li>Targe低于28 可以使用</li><li>Targe&gt;=28 反射也不能用</li></ul></li><li>黑名单 反射也不能用</li></ul></li><li>Android修改了getDeclaredMethods方法, 调用底层检查是否在白名单或者是否是No_check的Policy</li><li>使用FreeReflection绕过检查<ul><li>修改Runtime的<code>hidden_api_policy</code><ul><li>底层通过JavaVM拿到JavaVMExt的私有变量Runtime</li><li>自己写个Struct凑位数, 第二个<code>void*</code>(没虚方法少一个vp)类型就是Runtime变量</li><li>Runtime里面通过每4个字节(内存对齐)查找定位变量位置</li><li>查找<code>target_sdk_version</code>做为定位点, 将Runtime转换为PartialRuntime拿到Policy修改</li></ul></li><li>修改<code>hidden_api_exemptions</code>, 让程序豁免<ul><li>类似于第一种方法拿到Runtime, 修改HiddenApiExemptions </li></ul></li></ul></li><li>修改想要使用的Class, 将其ClassLoader置空 <ul><li><code>fn_caller_is_trusted</code>判断如果classLoader是空认为是bootClassLoader</li><li>可以在Java层修改, 也可以在native层修改</li></ul></li></ul></li><li>换肤功能<ul><li>Theme只支持定义的时候配置的值, 无法外部与动态加载</li><li>资源加载Context-&gt;Resource-&gt;AssetsManager (xml, 非xml, ResourceValue, ResourceText)</li><li>Resources内缓存替换<ul><li>替换资源有限, 只能替换缓存过的</li><li>Hook繁琐</li></ul></li><li>ResourcesWrapper包装<ul><li>不支持style, assets目录</li><li>包装起来代码量大</li><li>id映射可以在编译时期一致, 或者动态映射<ul><li>Id映射成资源name, 然后替换package再查找资源包新Id</li></ul></li></ul></li><li>AssertManager替换<ul><li>支持style, assets, 替换简洁</li><li>不能动态映射, 只能编译器需要对齐资源ID<ul><li>aapt输入主包的id映射表, public.xml</li><li>或者修改resource.arsc</li><li>如果皮肤资源少, 不能剔除public.xml, 因为剔除后位置会被后续非public资源补位, 保持资源紧凑</li><li>皮肤包资源需要对自己没有而主包有的资源进行占位/补位, 保证主包资源能加载进来<ul><li>修改AAPT, 或者直接修改resource.arsc</li><li>ResourceTable#applyPublicEntryOrder中间为不存在的占坑</li><li>如果最后有少资源还需要补位</li></ul></li></ul></li><li>非运行时替换<ul><li>编译器主包跟皮肤包差分, 应用阶段主包再与差分包合成皮肤包, 需要资源重定向</li><li>创建新的AssertManager只需要加入一个包即可, 因为包含所有资源</li></ul></li><li>反射创建并调用AssertManager#addAssetPath方法加入主包, 皮肤包, L以上要单独把Assets拿出来最后再加一次<ul><li>插件化是为了资源并存</li><li>皮肤是为了覆盖</li></ul></li><li>创建WrapContext<ul><li>attatchBaseContext的时候包装, 替换掉里面的resource, assertManager, classLoader<ul><li>Resource可以通过AssertManager构造</li></ul></li><li>getBaseContext的时候解包</li><li>可以使用JavaAssist改字节码插入attatch/detach方法</li></ul></li></ul></li></ul></li><li>VirtualAPK<ul><li>ClassLoader双亲委派<ul><li>DexClassLoader (user/plugin) -&gt; PathClassLoader (context) -&gt; BootClassLoader (parent)</li><li>先查看是否加载, 然后由父类查找, 父类查不到再让子类查找</li><li>他们都继承了BaseClassLoader-&gt;ClassLoader</li><li>BaseClassLoader#findClass会在pathList里查找类, 而这个list就是dex的list</li></ul></li></ul></li><li>Tinker<ul><li>Patch与Apk组成新Apk并放在Dex数组最前面<ul><li>基于Dex的差分, DexSectionDiffAlgorithm/DexSectionPatchAlogrithm<ul><li>先排序再用双指针分别指向</li><li>如果Old指针指向小于New指针指向, 说明DEL了</li><li>如果Old指针指向大于New指针指向, 说明ADD了</li><li>如果相等, 则更新映射</li><li>最后Index相同内容不同, 删除ADD/DEL操作, 标识为REPLACE</li><li>最终把变化转换为差分后的操作</li></ul></li></ul></li><li>Assets直接创建新的AssetsManager<ul><li>基于Entry的BSDiff, 得出资源差分包</li><li>与旧资源组成新包, 创建新的AssetsManager加载</li></ul></li><li>异常熔断<ul><li>加载之前checkpatch</li><li>单一进程启动三次失败</li><li>十秒钟内崩溃多次</li><li>大量注释, 46000代码, 69%代码</li><li>早起监控129个</li></ul></li></ul></li><li>Shadow<ul><li>使用Hook在海外直接下架</li><li>由反射转入编译器字节码, 注解处理器的方案</li><li>Shadow属于静态代理流派, 使用了很多字节码编辑</li><li>插件化流派<ul><li>动态Hook<ul><li>发送的时候靠占坑Activity替换绕过AMS检测, AMS返回的时候再换回PluginActivity</li></ul></li><li>静态代理<ul><li>将Activity的启动与生命周期靠ProxyActivity代理, 然后传递给PluginActivity, Plugin寄生与Proxy不被系统获知</li><li>在编译的时候, 通过字节码修改, 将PluginActivity修改成寄生的ShadowActivity</li></ul></li></ul></li><li>Shadow结构<ul><li>manager (插件管理, 如版本)<ul><li>plugin (ShadowActivity)</li><li>runtime (PluginContainerAcitity, Proxy)</li><li>loader (实现插件加载)</li><li>plugin, runtime, loader可以有多组, 没各插件都有一组, manager只有一个, 他们都是单独的apk</li></ul></li></ul></li><li>Shadow模块<ul><li>DynamicPluginManager与PluginProcessService都在Host里, 前者负责加载Manger, 反射创建PluginManager实例, 而该实例负责启动跨进程通信Service</li><li>PluginProcessService负责启动Loader与Runtime</li><li>Manager通过Binder接口直接控制Loader加载对应Plugin</li></ul></li><li>宿主与插件ClassLoader关系<ul><li>ApkClassLoader负责加载Manager, Loader</li><li>RuntimeClassLoader负责加载Runtime, 唯一的反射将其挂在PathClassLoader之上, 为了让系统启动Proxy壳子</li></ul></li><li>宿主与插件资源关系<ul><li>分开, ShadowActivity默认注入插件资源</li></ul></li><li>字节码编辑<ul><li>Java -&gt; APT (AST-&gt;Symbol)-&gt;Class-&gt;Dex-&gt;Apk</li><li>Class-&gt;Transform-&gt;Dex通过Transform修改</li><li>源码-&gt;Javassit-&gt;ASM-&gt;字节码, 越来越抽象</li></ul></li><li>插件系统通信机制<ul><li>主从通信<ul><li>插件注册Callback到宿主</li><li>插件通过binder与宿主通信</li></ul></li><li>对等结构<ul><li>通信模块可能也是特殊的插件</li><li>低频用Broadcast, 高频用LocalSocket</li></ul></li></ul></li><li>插件更新管理<ul><li>差分包<ul><li>Dex使用DexDiff(Tinker)</li><li>so使用Courgette(指令差分)</li><li>binary使用BSDiff</li></ul></li><li>v2签名<ul><li>插件包可以不需要签名</li><li>自研的更新服务器可重新签名<ul><li>可以拿到签名   <ul><li>先解包重新排列再签名</li><li>与重排列的完整包进行差分</li><li>合并插件</li></ul></li><li>拿不到签名<ul><li>拿到原始包压缩级别， entrylist</li><li>合成新的包, 可以做到复制签名信息等同等MD5值</li><li>google/archive-patcher</li></ul></li></ul></li></ul></li><li>工程管理<ul><li>Maven版本管理, 但有缓存不好用</li><li>所有都在一个project中, 耦合性大</li><li>Git Submodule, 依赖git, 手动管理更新代码</li><li>Gradle CompositeBuild<ul><li>setting.gradle里面直接<code>includeBuild=path-to-other-project</code></li><li>也有一些插件简化该操作</li></ul></li></ul></li></ul></li></ul></li><li>如何开展优化<ul><li>目标必须明确, 从定性到定量</li><li>定位关键问题, 找出最大的点, 梳理优先级</li><li>二八定律<ul><li>前期20%时间解决80%问题</li><li>后期则相反</li></ul></li><li>业内对比, 造轮子成本高</li><li>优化需要监控</li><li>算法策略优化<ul><li>对比现有方案, 论文或者经验交流</li><li>不同角度问题分析, 选择痛点</li><li>算法能否动态下发</li><li>监控报表与收益</li></ul></li><li>工程技术优化<ul><li>现有方案对比 <ul><li>系统方案, 开源方案, 基于开源自研方案</li></ul></li><li>基于开源自研优化<ul><li>针对特定Case进行处理, 如估算+再次判断</li><li>与产品探讨是否接受妥协, 使用估算代替精确</li></ul></li><li>开源协议License<ul><li>GPL 使用了就必须开源</li><li>LGPL 不用开源</li></ul></li></ul></li></ul></li><li>系统设计<ul><li>需求分析与系统设计</li><li>需求-&gt;流程-&gt;细节</li><li>细节<ul><li>IO密集还是CPU密集</li><li>线程如何调度, 需要多少线程</li><li>使用RxJava还是Koroutine</li><li>网络接入<ul><li>长连接, 高频交互, 维护复杂<ul><li>心跳保活, 要求高6-9s, 一般30-40s</li></ul></li><li>短连接, 低频交互, 查询为主<ul><li>短轮询, 固定时间抓取</li><li>长轮询, 60秒时间如果有就返回, 没有就超时让客户端重新抓</li></ul></li></ul></li><li>加密算法<ul><li>对称加密 </li><li>非对称加密, 耗时太长, 对数据长度有限制(RSA)</li><li>一般用对称加密, 用非对称加密将对称加密秘钥加密</li></ul></li><li>热修复与插件化<ul><li>是否需要立即生效</li><li>是否修改或者新增类</li><li>是否有未来做平台的打算</li></ul></li><li>脚本化<ul><li>存在很多模式化逻辑, 游戏关卡, 自定义UI体系等</li><li>经常调整的策略</li></ul></li><li>可以执行<ul><li>是否存在复杂平台不想管逻辑, 抽象为so库</li></ul></li><li>性能问题<ul><li>算法时间空间复杂度</li><li>内存峰值OOM</li><li>CPU占用与耗电量</li></ul></li><li>监控<ul><li>异常捕获Java+Native</li><li>性能监控</li><li>优化指标监控</li><li>运营数据监控</li></ul></li></ul></li></ul></li><li>短视频APP<ul><li>网络</li><li>相机<ul><li>新API都是异步, 状态难维护</li></ul></li><li>滤镜<ul><li>下发Shader Script给OpenGL渲染</li></ul></li><li>播放器<ul><li>H265 文件小, 硬件支持差, 解码慢, 适合热点小规模</li><li>H264 文件大一些, 硬件支持好, 解码快, 适合大规模</li><li>自带播放器一般收到一组GOP才能播放, FFmpeg收到关键帧就可以</li></ul></li><li>封装模式调整<ul><li>Mpeg4 (File Type Box, Movie Box, Media Data Box)</li><li>将一般的顺序由ftyp-mdat-moov改为ftyp-moov-mdat, 边下边播</li></ul></li></ul></li><li>网络请求框架<ul><li>依赖简单, 接口简单, 功能纯粹</li><li>协议 Http, WebSocket</li><li>基础组件<ul><li>连接管理</li><li>线程管理</li></ul></li><li>拦截器, 日志系统也是类似</li><li>重试机制, 渐进式重试, 最大重试次数与衰减因子</li><li>使用注解配置请求, 类似于retrofit与spring</li><li>支持第三方扩展, 支持rx, suspend</li><li>DNS增强, HttpDnsServer, 提速防止被劫持</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      Android 知识点
    
    </summary>
    
      <category term="Android Note" scheme="http://talentprince.github.io/categories/Android-Note/"/>
    
    
      <category term="Android" scheme="http://talentprince.github.io/tags/Android/"/>
    
      <category term="Note" scheme="http://talentprince.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>Refresh Refactor</title>
    <link href="http://talentprince.github.io/2020/09/01/Refresh-Refactor/"/>
    <id>http://talentprince.github.io/2020/09/01/Refresh-Refactor/</id>
    <published>2020-09-01T08:39:21.000Z</published>
    <updated>2020-09-08T04:28:43.337Z</updated>
    
    <content type="html"><![CDATA[<p>最近在闲暇之余重(第)温(一..次)此书, 首先能感受到的, 无论你是新程序员还是老程序员, 这本书都<strong>已经</strong>不具备太多的可读性了.</p><p>由于本书成书年代久远, 那个时候软件行业还不够发达, 面向对象还没有被大数人理解, 加之编译器也非常落后, 设计模式也不深入人心, 所以文中提供的所谓重构的心法, 在当时或许有一些意义. 而今看来, 整书400多页的文字, 主要的思想就是「抽」, 无论是类, 接口, 方法, 逻辑, 还是参数. 但是为什么会有这么大的篇幅, 其中一半的内容是教你如何在一个IDE功能匮乏的年代, 以一个出错率更低的顺序, 来进行上面所说的多种抽象操作.</p><p>当然我去除了大量书中已经没有任何价值的点后, 总结了如下的一些内容, 应该大多数大家已经在工作实践中已有体会, 主要还是总结一下, 温故知新吧.</p><a id="more"></a><ul><li>思想方面<ul><li>如果发现加特性很难, 就需要重构</li><li>重构前需要想想有没有可靠的测试机制</li><li>重构要微小步伐, 容易发现错误</li><li>Extract method是最简单的重构</li><li>写出机器认识的代码容易, 写出人类容易理解的才是应该的, 最大的影响就是命名</li><li>做移动重构时, 最好先复制粘贴, 测后再删除旧的代码</li><li>对于另外对象的switch往往可以通过继承, 多态来取代</li><li>三次遇到不合理的, 可能就是重构的时候了</li><li>重构往往通过加隔离层进行</li><li>不要过早发布接口</li><li>性能优化应该基于良好的代码结构, 性能瓶颈往往只会在很小的代码片段里</li><li>每次遇到一个bug, 尽量写个单元测试覆盖</li><li>测试集中覆盖边缘case  </li></ul></li><li>代码坏味道与手段<ul><li>重复代码<ul><li>抽方法</li></ul></li><li>大函数<ul><li>抽方法, 抽类</li></ul></li><li>大类<ul><li>抽类, 抽子类</li></ul></li><li>太多参数<ul><li>参数变方法, 抽参数对象</li></ul></li><li>加新功能修改多个函数<ul><li>抽子类</li></ul></li><li>加新功能需要改很多类<ul><li>挪方法, 挪成员</li></ul></li><li>函数过度依赖其他类<ul><li>挪方法, 抽方法</li></ul></li><li>同样的几个参数到处出现<ul><li>抽参数对象</li></ul></li><li>大量同样的基本类型做参数<ul><li>抽类, 不同表达式可抽进子类</li></ul></li><li>很多switch<ul><li>考虑用多态取代</li></ul></li><li>子类需平行同时添加<ul><li>先持有对方, 再挪方法, 再挪变量, 再合并</li></ul></li><li>没人用的类<ul><li>做内部类</li></ul></li><li>没太大用处的抽象, 参数, 命名<ul><li>删除, 重命名, 内联</li></ul></li><li>临时变量命名模糊<ul><li>抽方法, 抽类</li></ul></li><li>消息链过长, 对象转换过多<ul><li>对同一对象的使用抽方法, 推入消息链消除对象</li></ul></li><li>过度代理<ul><li>内联代理</li></ul></li><li>注释太多<ul><li>可能代码写的太难懂, 需要重构</li></ul></li></ul></li><li>数据<ul><li>临时变量被赋值多次, 则可以抽成方法</li><li>有时候需要提取多个临时变量对逻辑进行解释, 当然更好的可以再抽成方法</li><li>Java按值传递, 本质上是对象的引用按值传递</li><li>移除中间人与隐藏委托是相辅相成的</li><li>如果类无法更改, 就写个函数包装他, 类似于工厂方法?</li><li>如果不能修改, Adapter模式常常用于扩展方法功能</li><li>子类修改某些变量的获取可以通过自封装, 把变量抽象成函数</li><li>成员如果不用改变, 就由引用变为值对象, 即immutable对象</li><li>当业务复杂度变高需要将类之间单向关系改为双向绑定关系, 甚至一对多与多对一的关系</li><li>双向绑定可能会造成很多僵尸对象, 增加复杂度与空间占用, 所以只有真正需要的时候用, 删除可以通过将内部绑定查询转移为传参, 再在调用的位置进行判断是否为僵尸对象</li><li>不要使用Magic Number, 常量即可以优化储存, 又可读性高</li><li>封装字段可以控制字段的读写, 称之为数据隐藏</li><li>对于返回集合的函数需要返回只读副本, 如果需要修改, 则可另行提供修改方法</li><li>原始类型替换成类, 有类型字段的类转换为多个子类, 或者抽象成策略模式, 从而合理改变数据结构</li><li>如果子类只有常量, 可以抽成变量放父类, 再添加工厂方法创建, 降低复杂度</li></ul></li><li>条件表达式<ul><li>条件表达式很复杂的时候, 可以将条件, 执行代码进行封装, 更表意</li><li>嵌套很深的条件表达式的每个结果都作为返回值的话, 可以简化为多个if+return, 类似于swift里面的guard, 或者kotlin里面的?:return, 书里叫卫语句(Guard Clauses)</li><li>嵌套很深的条件表达式可以将范围大的if反向, 实现提前return</li><li>switch表达式有时候可以通过多态来取代</li></ul></li><li>函数调用<ul><li>函数最好读写分离</li><li>抽象重复性的函数用以复用</li><li>switch构造可以替换成工厂方法</li><li>从对象内拿出参数再传递给某函数不如直接将对象传入函数</li><li>当函数的参数来自另外一个函数时, 也可以删掉参数, 把函数调用挪进去</li><li>函数参数过多可以同对象替代</li><li>如果不需要设置就不要提供set方法, 变量都需要为final</li><li>有时候用抛异常替代返回错误码, 如果程序无法继续进行的话</li><li>如果可以条件逻辑避免Runtime异常, 应不要无脑try/catch</li></ul></li><li>继承关系<ul><li>子类同样的方法应该向上提, 并将不同的地方抽象为抽象方法分别继承</li><li>子类构造复制父类字段应该通过父类构造, super</li><li>超类与子类差不多, 就合并</li><li>逻辑相同, 类型不同可以通过模板函数, 模板类解决</li><li>不能滥用继承, 组合代理好过继承, 但也有特殊, 如果需要使用委托函数所有函数或者大量, 则就需要继承, 不过这一点在kotlin里面也可以通过by来代理</li></ul></li><li>复杂的重构<ul><li>整理复杂的继承关系, 该抽接口抽接口, 摘出更多深层子类</li><li>领域与表述分离, 就是UI与逻辑分离</li><li>过程抽象为对象</li><li>提炼继承体系</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      Refactor 重构 Martin Fowler 马丁福勒
    
    </summary>
    
      <category term="Refactor" scheme="http://talentprince.github.io/categories/Refactor/"/>
    
    
      <category term="Note" scheme="http://talentprince.github.io/tags/Note/"/>
    
      <category term="Refactor" scheme="http://talentprince.github.io/tags/Refactor/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化总结</title>
    <link href="http://talentprince.github.io/2020/07/30/Android-Performance-Enhance/"/>
    <id>http://talentprince.github.io/2020/07/30/Android-Performance-Enhance/</id>
    <published>2020-07-30T10:28:53.000Z</published>
    <updated>2020-09-08T04:29:51.760Z</updated>
    
    <content type="html"><![CDATA[<p>最近断断续续的看完了Android性能优化相关的一个系列视频, 感觉总结的非常不错, 很多地方都有深受启发.<br>期间也穿插着停下来研究了一些相关的技术,框架,与工具, 并做了一些小笔记, 现将整个体系总结下来, 以便翻阅与温习.</p><a id="more"></a><ul><li>性能优化工具<ul><li>TraceView<ul><li>图形化界面</li><li>track所有线程, 消耗大</li><li>Debug.start/stopMethodTracing开启与停止生成文件</li><li>AS的CPU Profile Trace Method就是这个</li><li>系统函数黄色, 第三方蓝色, 自己绿色</li><li>四个图表来查看<ul><li>Call Chart<ul><li>顺序的函数调用关系与时间, 由上到下</li></ul></li><li>Flame Chart<ul><li>函数调用时间汇总, 有下到上</li></ul></li><li>Top Down<ul><li>由根函数开始做树状图</li></ul></li><li>Bottom Down<ul><li>由叶子函数开始做树状图</li></ul></li></ul></li><li>时间<ul><li>Wall Clock Time<ul><li>表示真实运行时间, 包括Sleep, CPU切换</li></ul></li><li>Thread Time<ul><li>线程占用CPU的时间, 小于真实运行时间</li></ul></li><li>Self Time<ul><li>函数除第三方调用耗时以外的时间消耗</li></ul></li><li>Children Time<ul><li>函数第三方调用消耗</li></ul></li></ul></li></ul></li><li>Systrace<ul><li>主要检测CPU各个内核使用情况</li><li>消耗小, 只拿埋的点数据</li><li>python脚本, 通过Trace/TraceCompat打tag</li><li>CPU time才是优化的方向, 如果耗时过长, 可以通过多线程处理</li><li>灰色:睡眠, 蓝色:可以运行, 绿色:正在运行, 红色:内核睡眠, 橙色:IO睡眠</li><li>w:放大, s:缩小, a:左移, d:右移, f:放大, m:选中</li><li>查看frame中F的间隔, 大于16ms可能就有卡顿, 再通过traceview或者CPU Profile来进行追踪</li><li>4.3(18)以上加入了Java的Trace, 6.0(23)加入了Native Tracce, 低版本Native可以通过JNI来获取</li></ul></li><li>CPU Profiler<ul><li>3.0以上AS使用Profiler取代了Monitor</li><li>CPU时间轴最上面有事件时间轴, 7.1(25)及一下版本必须在Config里面勾选Advanced profiling, 重新编译, 注入监控逻辑才能有, 附带的还有一些内存的监控</li><li>Trace Method<ul><li>给方法调用前后记录时间戳, 有运行开销</li></ul></li><li>Sample Java Method<ul><li>通过不断的捕获堆栈</li></ul></li><li>System Trace<ul><li>使用systrace获取更加详细的</li><li>必须在7.0 (24)以上的机器才具备</li><li>在代码中添加检测代码进行标记<ul><li>C使用trace.h原生跟踪</li><li>Java使用Trace</li></ul></li><li>9.0 (28)以上手机里也可开启systrace </li></ul></li><li>Sample C++ Function<ul><li>8.0 (26)以上</li><li>使用simpleperf进行采样</li><li>如果想指定参数, 命令行使用simpleperf</li></ul></li></ul></li></ul></li><li>启动速度优化<ul><li>时间测量<ul><li>AOP AspectJ<ul><li>Join Points <ul><li>切入点<ul><li>函数调用,执行</li><li>get/set</li><li>init</li></ul></li></ul></li><li>Cut Point<ul><li>带条件的切入点</li></ul></li><li>Advice<ul><li>Hook, 插入位置<ul><li>Before</li><li>After</li><li>Around</li></ul></li></ul></li><li>语法<ul><li>@Aspect</li><li>@Before(“excution (* android.app.Activity.on**(..))”) public xx(JointPoint joinPoint) {}</li><li>@Around(“call(* package.**(..))”) public xx(ProceedingJoinPoint joinPoint) {}</li></ul></li></ul></li><li>通过AMS<ul><li>adb logcat -s ActivityManager | grep “Displayed”</li></ul></li></ul></li><li>启动器多线程<ul><li>Task</li><li>有向无环图</li></ul></li><li>延迟初始化<ul><li>View显示第一帧启动初始化任务<ul><li>ViewTreeObserver.addOnDrawListener</li></ul></li><li>IdleHandler<ul><li>Looper.queue.addIdleHandler</li><li>return true handler被移除, return false handler继续停留</li><li>结合第一帧, 封装一个Dispatcher, 将初始化任务加入, 注册IdleHandler</li></ul></li></ul></li><li>提前异步读取SharePreference<ul><li>在Multi dex install之前</li></ul></li><li>启动阶段不启动子进程</li><li>提前异步类加载<ul><li>在Multi dex install之前</li></ul></li></ul></li><li>内存优化<ul><li>常用工具<ul><li>离线<ul><li>Memory Profile</li><li>Memory Analyser</li><li>LeakCanary</li></ul></li></ul></li><li>Java内存分配<ul><li>方法区<ul><li>静态变量</li><li>方法信息</li><li>所有线程共享</li></ul></li><li>虚拟机栈</li><li>本地方法栈(native)</li><li>堆</li><li>程序计数器<ul><li>函数执行多多少行</li></ul></li></ul></li><li>Java内存回收<ul><li>标记清除法<ul><li>先标记再统一回收</li><li>效率低, 内存不连续</li></ul></li><li>复制算法<ul><li>划分多个块</li><li>一块用完后复制存活到另一块</li><li>再清除另一块</li><li>效率高, 但浪费</li></ul></li><li>标记整理<ul><li>存活对象向一端移动</li><li>清理其他内存</li><li>不浪费, 也没碎片</li></ul></li><li>分代收集<ul><li>新生代存活低, 复制</li><li>老年代存活高, 标记整理</li></ul></li></ul></li><li>Android内存管理<ul><li>内存弹性分配, 根据设备</li><li>OOM, 内存不足或者可用不足</li><li>Dalvik<ul><li>固定回收算法</li></ul></li><li>Art<ul><li>运行期选择<ul><li>前台<ul><li>标记清除</li></ul></li><li>后台<ul><li>标记整理</li></ul></li></ul></li></ul></li><li>Low Memory Killer<ul><li>进程分类<ul><li>根据优先级Kill</li><li>前台,可见,服务,后台,空进程</li></ul></li><li>回收收益<ul><li>根据需要回收的量级</li></ul></li></ul></li></ul></li><li>内存抖动与OOM<ul><li>原因 <ul><li>频繁创建对象, 会造成内存碎片与不足</li><li>内存碎片化会导致无法分配出来可用内存导致OOM</li></ul></li><li>Memory Profiler分析<ul><li>锯齿状</li><li>Record查看内存活动情况<ul><li>Allocate 分类instance个数</li><li>Shallow 自身占用内存大小</li><li>Retained 持有对象总大小</li></ul></li><li>追踪可疑内存allocate位置</li></ul></li><li>CPU Profile分析<ul><li>查看频繁调用方法的地方<ul><li>内存泄露</li></ul></li></ul></li><li>定义<ul><li>内存中存在没有用的对象 </li></ul></li><li>表象<ul><li>内存抖动 (因为GC), 可用内存逐渐减少</li></ul></li><li>危害<ul><li>GC频繁, 卡顿, 甚至OOM</li></ul></li><li>用Memory Profiler检测内存是否泄漏, 并dump java内存堆栈</li><li>用Memory Analyzer(MAT)分析<ul><li>需要进行转换 hprof-conv</li></ul></li></ul></li><li>Memory Analyzer<ul><li>Overview<ul><li>饼图</li><li>Top Consumer<ul><li>可查看Biggest Object</li></ul></li><li>Leak Suspect<ul><li>自动化分析泄露引用树</li></ul></li></ul></li><li>Histogram<ul><li>以类来列表</li><li>右键Group by package 以包名摆放</li><li>检查Objects, 存在个数</li><li>可疑对象右键可选List Object -&gt; with incoming ref</li></ul></li><li>dominator tree<ul><li>以对象列表</li><li>Percentage<ul><li>查看占比大的</li><li>同样通过List Object -&gt; with incoming ref</li></ul></li></ul></li><li>OQL<ul><li>对象数据库</li><li>可使用select * FROM className</li></ul></li><li>thread overview<ul><li>查看各个线程</li></ul></li><li>Unreachable Objects Histogram<ul><li>已经可回收的对象</li></ul></li></ul></li><li>Bitmap内存模型<ul><li>Api10之前, 像素存在Native, 对象存在Dalvik<ul><li>native回收时机不够</li></ul></li><li>Api10之后全部放Dalvik</li><li>Api26更改机制, 全部放Native, Bitmap回收后通知Native层</li><li>计算大小<ul><li>getByteCount</li><li>h <em> w </em> density, res要考虑压缩比例</li></ul></li><li>ARTHook<ul><li>Epic<ul><li>Hook Java方法</li><li>4.0 - 9.0</li><li>继承XC_MethodHook</li><li>DexposedBridge.hookXX用于注册</li><li>DexposedBridge.findXX用于查找</li></ul></li><li>无侵入性</li><li>基于Dexposed来hook</li><li>Hook了ArtMethod指向的函数指令, 指向自己的片段</li><li>兼容性问题大, 开源不能带入线上环境</li></ul></li></ul></li><li>线上内存问题解决一般方案<ul><li>检测内存使用达到一定程度, 使用Debug.dumpHprofData()</li><li>文件太大, 不易上传, 虽然可裁剪</li></ul></li><li>完整方案<ul><li>监控待机内存, 重点模块内存, OOM率<ul><li>ActivityManager#getProcessMemoryInfo</li><li>Debug.MemoryInfo#getMemoryStat</li><li>读取</li></ul></li><li>整机或者重点模块GC次数, GC时间<ul><li>Debug.startAllocCounting</li><li>Debug.getGlobalAllocCount() &lt; 6.0</li><li>Debug.getRuntimeStat(“art.gc.gc-xxx”) &gt; 6.0</li></ul></li><li>增强型LeakCanary<ul><li>ResourceCanary</li><li>自己找怀疑点</li><li>只分析Retain size大的</li><li>对象裁剪, 不全加入内存</li></ul></li><li>开LargeHeap</li><li>onTrimMemory/onLowMemory, 自我释放</li><li>使用SparseArray</li><li>谨慎使用SharedPreference</li></ul></li></ul></li><li>布局优化<ul><li>16ms发送VSync触发渲染</li><li>手机刷新频率一般是60Hz</li><li>Systrace查看帧率<ul><li>Frames</li><li>会给出一些Alert</li></ul></li><li>LayoutInspector查看布局层次</li><li>Choreographer<ul><li>API 16以上</li><li>可以获取FPS</li><li>Choreographer.getInstance().postFrameCallback</li></ul></li><li>原生布局加载优化<ul><li>读取资源使用IO<ul><li>?X2C?Async?</li></ul></li><li>创建View使用反射<ul><li>LayoutInflater.Factory/2<ul><li>创建一个Hook</li><li>全局替换自定义View的创建</li><li>LayoutInflaterCompat.setFactory2</li></ul></li></ul></li><li>AsyncLayoutInflater<ul><li>内部没有用Compat, 不能用Factory</li><li>View不能有创建Handler或者使用myLooper, 因为没调用prepare</li><li>不支持Fragment, 这个通过privateFactory构建的</li><li>父布局的generateLayoutParams必须线程安全</li><li>默认queue的size只有10</li></ul></li></ul></li><li>获取界面打开耗时<ul><li>Hook setContentView <ul><li>AspectJ<ul><li>excution setContentView</li></ul></li><li>ARTHook<ul><li>DexposedBridge.findAndHookMethod</li></ul></li></ul></li></ul></li><li>获取每一个控件耗时<ul><li>LayoutInflater.Factory/2</li></ul></li><li>X2C<ul><li>XML通过Apt转换为Java</li><li>@Xml让Java知道XML</li><li>X2C.setContentView</li><li>有的xml属性Java不支持</li><li>如果想要使用Compat的View做兼容, 需要自己修改X2C</li></ul></li><li>视图绘制优化<ul><li>减少层级</li><li>宽而浅, 避免前而深<ul><li>由上到下元素尽量在一个Group内</li><li>由左到右, 布局深度更浅</li></ul></li><li>不嵌套RelativeLayout</li><li>不在嵌套的LinearLayout里使用weight</li><li>多使用merge</li><li>避免过度绘制<ul><li>去掉多余背景色</li><li>减少复杂shape使用</li><li>不免空间重叠</li><li>自定义View使用clipReact屏蔽遮盖view绘制</li></ul></li><li>使用ViewStud延迟</li><li>onDraw不要创建大对象</li></ul></li><li>所使用的工具<ul><li>Choreographer -&gt; 帧率 线上</li><li>AOP, ArtHook -&gt; 统计耗时 线上</li><li>Systrace -&gt; 每一帧的耗时 线下</li><li>Layout Inspector -&gt; 布局层级 线下</li></ul></li></ul></li><li>App卡顿优化<ul><li>代码, 内存, 绘制, IO …</li><li>工具<ul><li>CPU Profiler<ul><li>Debug.startMethodTracing</li><li>Debug.stopMethodTracing</li><li>开销大</li></ul></li><li>Systrace<ul><li>API 18</li><li>TraceCompat</li><li>systrace.py -t 10 [options] [categories]</li><li>轻量级, 开销小</li><li>CPU利用率可视, 帧卡顿给出建议</li></ul></li><li>StrictMode<ul><li>运行时检测</li><li>线程策略<ul><li>自定义耗时调用<ul><li>detectCustomSlowCalls()</li></ul></li><li>磁盘读写<ul><li>detectDiskReads</li></ul></li><li>网络请求<ul><li>detectNetwork</li></ul></li></ul></li><li>虚拟机策略<ul><li>Activity泄露<ul><li>detectActivityLeaks</li></ul></li><li>Sqlite泄露<ul><li>detectLeakedSqlLiteObjects</li></ul></li><li>实例数检测<ul><li>setClassInstanceLimit</li></ul></li></ul></li></ul></li></ul></li><li>线上自动化监测<ul><li>原理<ul><li>Looper在dispathMessage的时候前后都会调用mLogging, 可用于监控耗时</li><li>通过seetMessageLogging</li></ul></li><li>AndroidPerformanceMonitor<ul><li>基于之上的原理, 时间超了就说明卡了</li><li>BlockCanary</li><li>非浸入</li><li>不足与优化<ul><li>只有T2时刻的堆栈, 可能不能表现卡顿原因</li><li>优化方案就是高频多次采集</li><li>对多次卡顿堆栈进行去重, 减少数据量</li></ul></li></ul></li></ul></li><li>ANR<ul><li>ActivityManagerService里定义了<ul><li>KeyDispatchTimeout 5s</li><li>BroadcastTimeout 前台10s, 后台60s</li><li>ServiceTimeout 前台20s, 后台200s</li></ul></li><li>ANR弹出会多余5s, 因为要写入堆栈信息</li><li>导入/data/anr/traces.txt分析</li><li>线上ANR监控<ul><li>低版本通过FileObserver监控文件变化</li><li>ANR-Wartchdog<ul><li>自有线程向UIhandler发消息</li><li>然后Sleep等待计数器增加</li><li>如果醒来发现没有增加, 说明ANR了, 就抛异常, 并且打印主线程堆栈信息</li><li>可以复写Listener, 自己处理异常</li></ul></li></ul></li></ul></li><li>单点卡顿监控:<ul><li>AspectJ与ArtHook<ul><li>AspectJ只能往自己或者lib里方法, 不支持系统方法</li><li>ArtHook则可以在系统方法调用的时候进行hook</li></ul></li><li>IPC问题监控<ul><li>关注点<ul><li>IPC调用类型, package manager等</li><li>次数, 耗时</li><li>堆栈, 发生的线程</li></ul></li><li>adb监控<ul><li>adb shell am trace-ipc start</li><li>adb shell am trace-ipc stop –dump-file xxx.txt</li></ul></li><li>Hook IPC数据传输<ul><li>BinderProxy#transact</li></ul></li></ul></li><li>IO, DB, View绘制</li></ul></li><li>界面秒开<ul><li>轻量级AOP框架, Lancet<ul><li>编译速度快, 增量编译</li><li>API简单, 没有多余的代码插入Apk中, 只有自己hook的</li><li>API<ul><li>@Proxy 对系统API进行Hook, 传入方法名</li><li>@TargetClass 指定Hook所在的<ul><li>scope<ul><li>SELF </li><li>DIRECT SELF+直接子类</li><li>ALL SELF+所有子类</li><li>LEAF 叶子节点</li></ul></li></ul></li><li>@Insert 操作App或者lib的类<ul><li>mayCreateSuper<ul><li>true 如果方法不存在, 就创建</li></ul></li></ul></li><li>Origin.call() 调用原有方法</li></ul></li><li>检测onWindowFocusChange - onCreate就是页面打开时间</li><li>监控生命周期函数耗时, 以及生命周期函数之间转换的耗时</li></ul></li><li>思路<ul><li>Systracce分析</li><li>异步+延迟初始化</li><li>异步Inflate, X2C, 绘制优化</li><li>提前获取数据</li></ul></li></ul></li><li>监控盲区<ul><li>只知道耗时了, 不知道具体做了什么</li><li>线上也不好操作</li><li>线下检测<ul><li>TraceView可以查看每一个线程都做了什么</li><li>还可以监控系统调用</li><li>GC可以通过log或者通过systrace的HeapTaskDaemon线程查看</li></ul></li><li>线上检测<ul><li>使用定制化的Handler监控sendMessage跟dispatchMessage</li><li>sendMessage保存msg记录时间, 调用栈, dispatchMessage拿出msg, 检测耗时, 上报调用栈</li><li>使用gradle插件编译期替换bytecode</li><li>didi的DroidAssist方便替换</li></ul></li></ul></li><li>卡顿优化不同阶段<ul><li>线下通过系统工具定位, 通过异步或者延时解决</li><li>线上自动化卡顿方案, 通过消息机制捕获上报, 包括ANR上报<ul><li>改进方案, 高频采集, 分析重复堆栈  </li></ul></li><li>线下监控与线上监控工具建设<ul><li>线下关注提前暴露, 线上关注自动化, 全面性, 灵敏度</li><li>对于达不到阈值的小卡顿, 线下AOP对一些耗时代码hook, 如IPC, IO等, 分析数据</li><li>线下Hook Handler的两个方法, 统计时间与堆栈信息</li><li>线上还监控秒开时间, 生命周期之间耗时</li></ul></li></ul></li></ul></li><li>线程调度<ul><li>普通CPU调度采用公平分配</li><li>Jvm线程调度根据优先级分配时间片</li><li>Android调度是抢占式<ul><li>nice<ul><li>在Process中定义</li><li>越小优先级越高</li><li>默认是0</li></ul></li><li>cgroup<ul><li>根据群组调用, 防止很多后台压制前台</li><li>优先级低的线程会进后台group</li><li>不在前台运行的程序的线程也会进去</li></ul></li></ul></li><li>线程太多会导致CPU频繁切换, 降低效率</li><li>工作量与优先级应该成反比</li><li>线程有继承性, 在UI线程创建的子线程就会抢占UI线程的时间片</li><li>线程执行的过程中, 也可以改名字与优先级</li><li>为了让子库做到线程收敛, 可提供一个setExecutor的方法统一设置</li><li>分类设置线程池<ul><li>如果IO密集型, 不消耗CPU, 线程池可以设置的很大</li><li>CPU密集型的线程大小要与核心数相关</li></ul></li></ul></li><li>网络优化<ul><li>维度<ul><li>流量消耗<ul><li>一段时间的消耗, 不同网络类型, 前台后台</li><li>流量消耗均值, 异常率, 流量消耗多, 次数多, 文件大等</li><li>所有网络请求Request/Response本地监控</li></ul></li><li>质量监控<ul><li>请求时长, 成功率, 失败率, Top失败接口</li></ul></li><li>其他消耗<ul><li>成本, 带宽, CDN</li><li>耗电</li></ul></li></ul></li><li>工具<ul><li>NetworkProfiler<ul><li>监控发送接收, 连接数</li><li>手动需要开启高级分析 (API小于26)</li><li>只支持URLConnection与OkHttp</li></ul></li><li>抓包工具<ul><li>Charles (mac)</li><li>Fiddler (windows)</li><li>WireShark (底层抓包)</li><li>Stetho (chrome)</li></ul></li></ul></li><li>获取流量消耗<ul><li>本地测试<ul><li>流量管理关闭其他app</li><li>抓包工具只允许本App联网</li></ul></li><li>线上获取<ul><li>TrafficStats API8(2.2)之后 重启之后的流量数据<ul><li>getUidRxBytes</li><li>getTotalTxBytes</li></ul></li><li>NetworkStatsManager API23(6.0)之后<ul><li>querySummary 返回bucket, 判断uid过滤本app数据</li><li>bucket getRxBytes getTxBytes</li></ul></li></ul></li><li>前台与后台<ul><li>定时+统计+前后台标记</li><li>每隔30s进行统计一次</li></ul></li></ul></li><li>网络优化<ul><li>添加配置使用http缓存<ul><li>NonetworkIntercepter, 无网环境打开Force Cache</li></ul></li><li>增量更新</li><li>数据gzip压缩</li><li>etag</li><li>图片压缩后上传<ul><li>Luban</li></ul></li><li>合并网络请求<ul><li>批量上传, 如上报数据</li></ul></li></ul></li><li>图片相关<ul><li>先试用缩略图</li><li>使用webp</li></ul></li><li>质量相关<ul><li>成功率与速度</li><li>dns优化<ul><li>使用HttpDns绕过运营, 不使用dns53端口而使用80</li><li>阿里云 httpdns.aar</li><li>通过实现Dns接口设置给okhttp</li></ul></li><li>http版本<ul><li>1.0 tcp不复用</li><li>1.1 长连接, 复用, tcp上的http是按顺序</li><li>2.0 tcp上的http同时发送多个请求, 类似于spdy</li></ul></li><li>监控<ul><li>请求耗时, 成功率, 错误码<ul><li>添加okhttp EventListener, 监控每个环节</li><li>通过EventListenerFactory加入okhttp </li></ul></li><li>图片加载每一步耗时<ul><li>Fresco 设置RequestListener      </li></ul></li></ul></li><li>其他<ul><li>容灾, 如果多次连接不上, 就不要请求了</li><li>cdn加速, 更新则需要清缓存</li><li>减少传输量, 时机, 频率</li><li>Okhttp请求池<ul><li>Dispatcher</li><li>okhttp限制了同域名最多请求个数为5, 如果单域名, 可以增加</li></ul></li></ul></li></ul></li><li>体系化<ul><li>线下测试<ul><li>只开本App</li><li>请求有误, 多余, 切网, 弱网, 无网</li></ul></li><li>线上监控<ul><li>服务端<ul><li>请求耗时, 地域, 时间段, 版本, 机型</li><li>失败率, 包括业务失败与请求失败</li><li>统计Top失败接口</li></ul></li><li>客户端<ul><li>接口每一步信息, 包括DNS解析, 连接建立, 请求包大小等</li><li>请求次数, 包大小, 失败原因</li><li>图片监控</li></ul></li></ul></li><li>异常监控<ul><li>服务器防刷</li><li>大文件预警 </li><li>异常兜底, 一定时间错误次数太多, 就不能访问, 或重试次数增加</li><li>单点问题查看日志分析</li></ul></li></ul></li></ul></li><li>电量优化<ul><li>统计电量消耗<ul><li>系统电量排行</li><li>通过注册Action_Battery_Changed广播</li><li>Battery Histrian 5.0+ 线下使用</li></ul></li><li>测试<ul><li>复杂运算, 视频</li><li>传感器相关, 耗电, 发热, 使用时长等</li><li>后台静默</li></ul></li><li>Battery Histrian<ul><li>基于dumpsys, 试用前先重置电量, 再开启电量统计, 再通过adb导出<ul><li>adb shell dumpsys batterystats –reset</li><li>adb shell dumpsys batterystats –enable full-wake-history</li><li>adb bugreport bugreport.zip</li></ul></li><li>可以通过docker安装histrain, 或者上<a href="http://bathist.ef.lc" target="_blank" rel="noopener">http://bathist.ef.lc</a></li></ul></li><li>运行时能耗<ul><li>能耗设定<ul><li>adb pull /system/framework/framework-res.apk</li><li>反编译找到power_profile拿到能耗</li><li>能耗是厂家设置的, 可以帮助分析哪些比较耗电</li></ul></li><li>AOP统计耗电组件调用时间, 次数<ul><li>使用Lacent @Insert @TargetClass</li><li>对于WakeLock, Thread.run</li></ul></li></ul></li><li>总结<ul><li>降低CPU时间片占用, 通过traceview, cpuprofiler, 降低后台工作</li><li>网络请求合并, 数据压缩</li><li>不要轮询进行操作业务</li><li>定位使用低精度, 网络定位, 使用完立即关闭</li><li>耗电操作后台关闭, 如动画</li><li>WakeLock及时释放, 设置超时时间, 释放最好写到finally中</li><li>如需要保持长亮, 可使用KeepScreenOn</li><li>使用JobScheduler/WorkManager, 设置运行场景</li></ul></li></ul></li><li>APK瘦身<ul><li>头部App都出Lite版, 提升转化率</li><li>Apk组成<ul><li>classes.dex 代码</li><li>资源 res, asserts, resource.arsc</li><li>so相关 lib</li></ul></li><li>分析工具<ul><li>apktool 反编译</li><li>analyze apk studio自带</li><li>nimbledroid.com 分析网站<ul><li>文件大小排行</li><li>dex, sdk方法数</li><li>启动时间, 内存占用</li></ul></li><li>classyshark github开源<ul><li>支持apk, jar, class, so</li></ul></li></ul></li><li>代码优化<ul><li>混淆</li><li>第三方库统一, 选小库<ul><li>android methods count插件</li><li>可以引入第三方库的部分模块, 或者修改源码剥离</li></ul></li><li>移除无用代码<ul><li>通过AOP统计activity是否还在被用</li><li>通过AOP看看类的构造还有没有被调用<ul><li>@After(excution(xxx.new(..)))</li></ul></li></ul></li></ul></li><li>资源优化<ul><li>无用资源<ul><li>右键refactor-&gt;remove unused resources</li><li>或者通过Analyze里面run inspect by name, 搜unused</li></ul></li><li>图片压缩<ul><li>tinypng.com及tinypngplugin</li><li>jpeg比png小很多</li></ul></li><li>资源混淆<ul><li>AndResGuard github项目</li><li>gradle引入插件, 添加配置</li><li>通过gradle task resguardRelease</li><li>会将resource.resc中的名字变短</li></ul></li><li>其他<ul><li>图片保留一份 如xdpi</li><li>资源放远端</li></ul></li></ul></li><li>so瘦身<ul><li>加解密, 音视频一般都是用so</li><li>在lib设置abifilters设置支持架构, 一般留armeabi, 兼容其他, 但是不会优化</li><li>可以把对性能要求高的so单独加入到armeabi中, 通过代码逻辑进行加载</li><li>so动态下载</li><li>插件化<ul><li>atalas</li><li>replugin</li></ul></li><li>CI监控大小变化</li></ul></li></ul></li><li>稳定性优化<ul><li>维度<ul><li>Crash</li><li>性能</li><li>业务高可用</li></ul></li><li>重要的是在于预防</li><li>Crash率<ul><li>UV评估影响范围, PV评估影响程度</li><li>启动Crash, 启动10秒后crash</li><li>优先解决新增crash (增量与存量)</li><li>99.8%是底线 万分之更优秀</li></ul></li><li>业务高可用<ul><li>主流程核心路径监控<ul><li>AOP采集, 统一上传</li><li>阈值报警, 趋势报警, 特定指标报警</li></ul></li><li>异常监控<ul><li>catch的代码块</li><li>异常逻辑, 一些逻辑返回false, 一些参数为空, 进行上报</li></ul></li><li>兜底<ul><li>关闭功能</li><li>跳转分发中心, 不要进入有错误的页面</li></ul></li></ul></li><li>容灾<ul><li>功能开关, remote toggle</li><li>统跳中心, 重定向到临时界面或其他</li><li>热修复<ul><li>tinker (把修复的dex里的elements放在host的pathlist中elements之前)</li><li>andfix (method hook, dalvik修改函数指向, art hook entrypoint)</li><li>robust (跟instant-run一样插装在diapatch)</li><li>如果rn之类的, 可以直接升级</li></ul></li><li>安全模式<ul><li>多次启动失败, 就重置app</li><li>太严重则需要阻塞热修</li><li>服务器多次失败, 网络库可以拒绝继续发送请求, 保护服务器</li></ul></li></ul></li><li>长效治理<ul><li>开发阶段<ul><li>增强编码功底, codereview等</li><li>架构优化, 能力收敛, 如界面切换用路由, 统一容错, 统一网络库, 统一网络错误处理</li><li>容错测试, 如服务器宕机, 脏数据, 特殊机型等边界</li><li>云测平台</li></ul></li><li>合代码<ul><li>编译检测, 静态扫描</li><li>合入跟主干一样的分支, 预编译, 防止代码冲突</li><li>主流程回归测试, 自动化执行</li></ul></li><li>发布环节<ul><li>多轮灰度, 筛选忠实用户</li><li>针对低于, 版本定向灰度</li><li>灵敏监控, 热修, 容灾等UI</li></ul></li></ul></li></ul></li><li>列表页卡顿<ul><li>图片不要太大</li><li>滑动过程中停止图片加载</li><li>列表页用线程池, 并设置为background, 不抢占UI</li><li>TextView优化<ul><li>BoringLayout 单行, StaticLayout 多行, DynamicLayout 可编辑</li><li>异步创建StaticLayout</li><li>可以使用facebook的TextLayoutBuilder优化</li></ul></li><li>使用StringBuilder拼接而不是直接+<ul><li>常量直接拼接性能最高, jvm直接拼好</li><li>变量拼接使用StringBuilder更好, 虽然直接拼接也会转换builder, 但还会多一些临时变量</li><li>循环内不要使用拼接, 因为会每次循环都创建出一个StringBuidler</li></ul></li></ul></li><li>储存优化<ul><li>SP优化<ul><li>系统SP问题<ul><li>初始化慢, 虽然异步, 但UI线程需要等</li><li>写入慢, 全量写入</li><li>卡顿, apply会与丢失的可能, 而且SP在一些时候, 如onPause进行写入磁盘</li></ul></li><li>使用腾讯MMKV取代<ul><li>mmap+文件锁</li><li>增量写入, 使用protobuffer</li><li>支持sp迁移</li></ul></li></ul></li><li>日志优化<ul><li>mmap 内存映射文件</li><li>使用微信的Xlog或者美团的Logan</li></ul></li><li>其他<ul><li>常用数据缓存</li><li>文件流缓存4-8K</li></ul></li></ul></li><li>Webview异常监控<ul><li>webview优化<ul><li>容器预热, 资源预加载</li><li>参考VasSonic</li></ul></li><li>检测白屏<ul><li>通过getBitmapFromView</li><li>用每一个像素点对比第一个</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近断断续续的看完了Android性能优化相关的一个系列视频, 感觉总结的非常不错, 很多地方都有深受启发.&lt;br&gt;期间也穿插着停下来研究了一些相关的技术,框架,与工具, 并做了一些小笔记, 现将整个体系总结下来, 以便翻阅与温习.&lt;/p&gt;
    
    </summary>
    
      <category term="Android Note" scheme="http://talentprince.github.io/categories/Android-Note/"/>
    
    
      <category term="Android" scheme="http://talentprince.github.io/tags/Android/"/>
    
      <category term="Note" scheme="http://talentprince.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>Refresh Java</title>
    <link href="http://talentprince.github.io/2020/06/02/Refresh-Java/"/>
    <id>http://talentprince.github.io/2020/06/02/Refresh-Java/</id>
    <published>2020-06-02T09:54:52.000Z</published>
    <updated>2020-09-08T04:28:35.760Z</updated>
    
    <content type="html"><![CDATA[<p>当你的知识来源于实践, 你可能会忽略很多细节.<br>当你的知识来源于阅读, 你可能会很快的忘掉.</p><p>那么, 不如在空闲之余, 浏览一遍, 把觉得有必要的记录下来, 也便于以后温故而知新, 何乐而不为呢?<br>于是便有了这138条从Thinking In Java中记下来的条目.<br>这本书不同于其他的Java教材, 它的作者更喜欢通过与C++进行对比来阐述Java的不同思想, 如果读者有一定C++知识储备, 会更好的理解Java的很多设计.</p><a id="more"></a><ul><li><code>&gt;&gt;&gt;</code>无符号移位</li><li><code>for(1 : range(10))</code>可实现计数器循环foreach</li><li><code>printnb</code>不会换行放在缓冲区, <code>print()</code>将其输出</li><li>带标签的<code>break</code>与<code>continue</code>可以跳出嵌套循环</li><li>构造调用<code>this(xxx)</code>只能调用一次,并且在最开始</li><li>Java的<code>finalize</code>是在垃圾回收时候调用的, 一般是配合释放ndk相关的底层空间</li><li>静态对象只有在所属类被实创建时才会被加载</li><li>构造方法其实也是静态方法</li><li><code>int[] a</code>与<code>int a[]</code>都可以,  前一种更合理, 后一种像C++</li><li>数组初始化花括号最后一个逗号可选, 即<code>{x,y,z,}</code></li><li>没有写<code>package</code>的类默认属于目录所在包</li><li>即时类不是<code>public</code>, 但是<code>main</code>方法依旧可以被调用</li><li>子类调用父类方法, 父类再调用<code>public</code>方法则可能会调用到子类所继承的方法(如果覆盖的话), 如果该方法在父类是<code>private</code>, 则只会调用父类方法, 因为不能覆盖, C++如果不是虚函数, 则只会调用父类的, 因为<code>this</code>内函数地址编译时就确定了</li><li><code>Java</code>函数没有隐藏/屏蔽特性, <code>C++</code>子类会同名函数会隐藏/屏蔽掉父类所有同名重载函数, 因为它会先查找函数名, 再找具体类型.</li><li>早起<code>JVM</code>会根据<code>final</code>类型来内联函数, 现在已经有更先进的技术了, 只为了禁止覆盖.</li><li>覆盖<code>private final</code>其实是假象而已</li><li>面向对象特性, 抽象, 继承, 多态</li><li><code>Java</code>除了<code>static</code>与<code>final</code>外函数都是后期绑定的, 即动态绑定</li><li><code>Java</code>构建子类时父类构造函数调用已被覆盖的函数会触发动态绑定, 但此时子类未完成构造, 所以类内对象都为空值. <code>C++</code>在处理同样问题时更加合理, 由于虚表指针未完整建立, 所以不会触发动态绑定, 无论是构造还是析构函数, 都是直接调用而非虚调用, 为了避免问题, 尽量不要在构造函数内调用可被覆盖的函数, 可以调用<code>final</code>函数来防止出错</li><li>Java5加入被覆盖方法返回参数协变(向下转型)</li><li>interface中定义的所有常量都是自动static fianl的</li><li>类内部定义的private接口可以进行内部public的实现, 但在外部无法看出任何有关私有接口的类型信息, 即不可向上转型</li><li>嵌套在接口内的接口自动public</li><li>private接口不能在定义它的类之外被实现</li><li>内部类持有的外部类对象学术名叫Enclosing Object(外围对象)</li><li>创建非静态内部类必须通过<code>.new</code>来创建, 即使用外部对象来创建内部对象</li><li>private内部类可以帮助隐藏具体实现, 外部类可以提供其实例的向上转型</li><li>内部类还可以放在方法里缩小scope, 作用于与局部变量一样</li><li>匿名内部类没有命名构造器, 只有实例初始化传参, 或者通过final形参直接在内部使用</li><li>static内部类叫作嵌套类, 它不持有外围对象</li><li>接口内部可以放嵌套类, 可以这么搞个测试在里面</li><li>内部类更重要的作用是有效的实现了<code>多重继承</code>, 比如需要继承多个抽象类而不是接口</li><li>Java使用内部类实例做回调来实现闭包功能</li><li>Java通过接口+内部类可以结果C++多重继承所能解决的问题</li><li>List/Set/Queue都继承Collection, Map独立有接口, 两者唯一的关系是Map提供一个返回Collection的entrySet与values</li><li>Queue虽然继承于Collection, 但Queue有自己独立的接口, 创建Queue不需要Collection的方法</li><li>LinkedList也继承于Dequeue</li><li>当我们在异常处理的终止与恢复中选择时, 开始往往是恢复, 最后趋向终止</li><li>对自定义异常的扩展可能没太大用, 因为更多的时候只关注异常类型</li><li>重新抛异常会保留之前的信息, 不会新加入抛出点的信息, 除非调用fillInStackTrace()</li><li>重新抛出新的异常则会清楚之前的信息</li><li>Finally用来清理，C++靠的是析构函数</li><li>即便有break，continue，return，finally始终都会被执行</li><li>Finally中return会吃掉try内的异常</li><li>Finally中抛异常会吃掉try内的异常</li><li>基类构造抛出异常不用在子类限制必须抛出， 因为基类构造必须调用， 并且需要处理</li><li>子类方法不能抛出基类未声明过的异常，这样直接调用基类接口不用处理，实际运行可能会出错</li><li>子类方法可以抛出基类声明异常的子类异常</li><li>对于构造需要清理的对象，如文件，应该将构造失败单独try/catch，而close方法放在内部的try/catch只对创建成功后进行清理</li><li>字符串正则表达式查找find匹配任意位置，lookingAt只从开头匹配， matches匹配全部</li><li>正则Pattern可以用<code>|</code>与操作进行组合</li><li>Java默认类型转换会RTTI，但是C++不会</li><li>setAccessable只是控制是否安全检测，public默认仍是false，关闭后速度快</li><li>泛型会被擦除， ArrayList<integer>跟ArrayList<string>一样，通过getTypeParameters()也只能得到占位符</string></integer></li><li>C++泛型不会擦除， 所以编译的时候仍然可以获得具体使用类型，所以定义时泛型对象就可以调用实际类型的方法，Java得通过泛型extends来实现</li><li>擦除主要是为了兼容低版本</li><li>C++可以直接new T()而Java只能通过泛型当参数newInstance，对于没有默认构造的Java可以传入泛型工场进行构造</li><li>泛型可以通过extends来限制边界, 并且可以通过<code>&amp;</code>增加多个边界, 类应该放在接口的前面</li><li><code>Clazz&lt;Apple&gt;</code>只能向上转型为<code>Clazz&lt;? extends Fruit&gt;</code>, 而不能<code>Clazz&lt;Fruit&gt;</code>, <code>Clazz&lt;Food&gt;</code>可以向下转型为<code>Clazz&lt;? super Fruit&gt;</code></li><li><code>&lt;? extends X&gt;</code>指定上界, 无法进行add操作, 因为它是由子类List向上转型来的, 子类多种多样不确定, 所以不让你放, 而get返回<code>X</code>, <code>&lt;? super X&gt;</code>指定下届, 是由父类List向下转型来的, 可以add <code>X</code>的子类, 内部可安全强转为同一个父类(X的某个父类), 但get就不清楚是哪个父类, 所以只能拿到<code>Object</code></li><li>类不能实现泛型接口的两种变体</li><li>自限定泛型继承, <code>class SelfBounded&lt;T extends SelfBounded&lt;T&gt;&gt;</code>, 任何继承SelfBounded类的泛型类型必须也是SelfBounded的导出类</li><li>继承自限定类可保证接口函数导入类唯一, 参数为限定类泛型指定</li><li>C++可以通过<code>template&lt;class T&gt; : T</code>来进行混型, 有一些AOP方面的思想</li><li>Java可以通过继承多个接口, 并分别初始化的时候进行实现, 然后再代理进行混型</li><li>Java也可以通过装饰器进行混型的概念, 但是由于装饰器其实只有最后一层是暴露的, 失去了内部各层的特性, 而混型是基于继承, 保留所有特性</li><li>Java还可以通过动态代理, 将所有需要混型的实现与接口导入, 在invoke的时候查表得到对应的Delegate来调用方法, 实现混型, 但是不方便, 也不易懂, 不如C++静态的好</li><li>对于一些脚本语言, 类型检测是在运行期, 所以可以使用潜在类型机制, 进行代码复用, 如Python, 只需要方法名一样, 或者称为鸭子类型机制, 只要走起来像鸭子, 叫起来像鸭子, 就当做鸭子…</li><li>由于C++的泛型在编译器可以检测T支持的方法, 可以直接对泛型类型调用相应函数,  也可以做到类似Python的效果. 表面上看C++的泛型成了弱类型, 但实际上是安全的, 称之为具有通气门的强类型</li><li>Java的泛型出现的晚, 已经不具备这种潜在类型机制了, 可以认为比他们更缺乏泛化性</li><li>Java虽然不能潜在类型, 但可以通过泛型, 一定程度补偿了这样的灵活性</li><li>虽然Java的Map有泛型, 但是<code>containsKey</code>, <code>get</code>之类的方法不受泛型约束, 而C++的Map是会在编译器检查类型的. 主要原因是泛型对于Java是后来引入的, 而对于C++在最初的标准版本里就引入了</li><li><code>Arrays.deepToString()</code>可以给数组填充初始默认值</li><li><code>Arrays.fill()</code>可以给数组填充指定值</li><li>无法创建泛型数组, 但是类型可以被赋值</li><li><code>Array.newInstance</code>用反射的Array可以生成任意类型, 指定大小的数组</li><li><code>System.arraycopy</code>可以实现高效的数组内存拷贝</li><li>自己实现Collection不一定需要支持所有的操作, 虽然平时用的List, Map, Set都实现了</li><li><code>Arrays.asList()</code>生成的是固定大小数组, 不支持改变大小的操作, 使用会抛异常</li><li><code>LinkedList</code>实现了<code>Queue</code>接口, 但是Java没有<code>Dequeue</code>接口, 不过它已经实现了所需方法<code>getLast</code>, 所以可以自己包装 </li><li><code>TreeMap</code>是唯一带<code>subMap</code>的Map, 返回一个子树, 它是<code>SortedMap</code>的唯一实现</li><li><code>LinkedHashMap</code>的散列是一个LRU, 没有被使用的数据放在前面</li><li>通过<code>Collection.synchronized</code>可以创建不同的线程同步子类</li><li><code>SoftReference</code>跟<code>WeakReference</code>都可以单独使用, 而<code>PhantomReference</code>必须跟<code>ReferenceQueue</code>一起使用</li><li>普通对象被gc后会进入<code>Finalizable</code>状态, finalize未被调用,  仍就可以有机会复生 (复写finalize), 当finalize调用后,  会进入<code>Finalized</code>状态, 下次GC会被回收</li><li><code>PhantomReference</code>天生就是finalized状态, GC发生后就清掉了</li><li><code>Stack</code>,<code>Vector</code>都是1.0/1.1版本的东西, 为了兼容性而保留了</li><li>1.4之后引入了<code>nio</code>相较于之前的被称之为新IO</li><li>1.1加入的Reader跟Writer是为了国际化兼容16位Unicode字符</li><li><code>BufferedInputFile.read</code>可以读取文件到Reader里, 在进行其他的包装, 如<code>StringReader</code>, <code>BufferedReader</code>, 没有快捷方式.</li><li>写入文本可以使用<code>PrinterWriter</code>简化, 直接<code>writer.println</code></li><li><code>System.out/in/err</code>被称为标准IO, 通过<code>setOut/In/Err</code>可以进行重定向</li><li><code>javap</code>随jdk一起发布做反编译</li><li>旧IO底层已经用nio重构过了</li><li>旧的<code>FileInputStream</code>, <code>FileOutputStream</code>等被修改支持生成一个<code>Channel</code>, Writer跟Reader不支持, 但是Channel有方法可以生成他们</li><li>Channel通过<code>ByteBuffer</code>进行读写, 写之前需要<code>flip</code>准备缓冲区, 读之前需要<code>rewind</code>回到数据头,  再通过<code>asCharBuffer</code>转换后打印</li><li><code>ByteBuffer.flip</code>是将position设置为0, 将limit设置为当前位置, 准备写;  <code>ByteBuffer.rewind</code>是将position设置为0, 并将marker清除, 准备读; <code>mark</code>会设置mark, <code>reset</code>会把position指向mark</li><li>通过ByteBuffer的<code>asCharBuffer</code>或者别的方法, 可以获得所谓缓冲器视图, 对缓冲器进行对应类型的<code>put</code>, 该缓冲器可通过其他as方法切换至其他的窗口进行输出</li><li>如果直接向缓冲器内写入Bytes, 那么无法通过<code>asCharBuffer</code>读出, 必须写入<code>UTF-16BE</code>才对应格式, 按Char读出不会乱码</li><li>通过<code>RandomAccesFile.map</code>可以产生<code>MappedByteBuffer</code>进行内存磁盘映射, 必须指定一个映射范围, 它的效率要比建立在nio之上的旧IO要快</li><li>Object序列化的文件, 必须能在找到类定义的环境下才能被反序列化成功, 否则会ClassNotFoundException</li><li>通过Serializable序列化, 内部有大量反射, 直接将二进制赋值,  不需要通过构造. 如果复写read/writeObject, 或者实现<code>Externalizable</code>接口, 自己实现序列化, 则需要有public默认构造, 没有反射, 效率高</li><li>静态成员变量不能自己序列化</li><li>枚举在编译的时候编译器会给加入<code>values</code>跟单参的<code>valueOf</code>静态方法</li><li>所以枚举向上转型Enum就没有values方法了, 但可以通过Class中<code>getEnumConstant</code>方法反射</li><li>构建枚举的枚举可以通过将枚举Class当构造参数传入枚举对象, 并且通过<code>geEnumConstant</code>覆盖其values</li><li><code>EnumSet.allOf</code>可以传入一个枚举类class, <code>of</code>则是手动传入N个枚举类型</li><li>枚举可以添加自定义方法, 每一个实例独自实现,  但是枚举实例不能像普通类一样作函数参数, 因为每一个实例其实是enum类型本身</li><li>注解不能继承, 注解的字段要么定义默认值, 要么使用时传入, 不能为空</li><li>线程设置为Deamon模式, 主线程结束后就被杀掉了</li><li>Thread可以设置<code>setDefaultUncaughtExceptionHandler</code>, 不设置就会被default处理</li><li>测试资源竞争可以调用<code>Thread.yield</code>增加几率</li><li>Java也提供手动的<code>Lock</code>, return要写在try里确保在finally的unlock之前调用</li><li>如果想实现尝试获取, 不行放弃的话, 需要自己封装<code>ReentrantLock</code>, 使用<code>tryLock</code></li><li>多核处理器上可视性比原子性问题多得多, volatile会解决可视性问题</li><li>volatile如果已经被synchronized防护, 则不需要加; 如果只在一个任务中用, 也不用加; 如果依赖前值, 或者某个域的值, 那也无法工作</li><li>在C++中自加可能是原子性的, 但是Java中肯定不是</li><li><code>synchronized</code>最合理的是锁被调用对象this, 或者加方法上, 这样如果一个线程获得了锁, 其他synchronized的方法也都不能被别的线程调用了</li><li>IO与Synchronized的阻塞无法被打断, 关闭资源才可以释放锁, 并打断线程, 锁阻塞续采用<code>Lock.lockInterruptibly</code>才可以被打断</li><li>线程被中断一般需要有清理逻辑, 通过try/catch/fanilly来做</li><li><code>sleep()</code>, <code>yield()</code>不会释放锁, <code>wait()</code>期间对象锁会释放, 被notify后, 醒之前必须重新获得锁</li><li><code>wait</code>一般跟while循环配合, 因为在即将被唤起之前(调用notify的前后), 可能条件已经发生了改变</li><li>为了防止错过信号, 通常也需要通过while(cindition)来保护wait, 防止死锁</li><li>因为wait会释放锁, 而notify在synchronized区间内, 会在之前获取锁, 而wait被唤醒又会重新获取锁,  所以实际上使用notifyAll也只能唤起在等待的一个任务, 同样, 使用notify的时候, 应使等待条件一致, 如果条件不一致, 则只能使用notifyAll</li><li>可以synchronized锁Object以及wait/notify做同步, 也可以通过<code>ReentrantLock</code>生成condition, 通过await/signal/lock/unlock来操控</li><li>有时候使用一些同步对象也可以简化逻辑, 如<code>BlockingQueue</code></li><li>简单的线程同步也ke已用1.5引入的<code>CountDownLatch</code>做</li><li>相较于CountDown只能计数一边, <code>CyclicBarrier</code>可以重复利用, 第一个参数传入parties个数, 当await数量达到时会停止等待, 并且调用第二个参数Runnable执行, 可以再次触发await, 这样可以形成一个循环, 或者闭环</li><li>除了<code>BlockingQueue</code>之外, 还有其他类似的同步队列, 但需要实现一定的接口, 如<code>DelayBlockingQueue</code>, <code>PriorityBlockingQueue</code></li><li><code>SynchronousQueue</code>的put必须等待take</li><li>常用的Excutor有<code>CachedThreadPool</code>, <code>ScheduledThreadPool</code>, <code>FixedThreadPool</code>等</li><li><code>Semaphore</code>作为信号量, 可以设置次数, 多次acquire, 并通过release来释放信号, 区别于<code>ReentrantLock</code></li><li><code>Exchanger</code>可以作为一个类似管道的东西, 同时传递生产到消费</li><li>一般使用synchronized, 可读性强, 调优用Lock, 简单情况用Atomic, 有性能指标可以替换</li><li><code>CopyOnWriteArrayList</code>内部使用整个数组的副本进行操作, 最终原子替换, 性能高一些, <code>ConcurrentHashMap</code>与<code>ConcurrentLinkededQueue</code>类似, 只不过是部分复制再操作. 这两者读取过程都有乐观锁处理, 所以性能要比synchronized List/Map好, 尤其是在很少写入的情况</li><li>AtomicXXX有一些乐观加锁的函数, 如compareAndSet, 当提供的oldValue发生变化时, set失败</li><li>读写锁(ReentrantReadWriteLock)保证了读取数据的一致性, 当写锁被持有的时候, 读锁将不能获取, 其他时候可多次获取读锁</li><li>更多的时候多线程的问题要通过Task+消息队列, 但这个依赖于平台或者额外复杂的设计</li></ul>]]></content>
    
    <summary type="html">
    
      Thinking in Java
    
    </summary>
    
      <category term="Java" scheme="http://talentprince.github.io/categories/Java/"/>
    
    
      <category term="Note" scheme="http://talentprince.github.io/tags/Note/"/>
    
      <category term="Java" scheme="http://talentprince.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Refresh design pattern</title>
    <link href="http://talentprince.github.io/2019/09/30/Refresh-design-pattern/"/>
    <id>http://talentprince.github.io/2019/09/30/Refresh-design-pattern/</id>
    <published>2019-09-30T08:06:52.000Z</published>
    <updated>2020-09-08T04:28:35.768Z</updated>
    
    <content type="html"><![CDATA[<p>多年后, 再次翻阅设计模式书籍, 将每种模式的要点总结于此, 需要本身有一定设计模式基础, 再结合要点, 帮助更好理解与运用.</p><a id="more"></a><ul><li><p>策略模式 (Strategy)</p><ul><li>附加功能单独抽象不同接口</li><li>功能以组合方式引入抽象类</li><li>抽象类封装功能模块各调用</li><li>实现类可在构造中配置功能具体实现</li></ul></li><li><p>观察者模式 (Observer)</p><ul><li>被订阅者持有所有订阅者</li><li>数据更新可以直接推送</li><li>数据更新也可以通知加拉取</li><li>大程度解耦观察者与被订阅者</li></ul></li><li><p>装饰器模式 (Decorator)</p><ul><li>装饰器接口的简单实现叫做组件</li><li>持有组件对象的叫做装饰器</li><li>装饰是从里层的装饰器开始</li><li>最里层的装饰器会持有原始组件</li><li>各层通过对持有的底层对象进行包装完成所谓装饰并返回给上层</li><li>理论上可以做到一层套一层无穷尽</li></ul></li><li><p>工场方法模式 (Factory Method)</p><ul><li>解耦产品的实现与使用</li><li>产品需要进行抽象</li><li>工场方法定义创建产品的接口</li><li>工场方法内还可以封装使用过程</li><li>子工场配置自己的创建逻辑</li><li>工场方法常常与抽象工场结合</li><li>抽象工场定义了一组产品的创建</li><li>工厂方法的实现又用这些产品创建或组件具体的大产品</li><li>工厂方法通过继承来实现</li><li>抽象工场通过组合来实现(传入)</li></ul></li><li><p>单例模式 (Singleton)</p><ul><li>全局实例注意内存</li><li>多线程需要特殊照顾</li></ul></li><li><p>命令模式 (Command)</p><ul><li>解耦发请求者与执行请求者</li><li>命令内部可以直接执行也可以代理给被封装在内的接收者</li><li>命令支持撤销</li><li>宏命令包含多个命令同时调用</li></ul></li><li><p>适配器模式 (Adapter)</p><ul><li>对象适配器以组合来实现</li><li>类适配器以多继承来实现</li><li>新旧系统共用可双向适配</li></ul></li><li><p>外观模式 (Facade)</p><ul><li>从抽象层次看与适配器很像</li><li>外观模式创建新的简单接口</li><li>适配器模式使用已存在接口</li><li>新接口包装多个系统模块简化调用</li><li>老接口包装其他系统达到兼容</li></ul></li><li><p>模板方法模式 (Template Method)</p><ul><li>模板实现算法, 子类实现步骤</li><li>子类与父类尽量不能成环</li><li>好莱坞模式为子类全为回调方法</li><li>有默认实现的为钩子方法</li><li>策略用组合封装算法,模板用继承封装算法</li><li>工厂方法是特殊的模板方法</li></ul></li><li><p>迭代器模式 (Iterator)</p><ul><li>解耦游走数组而不要关心具体类型</li><li>集合类都有自己的迭代器</li><li>一般的迭代器具备hasNext与next两个方法</li><li>聚合器持有数据并创建迭代器</li></ul></li><li><p>组合模式 (Composite)</p><ul><li>组合模式的节点分为子节点与叶节点</li><li>子与叶都实现了同样的组合接口,所谓透明性</li><li>子节点会额外实现add与get</li><li>为了叶节点安全也可以具有不同接口</li><li>组合模式可以与迭代器共生</li><li>迭代器需要配合栈来实现树的遍历</li><li>子节点可以实现空迭代器来减少Null判断</li></ul></li><li><p>状态模式 (State)</p><ul><li>与策略模式类图相似</li><li>状态接口定义状态切换行为</li><li>所有状态实现统一接口</li><li>状态机定义并持有所有状态</li><li>状态机储存当前状态</li><li>状态切换由不同状态自己控制</li><li>状态内通过持有的状态机来切换下一状态</li></ul></li><li><p>代理模式 (Proxy)</p><ul><li>可分为远程代理与虚拟代理</li><li>与装饰者很像</li><li>代理更多的是控制真实对象的访问, 解耦客户与真实对象, 也可能帮助创建真实对象</li><li>装饰器更多是增加行为, 而且不创建对象</li><li>可通过工厂方法返回主体的代理</li><li>与适配器很像</li><li>代理不改变接口, 适配器改变接口</li><li>保护代理可以限制访问部分接口,更像适配器</li></ul></li><li><p>复合模式 (Compound)</p><ul><li>多用几种</li><li>比如MVC就融合了策略,组合,适配器等</li></ul></li></ul><hr><ul><li><p>一些冷门模式</p></li><li><p>桥接模式 (Bridge)</p><ul><li>与策略模式很像</li><li>主体都依赖于功能组件的抽象</li><li>策略模式的主体是具体算法的实现</li><li>桥接模式的主更抽象,需要子类来实现不同算法</li><li>可以做到主体和功能组件解耦</li><li>增加了复杂度</li></ul></li><li><p>生成器 (Builder)</p><ul><li>封装复杂对象的创建过程</li><li>隐藏内部实现</li><li>创建时需要对所创对象有更多认识</li></ul></li><li><p>责任链 (Resposibility)</p><ul><li>简单理解为一个Handler的对象链</li><li>比如很多程序里常用的Dispatcher链</li><li>或者很多系统启动时需要加载的数据链</li><li>不能保证一定会有对象对数据进行处理</li></ul></li><li><p>享元 (Flyweight)</p><ul><li>多个同样的实例可被一个方法控制, 就可以封装在一起轮询数组进行处理</li><li>但是不能有独立不同行为了</li></ul></li><li><p>解释器 (Intepretor)</p><ul><li>主要是做简单固定语法解析</li><li>抽象解释接口, 并实现多个解释器</li><li>如And, Or之类的, 可相互嵌套.</li><li>如果语法复杂, 种类繁多, 会不太适合</li></ul></li><li><p>中介者 (Mediator)</p><ul><li>解耦不同对象</li><li>它们只需要通知中介者, 中介者根据不同状态来控制整个逻辑</li><li>可能会让中介者逻辑过于复杂</li></ul></li><li><p>备忘录 (Momento)</p><ul><li>将对象的储存抽出来, 更好的维护了业务的内聚</li><li>一般会提供储存与获取接口</li><li>储存过程可能会耗时</li><li>可能需要考虑序列化</li></ul></li><li><p>原型 (Prototype)</p><ul><li>提供复制对象的方法</li><li>比如clone</li><li>如果对象层次深,复制起来可能复杂</li></ul></li><li><p>访问者 (Visitor)</p><ul><li>解耦对象与每个对象的具体操作, 如对电脑的不同部件进行不同操作</li><li>在对象种类变化小而操作变化大的时候使用</li><li>每一个对象实现visitor接口, 接受(accept)一个visitor,并把自己传给visitor (visit)</li><li>缺点是具体元素对访问者暴露, 而不是抽象接口</li></ul></li></ul><hr><p>有很多种分类方式, 不必拘泥, 也可忽略.</p><ul><li><p>分类方式 I</p><ul><li>创建型<ul><li>单例</li><li>抽象工厂</li><li>工厂方法</li><li>生成器</li><li>原型</li></ul></li><li>行为型<ul><li>模板方法</li><li>迭代器</li><li>状态</li><li>策略</li><li>观察者</li><li>命令</li><li>解释器</li><li>中介者</li><li>访问者</li><li>备忘录</li><li>责任链</li></ul></li><li>结构型<ul><li>装饰器</li><li>代理</li><li>外观</li><li>组合</li><li>适配器</li><li>桥接</li><li>享元</li></ul></li></ul></li><li><p>分类方式 II</p><ul><li>类<ul><li>模板方法</li><li>工厂方法</li><li>适配器</li><li>解释器</li></ul></li><li>对象<ul><li>单例</li><li>抽象工厂</li><li>装饰器</li><li>代理</li><li>外观</li><li>组合</li><li>适配器</li><li>迭代器</li><li>状态</li><li>策略</li><li>观察者</li><li>命令</li><li>桥接</li><li>享元</li><li>生成器</li><li>中介者</li><li>访问者</li><li>备忘录</li><li>责任链</li><li>原型 </li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      Design Pattern
    
    </summary>
    
      <category term="Design Pattern" scheme="http://talentprince.github.io/categories/Design-Pattern/"/>
    
    
      <category term="Note" scheme="http://talentprince.github.io/tags/Note/"/>
    
      <category term="Design Pattern" scheme="http://talentprince.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Chernobyl, 切尔诺贝利, 車諾比</title>
    <link href="http://talentprince.github.io/2019/07/09/Chernobyl/"/>
    <id>http://talentprince.github.io/2019/07/09/Chernobyl/</id>
    <published>2019-07-09T08:06:52.000Z</published>
    <updated>2020-06-22T09:44:59.476Z</updated>
    
    <content type="html"><![CDATA[<p>虽然八季的权游的草草收尾让HBO被骂了个惨, 但是后续推出的Mini剧<code>切尔诺贝利</code>却以9.6的高分一绝红尘, 让大家对于人类历史上最大的核灾难有了形象生动的认识. <code>谎言的代价</code>, 一开始的旁白便以此为切入, 展开了整部剧的画面.</p><p>趁着热度, 我并没有先看这部西方指导的剧集, 而是分别看了美国拍的纪录片<a href="https://movie.douban.com/subject/3057368/" target="_blank" rel="noopener">抢救車諾比</a>, 俄罗斯的奇幻片<a href="https://movie.douban.com/subject/26214079/" target="_blank" rel="noopener">切尔诺贝利 禁区</a>, 以及乌克兰的电视剧<a href="https://movie.douban.com/subject/25834316/" target="_blank" rel="noopener">飞蛾</a>, 这三部剧让我从三个不同角度, 或者说是阵营去感知那段历史, 充分满足了我的好奇心, 也填补了我的很多困惑, 以及帮助了我更好的去思考时代的变迁. (Warning!!!后面会有一些剧透)</p><a id="more"></a><p>也许有人疑惑为何会对切尔诺贝利感兴趣, 说来可能会比较牵强, 首先作为一个社会主义工人阶级的后代, 对苏联有着一段莫名其妙的亲切感, 而这场核灾难在某种意义上来说是苏联的掘墓人, 这话也不是我说的, 是苏联最后一个总书记戈尔巴乔夫后来讲的. 其次在我的童年所生活过的几个地方, 都是类似于普里皮亚季这样的因为有某个工厂或者机构而盛极一时的地方, 而后又因为各种原因突然衰败, 最终被废弃, 成为小朋友们探险的场所. 再次作为半个历史的爱好者, 感慨过汉唐之兴衰, 民国之兴衰, 有时也会仰望星空, 感知人类的渺小, 感叹谁主沉浮.</p><center> <img src="https://res.cloudinary.com/dtn0pkdmg/image/upload/c_scale,w_600/v1562660097/old_vhuod3.jpg" alt="old_photo"> </center><p>距离1986年4月26号凌晨已经过去33年, 当我试图去寻找这个当年的苏联模板城市的资料时, 绝大部分都只有图片的对比, 不过最终还是找到了一个名为<code>苏联最好城市普里皮亚季</code>的<a href="https://www.bilibili.com/video/av30022920" target="_blank" rel="noopener">简短的视频</a>, 透过这段视频, 依稀可以感受到这个人口五万的城市曾经的生机勃勃与辉煌.</p><center> <img src="https://res.cloudinary.com/dtn0pkdmg/image/upload/v1562660465/map_m9wltl.gif" alt="map"> </center><p>普里皮亚季, 是切尔诺贝利西北方因为核电站而修建的城市, 兴建于1970年, 距离当时苏维埃乌克兰首府基辅(Kiev)一百公里, 人口将近五万, 平均年龄只有26岁, 聚集了大量的苏联技术青年, 一号核反应堆于1977年启用, 爆炸的四号反应堆是83年启用的, 并且一共规划了6座核电站. 整个城市修建了一家医院、一个公园、一座火车站、三家诊所、三个文化中心、二十一所学校、三个室内游泳馆、十个体育馆、十个射击场、35个体育场、25家商场和店铺、27个小餐馆, 就连基辅这等大城市的富贵们也会驱车来普里皮亚季的商场买西方最新上市的Dior香水, 不过这些繁华的景象, 都没有在目前的影视剧, 纪录片中有过多的描述, 留给人们印象最深的还是灾难本身的恐惧, 以及现在普里皮亚季废墟与鬼城的形象.</p><p>为了了解俄罗斯对于切尔诺贝利的视角, 我首先看的是<a href="https://movie.douban.com/subject/26214079/" target="_blank" rel="noopener">切尔诺贝利 禁区</a>这部俄剧, 俄剧在国内非常冷门, 但是这部剧居然达到近乎9分, 并且好评如潮. 大致的剧情是一群俄罗斯青年被一个偷钱的怪人引诱到了切尔诺贝利的普里皮亚季, 后来他们无意中通过一个设备穿越到了爆炸发生之前, 第一季的最后他们改变了过去, 导致回来的时候苏联并没有解体而成为世界上最强大的国家. 还记得印象最深的是女一号无意中从废墟穿越回过去, 一片欣欣向荣的景象让我感觉到心潮澎湃, 好希望灾难从未发生. 再后来他们真的阻止了爆炸的发生, 苏联又回来了, 男主穿越回来的第一瞬间, 便看到普里皮亚季大街上熙熙攘攘带着红领巾的小朋友, 看到这里, 我竟然莫名其妙的有一些激动. 虽然第二季最后一切又回归现实, 站在我们面前的依旧是现在的俄罗斯联邦. 整部剧里除了穿越还有一些惊悚成分, 例如普里皮亚季的高辐射成为了被称作<code>禁区</code>的物质, 它具备一定的超能力, 可以制造幻想, 并且期望将来这里的人杀死. 我还很好奇的查了一下拍摄资料, 原来他们从未实景拍摄过, 因为辐射会危害健康, 不过透过演员的FB看到了一张他们在普里皮亚季大门的合照, 可能最新的情节去采景了? 非常期待今年10月份上映的大电影.</p><center> <img src="https://res.cloudinary.com/dtn0pkdmg/image/upload/c_scale,w_600/v1562660192/%E7%A6%81%E5%8C%BA_t8wr6a.jpg" alt="禁区"> </center><p>俄剧的制作虽然不如美剧华丽, 但俄国作为切尔诺贝利事件的主要参与者, 一些细节足矣窥伺出他们的态度. 比如在前往切尔诺贝利途中被警察恶意扣留, 必须得用金钱进行贿赂, 或许侧面反映了大家对于目前俄罗斯腐败的不满. 当大家阻止了爆炸的发生, 苏联重振熊威, 成为世界霸主, 连互联网都变成了俄联网, iPhone8都变成了俄Phone8, 足矣见得大家对苏联大国地位的怀念, 以及切尔诺贝利对苏联的巨大影响. 由于历史被改变, 86年的核爆炸转移到了美国, 美国又爆发了内战, 可以看出俄方对于美国的态度还是非常敌对的. 而后一行人又穿越回美国阻止了核爆, 一切又回到正轨, 也表明了俄罗斯人不愿意利用灾难转移来恢复大国地位… 或许这些都是我想多了, 不过他们脑洞之大令人佩服.</p><p>乌克兰, 作为苏联三巨头之一, 一直都是附庸的地位, 乌克兰脱离苏联后也一直都表现浓厚的反俄情绪, 但<a href="https://movie.douban.com/subject/25834316/" target="_blank" rel="noopener">飞蛾</a>改变了一些我对乌克兰人的认知, 这部剧以平民视角出发, 客观真实以及浪漫的记录了灾难给人们的影响. 剧情是以苏军上校的女儿艾丽娅与士兵巴沙的生死之恋为主线, 士兵巴沙作为上校的下属来给艾丽娅送信, 两人对上了眼. 可是没过多久核爆发生, 上校坚持亲自驾机查看爆炸情况, 飞机受到强大的电离辐射坠毁, 成为孤儿的艾丽娅精神崩溃, 士兵巴沙变成为她的唯一依托, 可惜巴沙作为清理者(Liquidator)在四号核电站楼顶受到了致命的辐射, 他不愿被送往莫斯科, 私自逃离营帐与艾丽娅在已经空城的普里皮亚季度过了人生最浪漫的一天. 巴沙最后死在了莫斯科第六医院, 而艾丽娅没有接受医院的劝说堕胎, 电视剧的最后是艾丽娅的女儿来到了普里皮亚季废墟参观旅游, 在已经锈迹斑斑的电话亭里找到了当时她父母为躲避清城人员时刻的字, “艾丽娅 &amp; 巴沙”. </p><center> <img src="https://res.cloudinary.com/dtn0pkdmg/image/upload/c_scale,h_480/v1562660274/%E9%A3%9E%E8%9B%BE_q8ogvx.jpg" alt="飞蛾"> </center><p>这部四级的电视剧以”飞蛾”为名, 寓意飞蛾扑火, 与第一集核爆当晚灯光下的成群飞蛾在不明真相的人群中死亡想呼应. 整部剧没有丝毫讽俄的成分, 涉及到几个核爆重点事件也都是结合剧情改编的合情合理. 比如上校执意驾驶飞机查看爆炸情况坠机牺牲, 而他刚刚从阿富汗战场回来, 已经接受到了上级命令可以休假回家看望女儿, 并且上级也极力劝阻. 可见这里对苏军的英勇还是非常认可, 凸显了在亲情面前, 国家更为重要. 类似的剧情还有艾丽娅的姐姐在去医院找对象的途中发现人手不够主动帮忙, 在已知有辐射的情况下没有退缩, 在受到二次辐射后被送往莫斯科, 最后不幸去世. 当然也有像艾丽娅姐姐的未婚夫得知有辐射便谎称有家中有事逃回基辅, 在被未婚妻的爷爷(苏军老兵)鄙视后, 又硬着头皮回到普里皮亚季, 他始终犹豫不决, 胆战心惊, 慌乱中还是克服障碍, 参与了撤离人员难产接生. 这些在现在看来都算是所谓的正能量, 可歌可泣的东西, 也反映了从国家到平民大家都是国难当头, 上下一心. 针对于普里皮亚季的描写, 大致也与我查到的资料相符, 这些都可以从艾丽娅与巴沙逃回空城看得到. 他们分别去了幼儿园, 姐姐家中, 以及衣服店与理发馆. 印象最深的就是姐姐家中的暖水瓶与我们小时候(90年代)家中的红色铁皮那款一模一样, 电视冰箱等家电一应俱全, 幼儿园里环境优雅设施齐全, 衣服店里琳琅满目, 理发馆里海报女郎发型时尚, 广场还有冷饮外卖摊, 饮料自助机等等. 然而这一切最终还是化为乌有, 只留下了锈迹斑斑的”艾丽娅 &amp; 巴沙”, 令人惋惜.</p><p>除去影视剧的表现, 可能纪录片更能真实详细的反应事情的经过, 事件发生后的第五年, 苏联解体, 目前唯一一部<a href="https://movie.douban.com/subject/3057368/" target="_blank" rel="noopener">称得上纪录片的还是美国拍摄的</a>, 片中收集了大量珍贵的影像资料, 采访视频, 值得一看. 片子最初是以欢快的普里皮亚季生活开始的, 茁壮成长的青少年, 干净整洁的城市规划, 街头推着婴儿车的年轻人. 片中采访了几乎所有利害相关的人, 比如当时苏联最高领导人戈尔巴乔夫, 俄方的摄像师(参与拍摄屋顶清理石墨), 挖掘隧道的煤炭工人, 直升机救援队军方负责人, 从普里皮亚季撤出的居民等等. 从高官到平民, 无一不表露出对灾难的遗憾以及对救援行动的肯定. </p><center> <img src="https://res.cloudinary.com/dtn0pkdmg/image/upload/c_scale,h_480/v1562660344/%E6%8A%A2%E6%95%91%E8%BD%A6%E8%AF%BA%E6%AF%94_z43euo.jpg" alt="抢救"> </center><p>印象比较深刻的是挖掘隧道的工人说他从不后悔, 因为总该有人要去做这件事, 不是他们也会是别人. 拍摄清理者的摄影师也以第一人称的视角描述了苏联军人如何蚂蚁搬家的将楼顶所有的石墨清理干净, 为石棺的修建打好基础, 强大的辐射在照片下方留下的印记永远被记录了下来. 戈尔巴乔夫称整个救援行动花了180亿卢布, 折合180亿美元, 我也去查了一下当时的数据, 81-85年整个苏联的赤字平均就180亿, 而86年到89年上升到了690亿, 随后石油大跌也对苏联的经济雪上加霜.</p><p><code>一个国家的消亡, 或许也是造就英雄被遗忘的重要原因</code>. 与日本福岛核事故的处理, 显然苏共中央的决策与行动力是非常值得肯定的. 4月26日凌晨核爆发生, 26日当天中央便派技术检测人员去现场测量数据, 26日晚确定必须撤离所有群众, 并连夜调集了一千多辆大巴准备进行疏散, 27日十一时开始疏散居民, 总共耗时三小时, 并且派遣军方直升机进行投放铅与硼砂来降低辐射, 将爆炸区周围的辐射从12000伦琴每小时降低到100伦琴. 28日开始疏散10km内的群众, 29日开始疏散30km内的群众, 5月2日划定隔离区并使用铁丝网围起来, 为了防止核燃料烧穿地板接触用于降温的废水而产生更大的爆炸, 在明确高辐射危险的同时, 三名来自三号反应堆的工作人员冒死进入打开消防泵, 抽干了废水 (他们竟然幸存了下来), 5月7号政府决定修建石棺以及人工降温层来防止剩余的依旧燃烧的核燃料可能造成的影响. 年轻的苏联士兵每人工作90秒, 轮班将屋顶残留的高辐射石墨清理出来, 为石棺修建扫清障碍. 5月12号开始动员了1000km外苏联最优秀的一批矿工来切尔诺贝利, 13号他们开始了工作, 仅仅一个月就完成了预计三个月的工作量. 当年12月石棺完工. 前后两年间动员了多大30万人进行清理工作. (说道动员, 想起了红警苏联的动员兵, 100块一个, 口号就是for the Union, for mother Russia, 后面一句有点反苏).</p><center> <img src="https://res.cloudinary.com/dtn0pkdmg/image/upload/c_scale,h_600/v1562662049/compare_xx7dzm.jpg" alt="compare"> </center><p>事故距今已过33年, 也许没有HBO的热播剧, 就不会有更多的人对切尔诺贝利有详尽的了解, 虽然西方价值观下的影片在一定程度上掩盖了民族英雄, 或者说共产主义下的人民英雄的形象, 但它依旧是第一个能震撼的将整个过程呈现在人们面前的影视剧. 在人们指责当局掩盖事实, 阻止人们民众知道真相的同时, 是否考虑过在那个消息不发达的年代, 在资本主义社会主力两大阵营激烈对抗当中, 维稳与防止敌国的渗透更为重要. 面对人类历史上最大的核灾难, 或许只有苏联这样国家才能在最短的时间内调动全国的人力物力, 将损失降到最低.</p><p>而最终历史还是胜利者书写, 牢不可摧的联盟, 红色的CCCP, 也只能停留在记忆当中. </p><center> <img src="https://res.cloudinary.com/dtn0pkdmg/image/upload/v1562660807/cccp_e2sjcd.jpg" alt="CCCP"> </center><p>忘记苏联没良心, 而恢复苏联也决然不再可能.</p>]]></content>
    
    <summary type="html">
    
      Chernobyl, 切尔诺贝利, 車諾比
    
    </summary>
    
      <category term="nonsense" scheme="http://talentprince.github.io/categories/nonsense/"/>
    
    
      <category term="nonsense" scheme="http://talentprince.github.io/tags/nonsense/"/>
    
  </entry>
  
  <entry>
    <title>探究高级的Kotlin Coroutines知识</title>
    <link href="http://talentprince.github.io/2019/02/12/Deep-explore-kotlin-coroutines/"/>
    <id>http://talentprince.github.io/2019/02/12/Deep-explore-kotlin-coroutines/</id>
    <published>2019-02-12T01:14:52.000Z</published>
    <updated>2020-06-22T09:44:59.477Z</updated>
    
    <content type="html"><![CDATA[<p>要说程序如何从简单走向复杂, 线程的引入必然功不可没, 当我们期望利用线程来提升程序效能的过程中, 处理线程的方式也发生了从原始时代向科技时代发生了一步一步的进化, 正如我们的Elisha大神所著文章<a href="https://medium.com/@elye.project/the-evolution-of-android-network-access-1e199fc6e9a2" target="_blank" rel="noopener">The Evolution of Android Network Access</a>中所讲到的, Future可能会是Kotlin Coroutines的时代.</p><a id="more"></a><h3 id="什么是Coroutines"><a href="#什么是Coroutines" class="headerlink" title="什么是Coroutines"></a>什么是Coroutines</h3><p>Coroutines是Kotlin 1.1推出的实验性的一个扩展, 它被定义为一个轻量级的高效的线程框架, 并且在1.3版本正式发布, 去掉Experiment标签.</p><h3 id="如何启动一个Coroutines"><a href="#如何启动一个Coroutines" class="headerlink" title="如何启动一个Coroutines"></a>如何启动一个Coroutines</h3><p>最基础的创建一个Coroutines的方法就是使用<code>launch</code>或者<code>async</code>, 二者的区别是前者返回的是一个<code>Job</code>, 不带结果 而后者可以将结果以<code>Deferred&lt;T&gt;</code>格式返回.</p><p>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val job = launch &#123;</span><br><span class="line">    delay(100)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而通常在Coroutines内执行的函数都会有一个<code>suspend</code>声明, 而有<code>suspend</code>声明的函数也只能在Coroutines Scope中调用.</p><p><code>suspend</code>的意思是这个函数可以被suspend(挂起), 让Coroutines来调度它, 这也是为何Kotlin的<code>delay</code>函数可以不阻塞的进行延迟, 因为它就是一个suspend函数.</p><h3 id="Coroutines与线程的关系"><a href="#Coroutines与线程的关系" class="headerlink" title="Coroutines与线程的关系"></a>Coroutines与线程的关系</h3><p>Coroutines可以简单理解为一个有队列的任务链, 每一个Coroutines都有自己的Context, 而Context又可以决定其运行的线程.</p><p>所以可以看到, 并不是起一个Coroutines就是起了一个线程, 而只是启动了一个在某个Scope下运行的协程(Coroutines)罢了. 这里的Scope (CoroutineScope) 内部包含了一个 Context (CoroutineContext).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface CoroutineScope &#123;</span><br><span class="line">    public val coroutineContext: CoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只是通过<code>launch</code>来启动一个协程, 那它将会运行在Parent Scope所定义的线程中, 但是如果使用<code>GlobalScope.launch</code>来启动一个协程, 它将会使用线程池中的线程来创建一个协程, 线程池的大小跟CPU的核数相关.</p><p>当然<code>launch</code>也支持自己传入一个CoroutinesContext来控制它运行的线程, 它叫做<code>CoroutineDispatcher</code>, 是Context的子类.</p><p>上面讲了默认的<code>launch</code>会启在父Scope(Context)的线程中, 而<code>launch(Dispatchers.Default)</code>则等于<code>GlobalScope.launch</code>, 还可以通过<code>launch(newSingleThreadContext(&quot;MyOwnThread&quot;))</code>来启动自己的线程, 另外有一个不推荐在general code中出现的<code>launch(Dispatchers.Unconfined)</code>, 它将会运行在第一个进入Suspend状态的线程中.</p><p>可以举一个简单的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val job = launch &#123;</span><br><span class="line">    log(&quot;hehe&quot;)</span><br><span class="line">    delay(1000)</span><br><span class="line">    log(&quot;haha&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个协程是可以完全在main函数里执行完的, 即输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hehe</span><br><span class="line">haha</span><br></pre></td></tr></table></figure><p>因为launch会跑在main的scope中. 如果替换成:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val job = GlobalScope.launch &#123;</span><br><span class="line">    log(&quot;hehe&quot;)</span><br><span class="line">    delay(1000)</span><br><span class="line">    log(&quot;haha&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则只会输出<code>hehe</code>, 因为主线程已经结束.</p><p>这里我们可以通过<code>job.join()</code>来等待子协程执行结束, 这一点跟大家熟知的线程的join是一样.</p><h3 id="如何切换Context"><a href="#如何切换Context" class="headerlink" title="如何切换Context"></a>如何切换Context</h3><p>如果把Context对应到我们平时认为的线程, 那么这个问题可以类比成 <code>如何切换线程</code>.</p><p>答案是使用<code>withContext</code>, 举一个简单的栗子.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">launch(UI) &#123;</span><br><span class="line">    updateUI()</span><br><span class="line">    val result = withContext(IO) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    setView(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它类似于<code>async(IO){ }.await()</code>.</p><h3 id="如何共享资源"><a href="#如何共享资源" class="headerlink" title="如何共享资源"></a>如何共享资源</h3><p>线程与线程之间会涉及到同步与资源竞争的关系, 协程亦是如此.</p><p>通常情况下在线程中我们解决问题的方式是<code>加锁</code>, 而不正确的使用可能会导致性能下降甚至死锁（dead lock. 或者在高级语言中使用已经实现线程安全的数据类型, 来进行夸线程操作。</p><p>而我们的Coroutines自然也考虑到了这一点, 它认为我们<code>不应该以共享资源来进行通信, 而是以通信来进行资源共享</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Do not communicate by sharing memory; instead, share memory by communicating.</span><br></pre></td></tr></table></figure><p>所以它提出了一个叫做<code>Channel</code>的东西来在不同的Coroutines之间进行通信.</p><p>譬如我们期望将一堆数据交给两个并行的协程进行处理, 那么我们可以把数据放进Channel, 其他的协程从这个Channel进行数据读取.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">launch &#123;</span><br><span class="line">    for (o in data) &#123; channel.send(o) &#125;</span><br><span class="line">    channel.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">launch(One) &#123;</span><br><span class="line">    for (o in channel) &#123;</span><br><span class="line">        xxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">launch(Two) &#123;</span><br><span class="line">    for (o in channel) &#123;</span><br><span class="line">        xxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一定要记得关闭channel, 否则从channel读取数据的协程都将会无限挂起等待数据传过来.</p><p>由于Channel本身实现了<code>iterator</code>, 所以直接通过<code>in</code>就可以挨个取出内部的数据.</p><h3 id="ReceiveChannel与SendChannel"><a href="#ReceiveChannel与SendChannel" class="headerlink" title="ReceiveChannel与SendChannel"></a>ReceiveChannel与SendChannel</h3><p>上一个环节提到的协程之间是通过Channel来进行通信, 而Channel本身却是实现了接收管道与发送管道两个接口.</p><p>我们可以通过<code>producer</code>函数来进行生成数据, 提供给别的协程, 因为它的返回值是一个ReceiveChannel.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val channel = produce&lt;XXX&gt;() &#123;</span><br><span class="line">    for (o in data) send(o)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且produce自己会做channel close的处理, 省去我们发送完毕还要掉close的烦恼.</p><p>如果我们多个协程需要发送请求并集中处理, 或者可以叫数据整合, 那么我们可能需要用到<code>actor</code>这个函数, 它的返回值是一个SendChannel.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">val channel = actor&lt;XXX&gt;() &#123;</span><br><span class="line">                consumeEach &#123;</span><br><span class="line">                   xxx     </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">launch(One) &#123;</span><br><span class="line">    channel.send(xxx)</span><br><span class="line">&#125;</span><br><span class="line">launch(Two) &#123;</span><br><span class="line">    channel.send(xxx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>actor</code>返回的SendChannel有点像是一个邮箱, 它会不断的接收数据, 所以必须手动关闭才会停止.</p><h3 id="多个Channel之间数据如何进行选择"><a href="#多个Channel之间数据如何进行选择" class="headerlink" title="多个Channel之间数据如何进行选择"></a>多个Channel之间数据如何进行选择</h3><p>Coroutines推出一个仍在Experiment阶段的关键字<code>select</code>来在多个suspend function中进行选择第一个到达available的, 其实有点像RxJava的concat+first.</p><p>比如我有两个接收Channel, 但是每一个Channel接收到数据的频率不得而知, 我想分别从中得到数据, 这里就需要使用select.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select&lt;Unit&gt; &#123;</span><br><span class="line">    channel1.onReceive &#123;&#125;</span><br><span class="line">    channel2.onReceive &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在配合外围的循环, 就可以做到不断的去接收两个Channel的数据.</p><p>再比如有两个发送Channel都可以处理我的需求, 我也不知道这个时候谁是空闲的, 那也可以通过select来解决.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select&lt;Unit&gt; &#123;</span><br><span class="line">    channel1.onSend(xxx) &#123;&#125;</span><br><span class="line">    channel2.onSend(xxx) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候两个Channel是嵌套使用的.</p><p>比如一个咖啡店, 他们会不断的收到Oder, 只有两个打咖啡的服务员, 咖啡机也只有两个口,  如果我们对这个咖啡店进行抽象. 将Oder存在于一个Channel里, 服务员接收Order并不断的把咖啡递出来, 这也是一个Channel, 咖啡机会不断接收到服务员需要打咖啡的操作, 也这是一个Channel.</p><p>而在这个过程中, 两个服务员会有一个选择, 咖啡机的两个出口也会有一个选择的过程.</p><p>如果抽象成我们的Coroutines代码, 或许会是这个样子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">val orderChannel = producer &#123;</span><br><span class="line">    for (o in orders) send(o)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val waiter1 = producer &#123;</span><br><span class="line">    for (o in orderChannel) &#123; </span><br><span class="line">        pullCoffee(o)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// waiter2 is the same as 1</span><br><span class="line"></span><br><span class="line">val coffeePort1 = actor &#123;</span><br><span class="line">    consumeEach &#123; </span><br><span class="line">        //pass coffee through channel inside order</span><br><span class="line">        it.channel.send(Coffee)</span><br><span class="line">        it.channel.close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// coffeePort2 is the same as 2</span><br><span class="line"></span><br><span class="line">pullCoffee &#123;</span><br><span class="line">    select&lt;Coffee&gt; &#123;</span><br><span class="line">        coffeePort1.onSend(Request(channel)) &#123;</span><br><span class="line">            //get coffee from coffeePort</span><br><span class="line">            channel.recevie()</span><br><span class="line">        &#125;</span><br><span class="line">        coffeePort2.onSend ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while(someCondition) &#123;</span><br><span class="line">    select&lt;Coffee&gt; &#123;</span><br><span class="line">        waiter1.onReceiveOrNull &#123;</span><br><span class="line">            //上菜了</span><br><span class="line">        &#125;</span><br><span class="line">        waiter2.onReceiveOrNull &#123;</span><br><span class="line">            //上菜了</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>协程作为未来non blocking编程的方向, 需要大家花时间去理解, 花时间去尝试, 在此特别推荐这个咖啡小程序帮助大家学习.</p><p><a href="https://medium.com/@jagsaund/kotlin-coroutines-channels-csp-android-db441400965f" target="_blank" rel="noopener">https://medium.com/@jagsaund/kotlin-coroutines-channels-csp-android-db441400965f</a></p><p>以及官方的Overview</p><p><a href="https://kotlinlang.org/docs/reference/coroutines-overview.html" target="_blank" rel="noopener">https://kotlinlang.org/docs/reference/coroutines-overview.html</a></p><p>还有个CheatSheet可以参考</p><p><a href="https://blog.kotlin-academy.com/kotlin-coroutines-cheat-sheet-8cf1e284dc35" target="_blank" rel="noopener">https://blog.kotlin-academy.com/kotlin-coroutines-cheat-sheet-8cf1e284dc35</a></p>]]></content>
    
    <summary type="html">
    
      深入解析Kotlin Coroutines 协程
    
    </summary>
    
      <category term="Kotlin" scheme="http://talentprince.github.io/categories/Kotlin/"/>
    
    
      <category term="Android" scheme="http://talentprince.github.io/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://talentprince.github.io/tags/Kotlin/"/>
    
      <category term="Kotlin Coroutines" scheme="http://talentprince.github.io/tags/Kotlin-Coroutines/"/>
    
  </entry>
  
  <entry>
    <title>The year that was 2018</title>
    <link href="http://talentprince.github.io/2018/12/28/The-year-that-was-2018/"/>
    <id>http://talentprince.github.io/2018/12/28/The-year-that-was-2018/</id>
    <published>2018-12-28T02:13:42.000Z</published>
    <updated>2020-06-22T09:44:59.478Z</updated>
    
    <content type="html"><![CDATA[<p>昨天天空飘起了大雪, 今天便又艳阳高照, 空气中透着阵阵寒意, 似乎意味着冬天真的来了, 而且是大摇大摆, 万众瞩目.</p><p>四季分明, 或许不是文明泵发的必要条件, 但一年四季, 朝夕交替, 却的确是我们生活, 成长, 喜怒哀乐的必要条件.</p><p>2018年已余额不足, 恍惚间已迈入而立, 然常常并不曾觉察, 思绪也会偶然停留在学校, 停留在实验室, 停留在北京, 停留在年少轻狂的时代. 或许, 这也就是所说的老了吗?</p><p>在这即将过去的一年中, 发生了太多的改变, 虽然已经过去, 沉积在大脑中的余晖, 依旧令我久久不能平息. 我心痛过, 庆幸过, 欢喜过, 也期待着未来美好的事情会发生.</p> <a id="more"></a><ul><li>心痛:</li></ul><p>自宝宝出生后, 孩儿的娘便病魔缠身, 接二连三, 这对生活质量本已下降的整个家庭来说, 仿佛是异常噩梦, 似乎一切都是设定好的那样, 每次都是离希望的出口就差一步, 便又掉了进去, 肉体上的痛苦夹杂着无形的社会压力, 至今回想起来依旧胆战心惊.</p><p>命运的坎坷似乎也有延续与扩散之意, 老婆刚刚康复上班, 五岁的皮皮却在小区被二把刀熟人女司机杀害, 可惜之余, 大家都讲皮皮完成了它的使命, 现在有小小呆来取代它的位置了, 为了防止这段没好的回忆被遗忘, 我将所有与它有关的记忆记录下来, 来缅怀在特殊时期贡献过欢乐的小动物.</p><ul><li>庆幸:</li></ul><p>曾经有讲过, 这些年来没有什么太值得雀跃的事情, 唯独庆幸的是能把老婆从某邪恶组织解脱出来, 而又不伤毫发. 然而似乎这一年需要感谢上苍的事情不少, 小小呆是一个很乖很可爱很健康的宝宝; 老婆的病也终于康复, 生活中诸多与之相关不悦之事都渐渐烟消云散.</p><ul><li>欢喜:</li></ul><p>说道欢喜, 必定是在不断成长的小小呆, 看着从只会呆呆的躺着到现在到处乱跑, 爬上爬下, 模仿大人, 捉迷藏, 似乎一切都发生的太快了, 回头想想去年他还在妈妈的肚子里呢, 不禁感叹大自然与妈妈的伟大, 生命的美好, 以及未来的无限可期.</p><ul><li>期待:</li></ul><p>期待总会有太多, 然成者去半, 顺利达成者去之又半. 对于现在略显枯燥, 疲敝的生活, 应当宽心面对, 已经苦尽, 何愁甘不来呢. 计划一直都在队列里排着, 所有不顺的节点必将随着小小呆的长大而一一打开, 欢乐不会缺席, 只是有时不被觉察, 又或是感叹太过短暂罢了.</p><p>愿一切趋于美好, 顺利过冬.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天天空飘起了大雪, 今天便又艳阳高照, 空气中透着阵阵寒意, 似乎意味着冬天真的来了, 而且是大摇大摆, 万众瞩目.&lt;/p&gt;
&lt;p&gt;四季分明, 或许不是文明泵发的必要条件, 但一年四季, 朝夕交替, 却的确是我们生活, 成长, 喜怒哀乐的必要条件.&lt;/p&gt;
&lt;p&gt;2018年已余额不足, 恍惚间已迈入而立, 然常常并不曾觉察, 思绪也会偶然停留在学校, 停留在实验室, 停留在北京, 停留在年少轻狂的时代. 或许, 这也就是所说的老了吗?&lt;/p&gt;
&lt;p&gt;在这即将过去的一年中, 发生了太多的改变, 虽然已经过去, 沉积在大脑中的余晖, 依旧令我久久不能平息. 我心痛过, 庆幸过, 欢喜过, 也期待着未来美好的事情会发生.&lt;/p&gt;
    
    </summary>
    
      <category term="nonsense" scheme="http://talentprince.github.io/categories/nonsense/"/>
    
    
  </entry>
  
  <entry>
    <title>Android程序员的Flutter学习笔记</title>
    <link href="http://talentprince.github.io/2018/11/08/Flutter-self-learning-notes-as-an-android-developer/"/>
    <id>http://talentprince.github.io/2018/11/08/Flutter-self-learning-notes-as-an-android-developer/</id>
    <published>2018-11-08T03:17:10.000Z</published>
    <updated>2020-06-22T09:44:59.477Z</updated>
    
    <content type="html"><![CDATA[<p>作为忠实与较资深的Android汪, 最近抽出了一些时间研究了一下Google的亲儿子Flutter, 尚属皮毛, 只能算是个简单的记录吧.</p><p>Google自2017年第一次提出Flutter, 到2018年Beta, 再加之RN的各种风波与问题, 使得Flutter的热度不断上升, 国内不少公司都公布Flutter在其产品中的应用, 如美团, 闲鱼等.</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Flutter作为跨平台框架, 常常被人拿出来与React Native, 以及Xamarin进行对比, 除了大家都是跨平台框架之外且能达到近乎Native的体验之外, Flutter与这两者的原理大不相同.</p><p>让我们来看看这三者的结构图吧.</p><p><img src="/images/react_native.png" alt="React Native"></p><p><img src="/images/xamarin.png" alt="Xamarin"></p><p><img src="/images/flutter.png" alt="Flutter"></p><p>可能有一些复杂, 咱大致解释一下.</p><p>React Native跟Xamarin都是基于mapping native代码来实现所谓的Native体验的框架, 只是RN基于JS引擎 + Bridge与native打交道, 并且在运行时进行绑定, 而Xamarin是基于微软的基于Linux的C#虚拟机mono + JNI与native进行通信.</p><p>这里Android与iOS还是有差别的, 如RN在iOS上JS引擎不支持JIT, 会一定程度影响效率, Xamarin在iOS上可以直接编译成iOS平台可以执行的程序, 所以在实际运行起来的性能是一样的, 唯一的差别就是微软得更快的支持API同步.</p><p>对于Flutter来说, 由于他的渲染引擎使用了Skia直绘, 加上基于C++的Dart引擎, 所以在不同平台上没有差别, 加之其实现了Android Material Design与iOS Cupertino两套UI组件, 所以即便是自绘组件, 看起来还是跟原生的一个样子.</p><p>通过对三种跨平台引擎的大致了解, 我们可以看出来, 他们都达到了一定程度的Native体验, 然则各自都有一定的性能损耗, 比如RN的JS引擎加载JS, 以及Bridge通信的损耗, Xamarin Mono虚拟机与Java通信的损耗, 以及Flutter Skia渲染与Native Android渲染的差异等.</p><h2 id="Flutter笔记"><a href="#Flutter笔记" class="headerlink" title="Flutter笔记"></a>Flutter笔记</h2><h3 id="如何启动一个app"><a href="#如何启动一个app" class="headerlink" title="如何启动一个app"></a>如何启动一个app</h3><p>Android需要在Manfest里面指定带有MAIN action与LAUNCHER category的Activity声明, 而Flutter只需要一行.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void main() =&gt; runApp(MyApp());</span><br></pre></td></tr></table></figure><p>其中MyApp就是一个普通的Widgets(View).</p><h3 id="View-vs-Widgets"><a href="#View-vs-Widgets" class="headerlink" title="View vs Widgets"></a>View vs Widgets</h3><p>Flutter没有View, 与之对应的是Widget, 并且分为StatelessWidgets与StatefulWidgets, 前者是个静态View, 后者是动态通过Data来更新的View.</p><ul><li>Stateless</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">  &apos;I like Flutter!&apos;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>Stateful</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class StatefulText extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  State&lt;StatefulWidget&gt; createState() =&gt; _TextState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _TextState extends State&lt;StatefulText&gt; &#123;</span><br><span class="line">  // Default placeholder text</span><br><span class="line">  String textToShow = &quot;I Like Flutter&quot;;</span><br><span class="line"></span><br><span class="line">  void _updateText() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      // update the text</span><br><span class="line">      textToShow = &quot;Flutter is Awesome!&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">      ...invoke _updateText</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上是因为StatefulWidgets通过调用<code>State</code>的<code>setState</code>方法来触发整个Widgets树的重绘, 并且在重绘之前会调用传进去的<code>(){ ... }</code>block.</p><h3 id="怎么写Layout-XML到哪里去了"><a href="#怎么写Layout-XML到哪里去了" class="headerlink" title="怎么写Layout, XML到哪里去了."></a>怎么写Layout, XML到哪里去了.</h3><p>实际上Flutter没有xml了, 并且是通过Widgets的嵌套来实现一个布局的.</p><p>如:</p><ul><li><code>Center</code>是一个可以把子View放置在中央的容器.</li><li><code>Row</code>对应的就是LinearLayout + Horizontal, <code>Column</code>对应的就是LinearLayout + Vertical, 他们都具备一个属性叫做<code>crossAxisAlignment</code>, 有点类似<code>gravity</code>, 来控制子View相对于父View的位置.</li><li><code>Expanded</code>支持一个类似weight的属性, 叫<code>flex</code>. </li><li><code>Container</code>是一个具有<code>decoration</code>属性的容器, 可以用来控制背景色, border, margin等等.</li><li><code>Stack</code>有点像是一个特殊的RelatetiveLayout或者ConstraintLayout, <code>children</code>属性指定了它的子View, 第一个是Base View, <code>alignment</code>属性指定了后面的子View相对于BaseView的位置, 如<code>alignment: const Alignment(0.6, 0.6)</code>指定了位于BaseView右下角的位置.</li><li><code>ListTile</code>是一个特殊的ListItem, 有三个属性, 分别是左边的Icon (leading), 文字 (title), 以及右边的Icon (trailing).</li><li>还有诸如<code>ListView</code>, <code>GridView</code>, <code>Card</code>等等比较熟悉的Widgets.</li></ul><p>另外有一个类似于我们Activity的Widgets:</p><ul><li>叫做<code>MaterialApp</code>, 可以指定<code>theme</code>, <code>title</code>, 以及子View <code>home</code>, 还有更重要的页面跳转<code>routes</code>.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">      title: &apos;Welcome to Flutter&apos;,</span><br><span class="line">      home: ...,</span><br><span class="line">      routes: &lt;String, WidgetBuilder&gt; ...,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primaryColor: Colors.white</span><br><span class="line">      ),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>还有一个类似于Fragment的:</p><ul><li>叫做<code>Scaffold</code>, 中文意思是<code>脚手架</code>, 它包含一个appBar (ActionBar)与一个body, appBar可以指定title与actions (类似于action button的点击事件).</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(widget.title),</span><br><span class="line">        actions: &lt;Widget&gt;[...],</span><br><span class="line">      ),</span><br><span class="line">      body: ...,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h3 id="如何从父View中Remove一个元素"><a href="#如何从父View中Remove一个元素" class="headerlink" title="如何从父View中Remove一个元素"></a>如何从父View中Remove一个元素</h3><p>答案是没有… 因为在Flutter看来, Widgets的树结构是不可以被更改的, 但是如果想更改, 则是通过StatefulWidgets的方法, 通过setState来更改Data, 触发Widgets重绘, 从而替换掉之前的Widgets.</p><h3 id="喜欢画Canvas的同学怎么办"><a href="#喜欢画Canvas的同学怎么办" class="headerlink" title="喜欢画Canvas的同学怎么办?"></a>喜欢画Canvas的同学怎么办?</h3><p>Flutter同样支持, <code>CustomPaint</code>作为一个 Widgets就支持传入一个实现<code>CustomPainter</code>抽象类的参数, 而<code>CustomPainter</code>的抽象方法也类似于Android View的<code>onDraw</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void paint(Canvas canvas, Size size)</span><br><span class="line"></span><br><span class="line">bool shouldRepaint(CustomPainter oldDelegate)</span><br></pre></td></tr></table></figure><h3 id="如何自定义View"><a href="#如何自定义View" class="headerlink" title="如何自定义View"></a>如何自定义View</h3><p>不用继承, 而使用类似Android ViewGroup的办法, 通过组合(composing)与封装的方法来实现, 通过小Widgets组合成需要的新Widgets.</p><h3 id="页面跳转怎么办-四大组件之一的Intent跑哪里去了"><a href="#页面跳转怎么办-四大组件之一的Intent跑哪里去了" class="headerlink" title="页面跳转怎么办, 四大组件之一的Intent跑哪里去了"></a>页面跳转怎么办, 四大组件之一的Intent跑哪里去了</h3><p>貌似在讲类似于Activity的<code>MaterialApp</code>的时候剧透了… </p><p>就是使用<code>Navigator</code>与<code>Routes</code>来实现界面跳转, 实际上是整个Widgets的替换.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">routes: &lt;String, WidgetBuilder&gt; &#123;</span><br><span class="line">      &apos;/a&apos;: (BuildContext context) =&gt; MyPage(title: &apos;page A&apos;),</span><br><span class="line">      &apos;/b&apos;: (BuildContext context) =&gt; MyPage(title: &apos;page B&apos;),</span><br><span class="line">      &apos;/c&apos;: (BuildContext context) =&gt; MyPage(title: &apos;page C&apos;),</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">Navigator.of(context).pushNamed(&apos;/b&apos;);</span><br></pre></td></tr></table></figure><h3 id="如何处理外部的Intent"><a href="#如何处理外部的Intent" class="headerlink" title="如何处理外部的Intent"></a>如何处理外部的Intent</h3><p>实际上还是需要在Flutter App的Android壳子中注册这个filter, 然后在FlutterActivity中拿到存下来, </p><p>FlutterView初始化后再通过Bridge, 官方叫<code>MethodChannel</code>从Java里获取,进行下一步逻辑.</p><p>可以看个简单的例子.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">new MethodChannel(getFlutterView(), &quot;app.channel.shared.data&quot;).setMethodCallHandler(</span><br><span class="line">      new MethodCallHandler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onMethodCall(MethodCall call, MethodChannel.Result result) &#123;</span><br><span class="line">          if (call.method.contentEquals(&quot;getSharedText&quot;)) &#123;</span><br><span class="line">            result.success(sharedText);</span><br><span class="line">            sharedText = null;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">getSharedText() async &#123;</span><br><span class="line">    var sharedData = await platform.invokeMethod(&quot;getSharedText&quot;);</span><br><span class="line">    if (sharedData != null) &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        dataShared = sharedData;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="常用的startActivityForResult怎么办"><a href="#常用的startActivityForResult怎么办" class="headerlink" title="常用的startActivityForResult怎么办."></a>常用的startActivityForResult怎么办.</h3><p>这个Flutter有完全对应的办法, 而且用起来很方便, 结合之前说的页面跳转:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map xxx = await Navigator.of(context).pushNamed(&apos;/xxx&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Navigator.of(context).pop(&#123;xxx&#125;);</span><br></pre></td></tr></table></figure><h3 id="异步怎么办-runOnUiThread-哪里去了"><a href="#异步怎么办-runOnUiThread-哪里去了" class="headerlink" title="异步怎么办, runOnUiThread()哪里去了"></a>异步怎么办, runOnUiThread()哪里去了</h3><p>Flutter有点像JS, 是一个单线程模式, 所以只是通过模拟来构建简单的异步, 关键字就是类似于kotlin coroutines一样, 通过<code>await</code>+<code>async</code>来处理.</p><p>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loadData() async &#123;</span><br><span class="line">    response = await http.get(xxx);</span><br><span class="line">    setState(() &#123;xxx&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是由于它的单线程, 所以无法做很长的阻塞操作, 像http请求的延迟正常情况可能都是毫秒级的, 但是数据的处理等, 可能就得秒级了.</p><p>这也是RN在线程方面的做android程序的一个痛点, Flutter采用了比较容易想到的曲线救国的办法, 提供了一个叫<code>Isolate</code>的对象, 它实际是一个基于socket的数据通道, 相当于把数据放在一个独立的进程进行处理, 然后再通过socket发送回程序进程, 还记得进程间通信办法之一的<code>管道</code>吗…</p><p>具体API可以参考文档<a href="https://flutter.io/docs/get-started/flutter-for/android-devs" target="_blank" rel="noopener">1…</a>,<a href="https://docs.flutter.io/flutter/dart-isolate/Isolate-class.html" target="_blank" rel="noopener">2…</a>.</p><h3 id="Flutter-替代OkHttp的网络库"><a href="#Flutter-替代OkHttp的网络库" class="headerlink" title="Flutter 替代OkHttp的网络库"></a>Flutter 替代OkHttp的网络库</h3><p>自带了http库, 直接<code>http.get(url)</code>, 在线程部分的代码实例里也有涉及.</p><p>通过类似gradle的文件<code>pubspec.yaml</code>引入.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  ...</span><br><span class="line">  http: ^0.12</span><br></pre></td></tr></table></figure><p><code>^</code>表示不升大版本, 并取最新版本, 比gradle的+要范围更小.</p><h3 id="常见的LCE-Loading-Content-Error-里面的Loading怎么show"><a href="#常见的LCE-Loading-Content-Error-里面的Loading怎么show" class="headerlink" title="常见的LCE(Loading Content Error)里面的Loading怎么show"></a>常见的LCE(Loading Content Error)里面的Loading怎么show</h3><p>Flutter有一个widget叫做<code>ProgressIndicator</code>, 比如我们期望有一个转圈圈的Loading界面在数据加载出来之前.</p><p>我们就可以通过StatefulWidgets, 根据数据, 或者List Widgets的个数 (如果是显示一个List的话)来判断是否显示Loading, 使用子类<code>CircularProgressIndicator</code>, 来替换页面的Widgets.</p><p>当然也是通过setState(() {…})来触发界面刷新的, 可以在initState()内触发加载数据的异步操作.</p><h3 id="不同分辨率的图片资源怎么放"><a href="#不同分辨率的图片资源怎么放" class="headerlink" title="不同分辨率的图片资源怎么放"></a>不同分辨率的图片资源怎么放</h3><p>这个有点像iOS了, 即有1x,2x,3x:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">images/my_icon.png       // Base: 1.0x image</span><br><span class="line">images/2.0x/my_icon.png  // 2.0x image</span><br><span class="line">images/3.0x/my_icon.png  // 3.0x image</span><br></pre></td></tr></table></figure><p>不一样的一点还需要添加到类似gradle的文件<code>pubspec.yaml</code>里.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assets:</span><br><span class="line"> - images/my_icon.jpeg</span><br></pre></td></tr></table></figure><h3 id="字符串怎么存储"><a href="#字符串怎么存储" class="headerlink" title="字符串怎么存储"></a>字符串怎么存储</h3><p>Flutter没有像Android的<code>string.xml</code>的东西, 目前来说最好的就就是存成静态字符串.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Strings &#123;</span><br><span class="line">  static String welcomeMessage = &quot;Welcome To Flutter&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Text(Strings.welcomeMessage)</span><br></pre></td></tr></table></figure><h3 id="Gradle变成什么了"><a href="#Gradle变成什么了" class="headerlink" title="Gradle变成什么了"></a>Gradle变成什么了</h3><p>前面说网络库, 图片资源的时候提到过, 提供了一个叫<code>pubspec.yaml</code>的文件, 具体支持的规则可以查看<a href="https://www.dartlang.org/tools/pub/pubspec" target="_blank" rel="noopener">这个文档</a>.</p><h3 id="Fragment与Activity呢"><a href="#Fragment与Activity呢" class="headerlink" title="Fragment与Activity呢?"></a>Fragment与Activity呢?</h3><p>之前做过类比, 如<code>MaterialApp</code>有点类似于Activity, 而<code>Scaffold</code>都点类似Fragment, 实际上他们两个都是Flutter的Widgets, 也就是说其实只有View的概念了.</p><h3 id="还有生命周期吗"><a href="#还有生命周期吗" class="headerlink" title="还有生命周期吗?"></a>还有生命周期吗?</h3><p>Flutter有一个叫做<code>WidgetsBinding</code>的可以提供类似生命周期的回调.</p><p>四种状态<code>inactive</code> (iOS专用), <code>paused</code>(相当于onPause, 退后台), <code>resumed</code>(相当于onPostResume, 到前台), <code>suspending</code>(android专用, 相当于onStop).</p><p>一般在StatefulWidgets的State中注册与反注册.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line"> void initState() &#123;</span><br><span class="line">   super.initState();</span><br><span class="line">   WidgetsBinding.instance.addObserver(this);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> void dispose() &#123;</span><br><span class="line">   WidgetsBinding.instance.removeObserver(this);</span><br><span class="line">   super.dispose();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="ScrollView-vs-ListView"><a href="#ScrollView-vs-ListView" class="headerlink" title="ScrollView vs ListView"></a>ScrollView vs ListView</h3><p>Flutter没有ScrollView, 合并到了ListView, 通过ListView.builder创建的ListView提供了View复用的逻辑.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ListView.builder(</span><br><span class="line">          itemCount: widgets.length,</span><br><span class="line">          itemBuilder: (BuildContext context, int position) &#123;</span><br><span class="line">            return Text(xxx);</span><br><span class="line">          &#125;))</span><br></pre></td></tr></table></figure><p>其中itemBuilder有点像Android ListView的getView, 官方文档说它会自动回收Element给你, 但是事实上每次你都需要根据position生成新的Widgets, 所以呢应该是Flutter在内部回收了之前的Widgets并在你重新创建的时候又用上了.</p><p>BTW, 通过ListView构造来显示就不具备这种特性, 所以大量数据需要用Builder.</p><h3 id="Flutter横竖屏怎么玩"><a href="#Flutter横竖屏怎么玩" class="headerlink" title="Flutter横竖屏怎么玩."></a>Flutter横竖屏怎么玩.</h3><p>因为它实际上还是借助了Android程序的壳子, 所以如果AndroidManifect定义了<code>android:configChanges=&quot;orientation|screenSize&quot;</code>, 则Flutter会自己hanlde.</p><h3 id="怎么处理Gesture"><a href="#怎么处理Gesture" class="headerlink" title="怎么处理Gesture"></a>怎么处理Gesture</h3><p>Flutter提供了<code>GestureDetector</code>, 它相当于一个Container, 将我们期望接收手势的Widgets放进去, 再实现事件回调就行了.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GestureDetector(</span><br><span class="line">        child: FlutterLogo(</span><br><span class="line">          size: 200.0,</span><br><span class="line">        ),</span><br><span class="line">        onTap: () &#123;</span><br><span class="line">          print(&quot;tap&quot;);</span><br><span class="line">        &#125;,</span><br><span class="line">      )</span><br></pre></td></tr></table></figure><p>它同样支持其他的手势, 如<code>onDoubleTap</code>等等等.</p><h3 id="字体怎么弄"><a href="#字体怎么弄" class="headerlink" title="字体怎么弄"></a>字体怎么弄</h3><p>首先需要在<code>pubspec.yaml</code>里面配置需要的字体库:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fonts:</span><br><span class="line">   - family: MyCustomFont</span><br><span class="line">     fonts:</span><br><span class="line">       - asset: fonts/MyCustomFont.ttf</span><br><span class="line">       - style: italic</span><br></pre></td></tr></table></figure><p>然后在Text的<code>style</code>属性进行配置.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">        &apos;This is a custom font text&apos;,</span><br><span class="line">        style: TextStyle(fontFamily: &apos;MyCustomFont&apos;),</span><br><span class="line">      )</span><br></pre></td></tr></table></figure><h3 id="Hint哪里去了-错误信息怎么输出"><a href="#Hint哪里去了-错误信息怎么输出" class="headerlink" title="Hint哪里去了, 错误信息怎么输出"></a>Hint哪里去了, 错误信息怎么输出</h3><p>对于输入框的Hint基本一致, 可能就是换了个名字, 一看便知.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">    decoration: InputDecoration(hintText: &quot;This is a hint&quot;, errorText: _getErrorText()),</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Flutter在视图渲染上另辟蹊径, 性能优势凸显, 在跨平台框架属于一匹黑马, 又有Google撑腰, 值得在Mobile勤耕多年的同学入手. </p><p>由于作者曾经从事过2年的Webkit开发工作, 拜读了Flutter的渲染模式, 很像是Webkit/Chrome/Blink的思路, 通过查证, 起草者确实有大批同样的人, 如果你还没有入坑RN, 或许Flutter可以作为跨平台方案学习的首选哦. </p><p>同样Google自己也有很多Plugin去支持更多扩展功能, 如GPS, Camera, SharePreference, Database. 还例如Firebase这种亲儿子级的服务也是全面支持Flutter. 这些都可以通过<a href="https://pub.dartlang.org" target="_blank" rel="noopener">Dartlang</a>来查询.</p><p>当然也可以自己去开发需要的Plugin来适配需要的功能, 基于的技术就是上面有提的<code>MethodChannel</code>, NDK的支持也是同样的道理.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://flutter.io/docs/get-started/flutter-for/android-devs" target="_blank" rel="noopener">https://flutter.io/docs/get-started/flutter-for/android-devs</a></p>]]></content>
    
    <summary type="html">
    
      Android程序员 Flutter学习笔记 Flutter self-learning notes as an android developer
    
    </summary>
    
      <category term="Flutter" scheme="http://talentprince.github.io/categories/Flutter/"/>
    
    
      <category term="Android" scheme="http://talentprince.github.io/tags/Android/"/>
    
      <category term="Flutter" scheme="http://talentprince.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>如何正确使用Espresso来测试你的Android程序</title>
    <link href="http://talentprince.github.io/2018/09/30/How-to-correctly-use-android-espresso-to-test-your-UI/"/>
    <id>http://talentprince.github.io/2018/09/30/How-to-correctly-use-android-espresso-to-test-your-UI/</id>
    <published>2018-09-30T02:12:48.000Z</published>
    <updated>2020-06-22T09:44:59.477Z</updated>
    
    <content type="html"><![CDATA[<p>UI测试在Android平台上一直都是一个令人头痛的事情, 由于大家平时用的很少, 加之很多文档的缺失, 如果很多东西从头摸索,势必踩坑无数.</p><p>自Android24正式淘汰掉了<a href="https://developer.android.com/reference/android/test/InstrumentationTestCase" target="_blank" rel="noopener">InstrumentationTestCase</a>(位于android.test包), 推出<a href="https://developer.android.com/training/testing/espresso/" target="_blank" rel="noopener">Espresso</a>(位于android.support.test包), Google一直致力于降低UI测试的门槛.</p><p>了解测试金字塔的同学可能知道,UI测试属于功能测试(Functional Test), 或者按照其他的划分也属于集成测试(Integration Test), Google推出了<a href="https://developer.android.com/training/testing/ui-automator" target="_blank" rel="noopener">UIAutomator</a>与<a href="https://developer.android.com/training/testing/espresso" target="_blank" rel="noopener">Espresso</a>来分别处理跨App间的测试(<a href="https://zh.wikipedia.org/wiki/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">黑盒测试</a>)以及App内的测试(<a href="https://zh.wikipedia.org/wiki/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">白盒测试</a>).</p><p>测试步骤类似,分为:</p><ul><li>查找元素</li><li>触发行为</li><li>检测结果</li></ul><p>本文分为三部分, 第一部分简单介绍如何使用Espresso, 第二部分分析如何处理诸如异步, 依赖注入, 程序结构对UI测试的影响以及提供解决办法, 第三部分提供源码以及一些Reference的地址.</p><a id="more"></a><h2 id="Part-I"><a href="#Part-I" class="headerlink" title="Part I"></a>Part I</h2><h3 id="如何配置"><a href="#如何配置" class="headerlink" title="如何配置"></a>如何配置</h3><p>1.需要在gradle的dependencies里添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.2&apos;</span><br><span class="line">androidTestImplementation &apos;com.android.support.test:runner:1.0.2&apos;</span><br><span class="line">androidTestImplementation &apos;com.android.support.test:rules:1.0.2&apos;</span><br></pre></td></tr></table></figure><p>2.在gradle的android.defaultConfig里指定TestRunner</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br></pre></td></tr></table></figure><p>3.书写测试文件,通过<code>AndroidJUnit4</code>来跑即可,使用Activity Rule来启动你的Activity.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Rule</span><br><span class="line">@JvmField</span><br><span class="line">var activityTestRule: ActivityTestRule&lt;MainActivity&gt; = ActivityTestRule&lt;MainActivity&gt;()</span><br></pre></td></tr></table></figure><p>4.添加测试.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onView(withText(&quot;Hello world!&quot;)).check(matches(isDisplayed()));</span><br></pre></td></tr></table></figure><p>5.运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew connectedAndroidTest</span><br></pre></td></tr></table></figure><p>或在IDE中进行运行.</p><p>以上步骤写的比较简略, 如果第一次使用, 可参考<a href="https://developer.android.com/training/testing/espresso/setup" target="_blank" rel="noopener">官方文档</a>.</p><h2 id="Part-II"><a href="#Part-II" class="headerlink" title="Part II"></a>Part II</h2><h3 id="貌似已经会了-打钩-x"><a href="#貌似已经会了-打钩-x" class="headerlink" title="貌似已经会了, 打钩[x]?"></a>貌似已经会了, 打钩[x]?</h3><p>对于简单的UI其实上面的5步已经完全足够,  这也是Espresso好用的地方,  将UI测试写的跟普通的Unit Test一样简单.</p><p>但是随着你的UI变得复杂, 很多问题接踵而至.</p><p>其根本原因在于, Espresso系统在处理内置UI渲染(包括WebView)的异步操作都没有问题, 它会等待页面的渲染与加载, 而你自己如果有异步逻辑, 可能测试进程不会等待其完成而结束, 导致测试失败.</p><p>而采用Unit Test将无论是RxJava的Scheduler或者是Excutor替换成同一个线程的方法没法在UI Test中使用. 原因是UI操作只能在创建它的线程使用(UI 线程), 而如果你用了网络或者Room之类的数据库, 它又无法在UI线程使用, 相互矛盾, 进退两难.</p><p>所以这个时候就需要使用Espresso提供的<a href="https://developer.android.com/training/testing/espresso/idling-resource" target="_blank" rel="noopener">IdleResource</a>, 来通知系统是否Idle或者Busy.</p><h3 id="什么时候该使用IdleResource"><a href="#什么时候该使用IdleResource" class="headerlink" title="什么时候该使用IdleResource"></a>什么时候该使用IdleResource</h3><p>其实IdleResource的官方文档里面有指出, 如果你的测试里有使用:</p><ul><li>Thread.sleep()</li><li>Retry</li><li>CountDown …</li></ul><p>来保证你的测试工作正常, 那么意味着你应该使用IdleResource了.</p><p>或许刚刚接触Espresso的你可能还没有意识到问题所在, 还没有使用Work Around的方法来解决问题, 换个角度来说可能更好理解.</p><p>如果你所测试程序里有使用:</p><ul><li>Databinding</li><li>LiveData</li><li>通过非AsyncTask实现的异步操作</li><li>Fragment跳转</li><li>等等…</li></ul><p>那么就意味着你需要使用IdleResource来保证你的测试能顺利进行, 否则Test Case可能在程序异步操作未执行时就已经关闭了.</p><h3 id="如何使用IdleResource"><a href="#如何使用IdleResource" class="headerlink" title="如何使用IdleResource"></a>如何使用IdleResource</h3><p><a href="https://developer.android.com/training/testing/espresso/idling-resource" target="_blank" rel="noopener">IdleResource</a>的三个关键接口都非常Straigtforward.</p><p>1.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun getName(): String</span><br></pre></td></tr></table></figure></p><p>每一个IdleResource都应该有唯一的Name来注册到系统里, 不能重复.</p><p>2.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun isIdleNow(): Boolean</span><br></pre></td></tr></table></figure></p><p>Espresso会从UI线程调用, 通过这个方法来获得是否进入Idle状态.</p><p>3.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun registerIdleTransitionCallback(callback: IdlingResource.ResourceCallback)</span><br></pre></td></tr></table></figure></p><p>当该IdleResource被使用时, Espresso会注册该callback, 当background job执行完毕后, 需要调用callback.onTransitionToIdle()通知(<strong>如果已经是Idle状态, 调用也不影响, 所以很多简单的实现都是将这个调用放在isIdleNow中, 判断已经idle就调用, 虽然google的best practice里说不要这样</strong>), 该调用会通知UI线程, 并可以在任何线程调用.</p><p>在使用IdleResource的时候, 通常是通过注册Rule来驱动的, 这个就需要继承<code>TestWatcher</code>.</p><p>复写它的starting与finished方法, 通过<code>IdlingRegistry.getInstance().register</code>与<code>IdlingRegistry.getInstance().unregister</code>来注册/反注册IdleReource, 当然可能需要在finished的时候drain掉所有在运行的Task.</p><p>给一个简单的例子把.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class SampleIdleResourceRule : TestWatcher() &#123;</span><br><span class="line">    private val idlingResource: IdlingResource = xxx</span><br><span class="line">    </span><br><span class="line">    override fun starting(description: Description?) &#123;</span><br><span class="line">        IdlingRegistry.getInstance().register(idlingResource)</span><br><span class="line">        super.starting(description)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override fun finished(description: Description?) &#123;</span><br><span class="line">        //drain all the pending task here if needed.</span><br><span class="line">        IdlingRegistry.getInstance().unregister(idlingResource)</span><br><span class="line">        super.finished(description)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="举个IdleResource的例子吧"><a href="#举个IdleResource的例子吧" class="headerlink" title="举个IdleResource的例子吧."></a>举个IdleResource的例子吧.</h3><p>1.使用LiveData等Archtecture Component组件</p><p>我们知道LiveData是一个订阅系统, 是必涉及后台线程, 比较方便的是它自己内部已经调用了IdleResource来增加/减少后台job, 所以直接使用系统提供的<a href="https://developer.android.com/reference/android/support/test/espresso/idling/CountingIdlingResource" target="_blank" rel="noopener">CountingTaskExecutorRule</a>.</p><p>由于Resource name不能重复, 所以为了绕过这个检测, 需要继承<code>CountingTaskExecutorRule</code>来复写getName.</p><p>具体可以参考google的<a href="https://github.com/googlesamples/android-architecture-components/blob/1c91038b55d52fe1006b3b4c6436003f4da29c4f/GithubBrowserSample/app/src/androidTest/java/com/android/example/github/util/TaskExecutorWithIdlingResourceRule.kt#L31" target="_blank" rel="noopener">TaskExecutorWithIdlingResourceRule</a>.</p><p>Google还提供了Databinding的Rule, 可以参考.</p><p>2.等待弹框结束</p><p>一般情况下我们使用DialogFragment来弹框, 如果我们去check一些text被dialog遮挡, 就必须等待其消失后在进行检查.</p><p>这时我们可以通过<code>findFragmentByTag</code>来检测该弹框是否dismiss.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class DialogIdlingResource(</span><br><span class="line">        private val manager: FragmentManager, </span><br><span class="line">        private val tag: String) : IdlingResource &#123;</span><br><span class="line">    private var resourceCallback: IdlingResource.ResourceCallback? = null</span><br><span class="line"></span><br><span class="line">    override fun getName(): String = &quot;xxx&quot;</span><br><span class="line"></span><br><span class="line">    override fun registerIdleTransitionCallback(callback: IdlingResource.ResourceCallback?) &#123;</span><br><span class="line">        resourceCallback = callback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun isIdleNow(): Boolean &#123;</span><br><span class="line">        val idle = manager.findFragmentByTag(tag) == null</span><br><span class="line">        if (idle) &#123;</span><br><span class="line">            resourceCallback?.onTransitionToIdle()</span><br><span class="line">        &#125;</span><br><span class="line">        return idle</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.Delegate Executors/Scheduler</p><p>如果有异步处理逻辑, 大多都位于Repository/ViewModel层, 这部分会被Mock, 但也有一些UI逻辑可能会用到Excecutor. 如RecyclerView的DiffUtil, 需要传入一个Executor来做异步Diff, 这时我们就需要一个Excecutor的IdlingResource, 并把它里面的Delegate赋值给UI.</p><p>这部分可以参考Google GithubBrowser Sample的<a href="https://github.com/googlesamples/android-architecture-components/blob/1c91038b55d52fe1006b3b4c6436003f4da29c4f/GithubBrowserSample/app/src/androidTest/java/com/android/example/github/util/CountingAppExecutorsRule.kt#L32" target="_blank" rel="noopener">CountingAppExecutorsRule</a>.</p><h3 id="应该怎么测试-需要测试什么"><a href="#应该怎么测试-需要测试什么" class="headerlink" title="应该怎么测试, 需要测试什么?"></a>应该怎么测试, 需要测试什么?</h3><p>虽然Espresso测试是集成测试,  但是由于涉及到异步逻辑导致Test Case无法按照预期进行的问题时而存在, 且有时候无法通过IdlingResource来解决.</p><p>比如涉及到多个Fragment的跳转, 就会发生在Fragment未打开时Test Case就挂掉的情况.</p><p>再比如使用RxJava, 在Espresso3.x + RxJava2.x的情况下, 即便将Scheduler代理给IdlingResource也无法保证整个业务流程完整走下来, 异步操作仍无法完整运行, 具体问题可参考Jake大神RxIdler的<a href="https://github.com/square/RxIdler" target="_blank" rel="noopener">Issue</a>.</p><p>所以测试起来就有一些原则需要遵守, 才能保证整个流程的可测性.</p><ul><li>最好对每一个Fragment进行单独测试, Mock所依赖的部分, 如网络, 数据模块, 如果涉及Fragment跳转逻辑, 通过继承来复写进行测试.</li><li>如果使用了RxJava, 需要将其封装在Repository或者Presenter/ViewModel中进行整体的Mock.</li><li>如果使用了Dagger2.android进行自动注入, 最好对测试部分自定义TestRunner提供一个空的Application来Disable注入, 对所测试Fragment注入对象进行手动赋值.</li><li>如果Activity有注入逻辑, 最好将其解耦到Fragment, 因为Espresso的Activity是通过ActivityRule来启动, 无法进行直接手动注入.</li><li>如果无法Move到Fragment, 或者不想… 那就需要在测试里构建自己的Dagger Component, 对于使用Dagger2.android自动注入的, 还需要手动创建Fake的DispatchingAndroidInjector完成手动注入.</li><li>如果未使用Dagger2.android, 通过AndroidInjector来注入的, 可以忽略与注入相关的item.</li></ul><h3 id="能再讲的仔细一些吗"><a href="#能再讲的仔细一些吗" class="headerlink" title="能再讲的仔细一些吗?"></a>能再讲的仔细一些吗?</h3><p>1.单独测试Fragment的好处是可以解耦Fragment之间的跳转, 往往Fragment都是UI流程中的一个环节, 当逻辑完成时会跳向下一Fragment. 可以创建一个空Activity来专门用于显示该Fragment, 并且在测试的setUp里commit该Fragment.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class TestActivity &#123;</span><br><span class="line">    fun showFragment()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RunWith(AndroidJUnit4::class)</span><br><span class="line">class XXXFragmentTest &#123;</span><br><span class="line">    @Rule</span><br><span class="line">    @JvmField</span><br><span class="line">    val activityRule = ActivityTestRule(XXXFragment::class.java)</span><br><span class="line">    </span><br><span class="line">    @Before</span><br><span class="line">    fun init() &#123;</span><br><span class="line">        //1. init fragment</span><br><span class="line">        //2. assign mock data</span><br><span class="line">        activityRule.showFragment(xxx)  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    fun testXXX() &#123;</span><br><span class="line">        xxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.由于常常会需要继承需要测试的Fragment来复写一些类, 对于使用Dagger.android自动注入的, 该子Fragment又未通过<code>@ContributesAndroidInjector</code>进行注册, 往往需要自定义TestRunner, 然后手动注入Fragment.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class CustomTestRunner : AndroidJUnitRunner() &#123;</span><br><span class="line">    override fun newApplication(...) &#123;</span><br><span class="line">        return ...TestApp:class...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        testInstrumentationRunner &quot;xxx.CustomTestRunner&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestApp : Application() &#123;&#125;</span><br><span class="line"></span><br><span class="line">@RunWith(AndroidJUnit4::class)</span><br><span class="line">class XXXFragmentTest &#123;</span><br><span class="line">    //activity rule</span><br><span class="line">    ...</span><br><span class="line">    val testFragment = TestFragment()</span><br><span class="line">    </span><br><span class="line">    @Before</span><br><span class="line">    fun init() &#123;</span><br><span class="line">        testFragment.xxx = mockXXX</span><br><span class="line">        ...</span><br><span class="line">        activityRule.activity.showFragment(testFragment)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    fun testXXX() &#123;</span><br><span class="line">        onView...check(...)</span><br><span class="line">        assertTrue(testFragment.isXXXShow)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class TestFragment : XXXFragment() &#123;</span><br><span class="line">        var isXXXShow = false</span><br><span class="line">        override fun showXXX() &#123;</span><br><span class="line">            isXXXShow = true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.如果Activity有注入逻辑与业务逻辑, 并且不想抽到Fragment中去, 则需要创建Fake的Injector保证可以完成注入, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun createFakeInjector(block: T.() -&gt; Unit): DispatchingAndroidInjector&lt;Activity&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RunWith(AndroidJUnit4::class)</span><br><span class="line">class XXXActivityTest &#123;</span><br><span class="line">    @Rule</span><br><span class="line">    @JvmField</span><br><span class="line">    var activityRule = object : ActivityTestRule&lt;XXX&gt;(XXX::class.java) &#123;</span><br><span class="line">       val app = ...get application</span><br><span class="line">       app.dispatchingAndroidInjector = createFakeInjector&lt;XXX&gt;() &#123;</span><br><span class="line">           //手动注入</span><br><span class="line">           xxx =  mockXXX</span><br><span class="line">           `when`(xxx).thenReturn(xxx)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.为了支持需要通过继承Fragment来完成测试的Case, 还需要对测试模块创建自己的Component来注册从而进行Fake Injector的创建 (类似3, 只是Application/Activity可能为Test版本).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Grale</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    kaptAndroidTest &apos;com.google.dagger:dagger-android-processor:2.X&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Component(modules = [</span><br><span class="line">    AndroidInjectionModule::class,</span><br><span class="line">    AndroidSupportInjectionModule::class,</span><br><span class="line">    ...主App所注册的所有Module,</span><br><span class="line">    TestActivityModule::class])</span><br><span class="line">interface TestCompnent &#123;</span><br><span class="line">    fun inject(xxx: XXX)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Module</span><br><span class="line">abstract class TestActivityModule &#123;</span><br><span class="line">  //通过`ContributesAndroidInjector`注册你的TestActivity, 以及TestFragment  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestApp : Application(), HasActivityInjector &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    lateinit var injector: DispatchingAndroidInjector&lt;Activity&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestActivity : Activity(), HasSupportFragmentInjector &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    lateinit var injector: DispatchingAndroidInjector&lt;Fragment&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Part-III"><a href="#Part-III" class="headerlink" title="Part III"></a>Part III</h2><h3 id="如果还不是很明白可以查看代码"><a href="#如果还不是很明白可以查看代码" class="headerlink" title="如果还不是很明白可以查看代码"></a>如果还不是很明白可以查看代码</h3><p>Disable注入的在这里:<br><a href="https://github.com/googlesamples/android-architecture-components/tree/master/GithubBrowserSample" target="_blank" rel="noopener">Google的Demo GithubBrowser</a></p><p>跟注入相关的在这里:<br><a href="https://github.com/mengdd/DribbbleClient" target="_blank" rel="noopener">自己的Demo</a></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://proandroiddev.com/activity-espresso-test-with-daggers-android-injector-82f3ee564aa4" target="_blank" rel="noopener">https://proandroiddev.com/activity-espresso-test-with-daggers-android-injector-82f3ee564aa4</a></li><li><a href="https://github.com/SabagRonen/dagger-activity-test-sample" target="_blank" rel="noopener">https://github.com/SabagRonen/dagger-activity-test-sample</a></li><li><a href="https://github.com/googlesamples/android-architecture-components/tree/master/GithubBrowserSample" target="_blank" rel="noopener">https://github.com/googlesamples/android-architecture-components/tree/master/GithubBrowserSample</a></li><li><a href="https://developer.android.com/training/testing/espresso/idling-resource" target="_blank" rel="noopener">https://developer.android.com/training/testing/espresso/idling-resource</a></li><li><a href="http://blog.sqisland.com/2015/07/espresso-wait-for-dialog-to-dismiss.html" target="_blank" rel="noopener">http://blog.sqisland.com/2015/07/espresso-wait-for-dialog-to-dismiss.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      如何使用Android Espresso测试UI
    
    </summary>
    
      <category term="Android" scheme="http://talentprince.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://talentprince.github.io/tags/Android/"/>
    
      <category term="Espresso" scheme="http://talentprince.github.io/tags/Espresso/"/>
    
      <category term="UI Automation Test" scheme="http://talentprince.github.io/tags/UI-Automation-Test/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #319</title>
    <link href="http://talentprince.github.io/2018/07/27/Android-Weekly-Issue-319/"/>
    <id>http://talentprince.github.io/2018/07/27/Android-Weekly-Issue-319/</id>
    <published>2018-07-27T01:00:01.000Z</published>
    <updated>2020-06-22T09:44:59.475Z</updated>
    
    <content type="html"><![CDATA[<p>July 22nd, 2018</p><h2 id="Android-Weekly-Issue-319"><a href="#Android-Weekly-Issue-319" class="headerlink" title="Android Weekly Issue #319"></a><a href="http://androidweekly.net/issues/issue-319" target="_blank" rel="noopener">Android Weekly Issue #319</a></h2><p>本期内容包括MotionLayout如何做动画的介绍,Kotlin when完备性的实现,以及如何Move一些Gradle的东西到Kotlin,还包括一个比较好的Kotlin Test库,以及如何用LiveData整合不同数据源,还有一个轻量级的Kotlin Eventbus的推荐.</p><p>Lib部分有Jake大神的Android与Chrome Extension的android sdk查看器,还有一个android黄瓜测试生成工具等…</p><a id="more"></a><h1 id="NOTES"><a href="#NOTES" class="headerlink" title="NOTES"></a>NOTES</h1><h2 id="Creating-Animations-With-MotionLayout-for-Android"><a href="#Creating-Animations-With-MotionLayout-for-Android" class="headerlink" title="Creating Animations With MotionLayout for Android "></a><a href="https://code.tutsplus.com/tutorials/creating-animations-with-motionlayout-for-android--cms-31497" target="_blank" rel="noopener">Creating Animations With MotionLayout for Android </a></h2><p>通过定义MotionLayout布局xml,指定定义好的MotionScene就可以完成动画.</p><p>MotionScene内可以定义ConstraintSet指定位置,然后定义Transition指定起始Constraint,也可以指定KeyFrameSet包含多个KeyPostion,或者KeyCircle.</p><p>还可以绑定事件,OnClick,OnSwipe来启动动画.</p><h2 id="When-is-“when”-exhaustive"><a href="#When-is-“when”-exhaustive" class="headerlink" title="When is “when” exhaustive? "></a><a href="https://medium.com/@ataulm/til-when-is-when-exhaustive-31d69f630a8b" target="_blank" rel="noopener">When is “when” exhaustive? </a></h2><p>为了防止大家写when的时候忘记写else导致问题,作者想出来了一些好办法.</p><p>如when {}.let{}或者扩展方法返回自己.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val &lt;T&gt; T.exhaustive: T</span><br><span class="line">    get() = this</span><br></pre></td></tr></table></figure><h2 id="Android-Studio-Taming-the-interface"><a href="#Android-Studio-Taming-the-interface" class="headerlink" title="Android Studio - Taming the interface "></a><a href="https://jeroenmols.com/blog/2018/07/16/androidstudioshortcuts3/" target="_blank" rel="noopener">Android Studio - Taming the interface </a></h2><p>AS的一些快捷键,有一些很多人没注意到的,如小窗口的大小调整,等等.配有动图.</p><h2 id="Becoming-Google-Certified-Associate-Android-Developer"><a href="#Becoming-Google-Certified-Associate-Android-Developer" class="headerlink" title="Becoming Google Certified Associate Android Developer "></a><a href="https://medium.com/@sodiqOladeni/becoming-google-certified-associate-android-developer-907bdb61d79f" target="_blank" rel="noopener">Becoming Google Certified Associate Android Developer </a></h2><p>Google推出了149美元考助理安卓工程师的认证,24小时完成一个project并提交,如果通过在线10分钟回答5个问题,就可以轻松通过…</p><p>如果不通过可以免费补考,如果还不过那就得交钱了…</p><p>只考安卓四大组件,不考语言知识,因为安卓更重要的是框架组件..</p><h2 id="Maintainable-Architecture-–-Daily-Forecast"><a href="#Maintainable-Architecture-–-Daily-Forecast" class="headerlink" title="Maintainable Architecture – Daily Forecast "></a><a href="https://blog.stylingandroid.com/maintainable-architecture-daily-forecast/" target="_blank" rel="noopener">Maintainable Architecture – Daily Forecast </a></h2><p>系列最后一节,主要讲了如何注入你的ViewModel,还给出了demo地址.</p><h2 id="Cloud-Continuous-Integration-on-Android-with-Kotlin-Project"><a href="#Cloud-Continuous-Integration-on-Android-with-Kotlin-Project" class="headerlink" title="Cloud Continuous Integration on Android with Kotlin Project "></a><a href="https://proandroiddev.com/cloud-continuous-integration-on-android-with-kotlin-project-8d6f12cbf0c4" target="_blank" rel="noopener">Cloud Continuous Integration on Android with Kotlin Project </a></h2><p>文章介绍了如何大家CI,本篇作者使用的是Travis,并且添加了Jacoco生成覆盖率报告,并且push到Codecov.io上.</p><p>最后当然不要忘记加高大上的badge到你的README…</p><h2 id="Moving-Your-Gradle-Build-Scripts-to-Kotlin"><a href="#Moving-Your-Gradle-Build-Scripts-to-Kotlin" class="headerlink" title="Moving Your Gradle Build Scripts to Kotlin "></a><a href="https://pspdfkit.com/blog/2018/moving-your-gradle-build-scripts-to-kotlin/" target="_blank" rel="noopener">Moving Your Gradle Build Scripts to Kotlin </a></h2><p>本篇文章实际上是个标题党,与之前介绍的用Kotlin DSL写gradle的<a href="https://antonioleiva.com/kotlin-dsl-gradle/" target="_blank" rel="noopener">文章</a>不太一样.</p><p>这篇文章只是自己定义了一个plugin,并且可以在自己的buildSrc里面用kotlin声明一些变量, 然后在gradle里面去调用,比如说dependencies的版本.</p><p>之前的那篇文章使用了gradle 4.5.1以上的新特性,然后将gradle后面加上后缀kts即可,当然在buildSrc里面声明变量的同时还需要引用<code>kotlin-dsl</code>插件.这样你的kts文件里就可以写成kotlin dsl风格了.这是题外话…可以查看#283的文章.</p><h2 id="Data-Driven-Testing-with-KotlinTest"><a href="#Data-Driven-Testing-with-KotlinTest" class="headerlink" title="Data Driven Testing with KotlinTest "></a><a href="https://proandroiddev.com/data-driven-testing-with-kotlintest-a07ac60e70fc" target="_blank" rel="noopener">Data Driven Testing with KotlinTest </a></h2><p>作者推荐一个叫<a href="https://github.com/kotlintest/kotlintest" target="_blank" rel="noopener">KotlinTest</a>的库可以提供很多有趣的assert方法.</p><p>来支持他自己的Data driven test的理念,来做数据的对比.</p><p>如forAll可以添加很多组数据,然后通过shouldBe进行判断.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">forAll(</span><br><span class="line">    row(...)</span><br><span class="line">) &#123; ... -&gt;</span><br><span class="line">   ... shouldBe ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reactive-patterns-using-Transformations-and-MediatorLiveData"><a href="#Reactive-patterns-using-Transformations-and-MediatorLiveData" class="headerlink" title="Reactive patterns using Transformations and MediatorLiveData "></a><a href="https://medium.com/google-developers/livedata-beyond-the-viewmodel-reactive-patterns-using-transformations-and-mediatorlivedata-fda520ba00b7" target="_blank" rel="noopener">Reactive patterns using Transformations and MediatorLiveData </a></h2><p>作者介绍了如何用MediatorLiveData+Transformations来实现RxJava类似于zip的功能来进行combine不同的DataSource.</p><p>在这之前作者介绍了使用LiveData过程中的一些注意事项以及解决办法.</p><p>如是否去Share一个LiveData需要值得考虑它会导致的问题,使用MediatorLiveData添加外部source会导致泄露,使用switchMap去解决问题的时候也一定注意需要在构造的时候用,因为map/switchMap都会创建新的LiveData,等等.</p><p>最后一句话写到,如果使用了AutoDisposal的Rxjava第三方控件,就没必须这么用LiveData了.</p><h2 id="Delegate-your-Lifecycle-to-Kotlin"><a href="#Delegate-your-Lifecycle-to-Kotlin" class="headerlink" title="Delegate your Lifecycle to Kotlin "></a><a href="https://blog.blueapron.io/delegate-your-lifecycle-to-kotlin-17c1d0d876c9" target="_blank" rel="noopener">Delegate your Lifecycle to Kotlin </a></h2><p>为了防止一些Activity或者Fragment的变量有跟生命周期同等的初始化与销毁,使用Kotlin的<code>by</code>来交给代理来改变它的Value,代理通过很多方式都可以监听生命周期,如LifecycleObserver,或者RxLifeCycle,来实现setValue.</p><h2 id="KDispatcher-simple-and-light-weight-event-bus-for-Kotlin"><a href="#KDispatcher-simple-and-light-weight-event-bus-for-Kotlin" class="headerlink" title="KDispatcher simple and light-weight event bus for Kotlin "></a><a href="https://medium.com/@sphc/kdispatcher-simple-and-light-weight-event-bus-for-kotlin-e0fa4aaea1c7" target="_blank" rel="noopener">KDispatcher simple and light-weight event bus for Kotlin </a></h2><p>一个Kotlin的轻量EventBus,而且是与平台无关的,backend也可以用.</p><h1 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h1><h2 id="wearfaceutils"><a href="#wearfaceutils" class="headerlink" title="wearfaceutils "></a><a href="https://github.com/purposebakery/wearfaceutils" target="_blank" rel="noopener">wearfaceutils </a></h2><p>Android Wear 表盘</p><h2 id="pickle"><a href="#pickle" class="headerlink" title="pickle "></a><a href="https://github.com/fourlastor/pickle" target="_blank" rel="noopener">pickle </a></h2><p>Android 黄瓜测试代码生成器.</p><h2 id="kotlintest"><a href="#kotlintest" class="headerlink" title="kotlintest "></a><a href="https://github.com/kotlintest/kotlintest" target="_blank" rel="noopener">kotlintest </a></h2><p>一个kotlin test framework, 可以写出 shouldBe should之类的assert.</p><h2 id="SdkSearch"><a href="#SdkSearch" class="headerlink" title="SdkSearch "></a><a href="https://github.com/JakeWharton/SDKSearch" target="_blank" rel="noopener">SdkSearch </a></h2><p>Jake Wharton大哥的android app跟chrome扩展,查询android sdk的.</p><h2 id="ketro"><a href="#ketro" class="headerlink" title="ketro "></a><a href="https://smilecs.github.io/ketro/" target="_blank" rel="noopener">ketro </a></h2><p>Retrofit + LiveData的组合.</p><h2 id="KDispatcher"><a href="#KDispatcher" class="headerlink" title="KDispatcher "></a><a href="https://github.com/Rasalexman/KDispatcher" target="_blank" rel="noopener">KDispatcher </a></h2><p>Kotlin轻量级Event Bus</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://talentprince.github.io/tags/Kotlin/"/>
    
      <category term="Kotlin Delegate" scheme="http://talentprince.github.io/tags/Kotlin-Delegate/"/>
    
      <category term="Kotlin Test" scheme="http://talentprince.github.io/tags/Kotlin-Test/"/>
    
      <category term="Gradle" scheme="http://talentprince.github.io/tags/Gradle/"/>
    
      <category term="LiveData" scheme="http://talentprince.github.io/tags/LiveData/"/>
    
      <category term="MotionLayout" scheme="http://talentprince.github.io/tags/MotionLayout/"/>
    
      <category term="Shortcut" scheme="http://talentprince.github.io/tags/Shortcut/"/>
    
      <category term="Kotlin Eventbus" scheme="http://talentprince.github.io/tags/Kotlin-Eventbus/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #318</title>
    <link href="http://talentprince.github.io/2018/07/15/Android-Weekly-Issue-318/"/>
    <id>http://talentprince.github.io/2018/07/15/Android-Weekly-Issue-318/</id>
    <published>2018-07-15T01:00:01.000Z</published>
    <updated>2020-06-22T09:44:59.474Z</updated>
    
    <content type="html"><![CDATA[<p>July 15th, 2018</p><h2 id="Android-Weekly-Issue-318"><a href="#Android-Weekly-Issue-318" class="headerlink" title="Android Weekly Issue #318"></a><a href="http://androidweekly.net/issues/issue-318" target="_blank" rel="noopener">Android Weekly Issue #318</a></h2><p>本期内容包括Jetpack NavigationUI的介绍, FAT AAR的讨论, Realm迁移到Kotlin的方案,以及如何通过MVI+DataBinding来写程序.还包含DSL改造Android Dialog以及Kotlin scope function的详细解读.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="Android-Jetpack-NavigationUI"><a href="#Android-Jetpack-NavigationUI" class="headerlink" title="Android Jetpack - NavigationUI "></a><a href="https://proandroiddev.com/android-jetpack-navigationui-a7c9f17c510e" target="_blank" rel="noopener">Android Jetpack - NavigationUI </a></h2><p>文章简单介绍了如何将NavigationView或者BottomNavigation与JetPack提供的Navigation控件连起来,通过定义<navigation> xml来实现自动跳转.</navigation></p><h2 id="Why-We-Need-“fat”-AARs-for-Android-Libraries"><a href="#Why-We-Need-“fat”-AARs-for-Android-Libraries" class="headerlink" title="Why We Need “fat” AARs for Android Libraries "></a><a href="https://handstandsam.com/2018/07/13/why-we-need-fat-aars-for-android-libraries/" target="_blank" rel="noopener">Why We Need “fat” AARs for Android Libraries </a></h2><p>Gradle aar不支持打包所有依赖,一般情况下可以使用一个叫做FAT aar的插件,但是已经不更新了.</p><p>还可以通过transitive来让gradle下载依赖,但是作者的疑问在于如果依赖也是不公开的就没办法了.</p><p>Google已经表示3.3会考虑加这个功能.</p><h2 id="Maintainable-Architecture-–-UI-Layer"><a href="#Maintainable-Architecture-–-UI-Layer" class="headerlink" title="Maintainable Architecture – UI Layer "></a><a href="https://blog.stylingandroid.com/maintainable-architecture-five-day-forecast-ui-layer/" target="_blank" rel="noopener">Maintainable Architecture – UI Layer </a></h2><p>继上次介绍数据层,这篇文章介绍了一个Weather App如何使用MVVM实现UI Layer.</p><h2 id="Migrating-your-Realm-to-Kotlin-–-Blue-Apron-Engineering"><a href="#Migrating-your-Realm-to-Kotlin-–-Blue-Apron-Engineering" class="headerlink" title="Migrating your Realm to Kotlin – Blue Apron Engineering "></a><a href="https://blog.blueapron.io/migrating-your-realm-to-kotlin-ee0fa5fc29b" target="_blank" rel="noopener">Migrating your Realm to Kotlin – Blue Apron Engineering </a></h2><p>文章介绍了如何将Realm迁移到Kotlin.</p><ul><li>为了不想让主键为空导致Kotlin nullable变量使用起来需要进行let之类的null check,所以给与初始化值,但是一定要加Migration逻辑保证数据库迁移正确.</li><li>可以通过一些Helper function加!!来避免Null check</li><li>Extension function包装关键字<code>in</code>,因为它是kotlin的关键字.</li></ul><h2 id="Model-View-Intent-amp-Data-Binding"><a href="#Model-View-Intent-amp-Data-Binding" class="headerlink" title="Model-View-Intent &amp; Data Binding "></a><a href="https://proandroiddev.com/model-view-intent-data-binding-39c7a6a6512f" target="_blank" rel="noopener">Model-View-Intent &amp; Data Binding </a></h2><p>作者通过一个登陆页面介绍了如何使用了MVI+DataBinding,适合初步了解MVI的机制以及Reducer的思想.</p><h2 id="Social-Network-Integration-on-Android"><a href="#Social-Network-Integration-on-Android" class="headerlink" title="Social Network Integration on Android "></a><a href="https://www.raywenderlich.com/191933/social-network-integration-on-android" target="_blank" rel="noopener">Social Network Integration on Android </a></h2><p>作者介绍了如何使用诸如FB Twitter这样的social media sdk来实现自己app内的登录与分享.</p><h2 id="Kotlin-Demystified-What-are-‘scope-functions’-and-why-are-they-special"><a href="#Kotlin-Demystified-What-are-‘scope-functions’-and-why-are-they-special" class="headerlink" title="Kotlin Demystified: What are ‘scope functions’ and why are they special? "></a><a href="https://medium.com/google-developers/kotlin-demystified-scope-functions-57ca522895b1" target="_blank" rel="noopener">Kotlin Demystified: What are ‘scope functions’ and why are they special? </a></h2><p>作者介绍了Kotlin里面的scope functions,其实就是let/run/with/apply/also.</p><p>作者的总结比较复杂,其实有一个比较简单的图可以清楚了解之间的关系.</p><p>如果你需要返回本身,就使用apply或者also,其区别就是使用this或者it.</p><p>如果你不需要返回本身,又想要做null判断,那就是用T.run或者let,当然区别也是this或者it.</p><p>如果你即不需要返回本身,又不用判断null,那就用with或者run,区别也是this或者it.</p><h2 id="Seedbank-—-discover-machine-learning-examples"><a href="#Seedbank-—-discover-machine-learning-examples" class="headerlink" title="Seedbank — discover machine learning examples "></a><a href="https://medium.com/tensorflow/seedbank-discover-machine-learning-examples-2ff894542b57" target="_blank" rel="noopener">Seedbank — discover machine learning examples </a></h2><p>可以在线的试一试Machine Learning</p><h2 id="From-Java-Builders-to-Kotlin-DSLs"><a href="#From-Java-Builders-to-Kotlin-DSLs" class="headerlink" title="From Java Builders to Kotlin DSLs "></a><a href="https://kotlinexpertise.com/java-builders-kotlin-dsls/" target="_blank" rel="noopener">From Java Builders to Kotlin DSLs </a></h2><p>教大家如何把Dialog Builder改造成Kotlin DSL,使用起来非常炫酷.</p><p>其实大家也都清楚了,就是通过Extension Function.</p><p>具体可以去看看作者的对比,DSL化后使用起来跟CSS一样,花括号套起来就实现了Dialog.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">draw &#123;</span><br><span class="line">    drawerLayout = xxxx</span><br><span class="line">    onItemClick &#123;</span><br><span class="line">        xxxxx</span><br><span class="line">    &#125;</span><br><span class="line">    onOpen &#123;</span><br><span class="line">        Toast.xxxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="android-face-detector"><a href="#android-face-detector" class="headerlink" title="android-face-detector "></a><a href="https://github.com/husaynhakeem/android-face-detector" target="_blank" rel="noopener">android-face-detector </a></h2><p>实时面部识别的lib,使用的Firebase ML kit.</p><h2 id="UnderlinePageIndicator"><a href="#UnderlinePageIndicator" class="headerlink" title="UnderlinePageIndicator "></a><a href="https://github.com/dcampogiani/UnderlinePageIndicator" target="_blank" rel="noopener">UnderlinePageIndicator </a></h2><p>类似于系统design的TabLayout那种效果.</p><h2 id="Seedbank"><a href="#Seedbank" class="headerlink" title="Seedbank "></a><a href="https://tools.google.com/seedbank/" target="_blank" rel="noopener">Seedbank </a></h2><p>在线测试ML的.</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="Realm" scheme="http://talentprince.github.io/tags/Realm/"/>
    
      <category term="Kotlin DSL" scheme="http://talentprince.github.io/tags/Kotlin-DSL/"/>
    
      <category term="MVI" scheme="http://talentprince.github.io/tags/MVI/"/>
    
      <category term="DataBinding" scheme="http://talentprince.github.io/tags/DataBinding/"/>
    
      <category term="Jetpack" scheme="http://talentprince.github.io/tags/Jetpack/"/>
    
      <category term="Navigation" scheme="http://talentprince.github.io/tags/Navigation/"/>
    
      <category term="AAR" scheme="http://talentprince.github.io/tags/AAR/"/>
    
      <category term="Scope Functions" scheme="http://talentprince.github.io/tags/Scope-Functions/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #317</title>
    <link href="http://talentprince.github.io/2018/07/08/Android-Weekly-Issue-317/"/>
    <id>http://talentprince.github.io/2018/07/08/Android-Weekly-Issue-317/</id>
    <published>2018-07-08T11:00:01.000Z</published>
    <updated>2020-06-22T09:44:59.474Z</updated>
    
    <content type="html"><![CDATA[<p>July 8th, 2018</p><h2 id="Android-Weekly-Issue-317"><a href="#Android-Weekly-Issue-317" class="headerlink" title="Android Weekly Issue #317"></a><a href="http://androidweekly.net/issues/issue-317" target="_blank" rel="noopener">Android Weekly Issue #317</a></h2><p>本期主要内容包括”重磅”的Udacity放弃RN(其实是因为他们RN写的那个Feature不要了),还包括如七部使用Google Page Lib,如何用Room设计与创建可维护的数据库等Code Guide的文章,以及Android P字体渲染,放大镜,Google新版Universal Music Play Sample,还有Retrofit如何工作,如何通过Kotlin Extension Generation来改善Dagger Butterknife使用体验,等等.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="State-of-Kotlin"><a href="#State-of-Kotlin" class="headerlink" title="State of Kotlin "></a><a href="https://pusher.com/state-of-kotlin" target="_blank" rel="noopener">State of Kotlin </a></h2><p>Kotlin状态的一些列数据,包括它的使用率,渗透率,在项目中的应用率等多种多样的数据,并且可以订阅.</p><p>一切数据表明,Kotlin在过去的一年中发展迅速,使用量Double,并且好评如潮.</p><h2 id="How-does-Retrofit-work"><a href="#How-does-Retrofit-work" class="headerlink" title="How does Retrofit work "></a><a href="https://medium.com/@theneckmaster/how-does-retrofit-work-6ecad1bb683b" target="_blank" rel="noopener">How does Retrofit work </a></h2><p>文章讲述了Retrofit如何工作,实际上是通过Proxy而非Processor去生成代码来实现的.文章表示在运行速度与编译速度上的Compromise是一个值得思考的问题.</p><h2 id="Exploring-Android-P-Magnifier"><a href="#Exploring-Android-P-Magnifier" class="headerlink" title="Exploring Android P: Magnifier "></a><a href="https://medium.com/@hitherejoe/exploring-android-p-magnifier-ddfd06bdecbe" target="_blank" rel="noopener">Exploring Android P: Magnifier </a></h2><p>Android P提供了放大镜功能,并且TextView默认就实现了.<br>国内用户应该不是很陌生,几年前国内的一些大Android浏览器厂商在WebView里面也有类似的功能,不过主要是Android copy了 iOS的默认属性…</p><h2 id="Tracking-Android-app-metrics"><a href="#Tracking-Android-app-metrics" class="headerlink" title="Tracking Android app metrics "></a><a href="https://medium.com/@emmaguy/tracking-android-app-metrics-431cbea2113d" target="_blank" rel="noopener">Tracking Android app metrics </a></h2><p>文章介绍了CI上使用<a href="http://www.stathat.com/manual/start" target="_blank" rel="noopener">StatHat</a>上传APK的一些数据,比如size等,然后发现问题后通过<a href="http://danger.systems/ruby/" target="_blank" rel="noopener">Danger</a>给Github的PR上面发出报警.</p><p>这两个都是Ruby的应用.</p><h2 id="Kotlin-extension-function-generation"><a href="#Kotlin-extension-function-generation" class="headerlink" title="Kotlin extension function generation "></a><a href="https://medium.com/the-fabulous/kotlin-extension-methods-generation-15b5e6499dc8" target="_blank" rel="noopener">Kotlin extension function generation </a></h2><p>文章介绍了自己给Dagger与Butterknife写的ktx.</p><p>由于Dagger使用了生成文件进行注入,所以必须先编译一边才能通过Compiler生成文件,使用起来不便.</p><p>而ButterKnife使用了反射通过类名将自己Generate的辅助类在运行时创建,我们想消除这个反射.</p><p>这些原因都因为Processor只能生成文件,而无法改变已有文件.</p><p>所以作者使用了Kotlin Extension,首先在Lib里定义了一些Mock的接口,所以编译之前可以调用这些空实现.而在编译过程中,Compiler会生成对应的扩展方法,这样Dagger与Butterknife的问题都得以解决.</p><h2 id="What’s-new-for-text-in-Android-P"><a href="#What’s-new-for-text-in-Android-P" class="headerlink" title="What’s new for text in Android P "></a><a href="https://android-developers.googleblog.com/2018/07/whats-new-for-text-in-android-p.html?linkId=53827942" target="_blank" rel="noopener">What’s new for text in Android P </a></h2><p>Android P在TextView上下了狠功夫,增加了很多功能.</p><ul><li>PrecomputedText</li></ul><p>复杂字体Font在显示的时候实际上90%的时间都耗费在Measure计算上, 可以在后台线程通过<code>PrecomputedText</code>计算,然后在UI线程set</p><ul><li>Magnifier</li></ul><p>放大镜,上篇有提到.TextView自己默认实现了.</p><ul><li>Smart Linkify</li></ul><p>TextView方按选中可以通过Google的ML处理解析,提供可能相关的应用显示在Copy Cut Paste旁边,这一切都是通过<code>TextClassifier</code>实现的.</p><ul><li>Line Height &amp; Baseline Alignment</li></ul><p>提供了几个Attribute控制文字行高,以及baseline的top与bottom margin.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app:lineHeight</span><br><span class="line">app:firstBaselineToTopHeight</span><br><span class="line">app:lastBaselineToBottomHeight</span><br></pre></td></tr></table></figure><h2 id="React-Native-A-retrospective-from-the-mobile-engineering-team-at-Udacity"><a href="#React-Native-A-retrospective-from-the-mobile-engineering-team-at-Udacity" class="headerlink" title="React Native: A retrospective from the mobile-engineering team at Udacity"></a><a href="https://engineering.udacity.com/react-native-a-retrospective-from-the-mobile-engineering-team-at-udacity-89975d6a8102" target="_blank" rel="noopener">React Native: A retrospective from the mobile-engineering team at Udacity</a></h2><p>Udacity也放弃了RN,看了整片博客,感觉是他们可能只是为了凑个热度.</p><p>首先他们放弃的最主要原因是他们就一个Feature用了RN,而且当时也是因为它很独立,然后尝试了RN,现在这个Feature不用了,就删掉了.</p><p>然后他们的Android Dev细数了RN的十宗罪,但是都是我们大概能想到的.</p><p>比如实际上两个平台尤其android还是需要通过改code来修bug或者特殊需求,RN与native互通麻烦,RN导致CI编译长,包增大,启动变慢,RN文档欠缺,代码变更太快,自身bug多,不同设备不同表现,遇到问题常常需要改源码等等等等.</p><p>而之所以当初要使用,主要原因是为了省事,可惜后来发现还是费事了,所以以后再也不会考虑RN了.</p><h2 id="Automated-testing-will-set-your-engineering-team-free"><a href="#Automated-testing-will-set-your-engineering-team-free" class="headerlink" title="Automated testing will set your engineering team free "></a><a href="https://medium.com/azimolabs/automated-testing-will-set-your-engineering-team-free-a89467c40731" target="_blank" rel="noopener">Automated testing will set your engineering team free </a></h2><p>作者介绍了他们的应用是如何保证质量的,答案就是写测试,一般feature手工只测一遍,剩下就得自动化测试.</p><p>测试他们分为三类, UT是开发来写, 基本覆盖每一个函数,集成测试用Robolectric是QA负责来写,End to End test使用Espresso,Instrument Test等,整个跑下来不能超过三小时.</p><h2 id="Compiler-based-security-mitigations-in-Android-P"><a href="#Compiler-based-security-mitigations-in-Android-P" class="headerlink" title="Compiler-based security mitigations in Android P "></a><a href="https://android-developers.googleblog.com/2018/06/compiler-based-security-mitigations-in.html?linkId=53786461" target="_blank" rel="noopener">Compiler-based security mitigations in Android P </a></h2><p>从Android P开始基于Clang编译器做了很多优化,提升了稳定性,降低了被攻击的风险.</p><p>如CFI (Control Flow Integrity<br>) 技术,主要是增加了虚函数指针偏移指向地址的检查,如果发现指向非法地址就会终止编译.</p><p>IOS (Integer Overflow Sanitization<br>) 技术会检测有符号或者无符号的Integer在算法中溢出的问题,并且优化后运用到了一些库的编译中,如libui, libnl,libexif等…</p><h2 id="7-steps-to-implement-Paging-library-in-Android"><a href="#7-steps-to-implement-Paging-library-in-Android" class="headerlink" title="7 steps to implement Paging library in Android "></a><a href="https://proandroiddev.com/8-steps-to-implement-paging-library-in-android-d02500f7fffe" target="_blank" rel="noopener">7 steps to implement Paging library in Android </a></h2><p>文章介绍了如何使用Google Architecture Component里面的Page来实现分页加载.</p><p>总共有七步,关键是实现PageKeyedDataSource接口封装MutableLiveData. 实现DataSource.Factory将DataSource封装成Factory.</p><p>然后就可以通过LivePagedListBuilder来生成数据了.</p><h2 id="A-New-Universal-Music-Player"><a href="#A-New-Universal-Music-Player" class="headerlink" title="A New Universal Music Player "></a><a href="https://android-developers.googleblog.com/2018/06/a-new-universal-music-player.html?linkId=53783436" target="_blank" rel="noopener">A New Universal Music Player </a></h2><p>鉴于大家对Google的Universal Music Player的喜爱,推出V2版,采用Kotlin与MVVM的架构,但是还有一些小功能没有加进来.</p><h2 id="Publishing-your-library-to-jCenter-from-Android-Studio"><a href="#Publishing-your-library-to-jCenter-from-Android-Studio" class="headerlink" title="Publishing your library to jCenter from Android Studio "></a><a href="https://android.jlelse.eu/publishing-your-android-kotlin-or-java-library-to-jcenter-from-android-studio-1b24977fe450" target="_blank" rel="noopener">Publishing your library to jCenter from Android Studio </a></h2><p>作者在网上找如何上传jcenter,找了很多说法不一的,所以一怒之下自己写了一篇.</p><h2 id="Maintainable-Architecture-–-Five-Day-Forecast-Data-Layer"><a href="#Maintainable-Architecture-–-Five-Day-Forecast-Data-Layer" class="headerlink" title="Maintainable Architecture – Five Day Forecast Data Layer "></a><a href="https://blog.stylingandroid.com/maintainable-architecture-five-day-forecast-data-layer/" target="_blank" rel="noopener">Maintainable Architecture – Five Day Forecast Data Layer </a></h2><p>作者通过实现一个天气预报软件的数据库,来介绍如何设计以及使用正确的方案来确保软件架构正确与维护的成本.</p><p>PS:使用的是Room.</p><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="RecyclerView-FastScroller"><a href="#RecyclerView-FastScroller" class="headerlink" title="RecyclerView-FastScroller "></a><a href="https://github.com/quiph/RecyclerView-FastScroller" target="_blank" rel="noopener">RecyclerView-FastScroller </a></h2><p>Kotlin写的快速滑动的滚动条,按照首字母.</p><h2 id="vector-analog-clock"><a href="#vector-analog-clock" class="headerlink" title="vector-analog-clock "></a><a href="https://github.com/TurkiTAK/vector-analog-clock" target="_blank" rel="noopener">vector-analog-clock </a></h2><p>Vector实现的石英表,适配各种屏幕.</p><h2 id="androme"><a href="#androme" class="headerlink" title="androme "></a><a href="https://github.com/anpham6/androme" target="_blank" rel="noopener">androme </a></h2><p>可以将带JS的HTML5页面转换为多个Android Layout.</p><h2 id="android-UniversalMusicPlayer"><a href="#android-UniversalMusicPlayer" class="headerlink" title="android-UniversalMusicPlayer "></a><a href="https://github.com/googlesamples/android-UniversalMusicPlayer" target="_blank" rel="noopener">android-UniversalMusicPlayer </a></h2><p>Google重写的UAMP</p><h2 id="LazyDatePicker"><a href="#LazyDatePicker" class="headerlink" title="LazyDatePicker. "></a><a href="https://github.com/lopspower/LazyDatePicker" target="_blank" rel="noopener">LazyDatePicker. </a></h2><p>替代系统DatePicker的一个第三方组件.</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="Jetpack" scheme="http://talentprince.github.io/tags/Jetpack/"/>
    
      <category term="Page" scheme="http://talentprince.github.io/tags/Page/"/>
    
      <category term="React Native" scheme="http://talentprince.github.io/tags/React-Native/"/>
    
      <category term="Kotlin Extension" scheme="http://talentprince.github.io/tags/Kotlin-Extension/"/>
    
      <category term="Android P" scheme="http://talentprince.github.io/tags/Android-P/"/>
    
      <category term="Universal Music Player" scheme="http://talentprince.github.io/tags/Universal-Music-Player/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #316</title>
    <link href="http://talentprince.github.io/2018/07/01/Android-Weekly-Issue-316/"/>
    <id>http://talentprince.github.io/2018/07/01/Android-Weekly-Issue-316/</id>
    <published>2018-07-01T11:00:01.000Z</published>
    <updated>2020-06-22T09:44:59.474Z</updated>
    
    <content type="html"><![CDATA[<p>July 1st, 2018</p><h2 id="Android-Weekly-Issue-316"><a href="#Android-Weekly-Issue-316" class="headerlink" title="Android Weekly Issue #316"></a><a href="http://androidweekly.net/issues/issue-316" target="_blank" rel="noopener">Android Weekly Issue #316</a></h2><p>本期内容包含教你使用Kotlin通过Annotation Processor生成代码文件, JetPack中的Android KTX, 以及升级到Target26所需要注意的东西,还包含如何使用KTX简化AndroidX里面的Slice的Build,以及如何通过MotionLayout方便实现动画的系列,还有MLKit中扫条形码的Lib介绍,以及一些譬如Kotlin MVVM, Koin依赖注入做Test, UI Test去除动画,入行一年感受,DialogFLow来做面试机器人等等的有趣内容.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="Generating-Code-via-Annotations-in-Kotlin"><a href="#Generating-Code-via-Annotations-in-Kotlin" class="headerlink" title="Generating Code via Annotations in Kotlin "></a><a href="https://willowtreeapps.com/ideas/generating-code-via-annotations-in-kotlin" target="_blank" rel="noopener">Generating Code via Annotations in Kotlin </a></h2><p>文章介绍了如果用Kotlin来写Annotation Processor生成代码.</p><p>两个关键的Lib</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\\ Code generation library for kotlin, highly recommended</span><br><span class="line">implementation &apos;com.squareup:kotlinpoet:0.7.0&apos;</span><br><span class="line"></span><br><span class="line">\\ configuration generator for service providers</span><br><span class="line">implementation &quot;com.google.auto.service:auto-service:1.0-rc4&quot;</span><br><span class="line">kapt &quot;com.google.auto.service:auto-service:1.0-rc4&quot;</span><br></pre></td></tr></table></figure><ul><li>首先需要通过<code>annotation class</code>定义自己的Annotation.</li><li>其实继承<code>AbstractProcessor</code>实现自己的Processor, 通过<code>@AutoService</code>注册到系统的<code>Processor.class</code>上去.复写<code>process</code>方法生成代码.</li></ul><h2 id="Android-KTX-Android-development-with-Kotlin"><a href="#Android-KTX-Android-development-with-Kotlin" class="headerlink" title="Android KTX - Android development with Kotlin "></a><a href="https://kotlinexpertise.com/android-ktx-kotlin/" target="_blank" rel="noopener">Android KTX - Android development with Kotlin </a></h2><p>之前已经有不少Kotlin的语法糖了,这次JetPack推出的是Android官方的KTX,其主要实现原理就是通过给已有的Framework添加很多方法或者变量的Extension.</p><p>类似于Anko, 支持的列表在<a href="https://developer.android.com/kotlin/ktx" target="_blank" rel="noopener">这里</a>,当然对于类似的Project, 学习是一个过程.</p><h2 id="Remember-remember…-to-target-API-26-on-November"><a href="#Remember-remember…-to-target-API-26-on-November" class="headerlink" title="Remember, remember… to target API 26 on November! "></a><a href="https://medium.com/@fabionegri/remember-remember-to-target-api-26-on-november-7ce4fdde2c08" target="_blank" rel="noopener">Remember, remember… to target API 26 on November! </a></h2><p>文章列举了要逐步将Target升级到26所需要注意的东西.</p><p>Marshmallow 6.0 Level 23</p><ul><li>Runtime Permission</li><li>删除了Apache Http Client</li><li>从OpenSSL到BoringSSL</li><li>删除<code>Notification.setLatestEventInfo()</code></li></ul><p>Nougat 7.0 Level 24</p><ul><li>限制后台网络,删除了<code>CONNECTIVITY_ACTION</code>广播通知,以及Intent中的 <code>ACTION_NEW_PICTURE</code>与<code>ACTION_NEW_VIDEO</code>.</li><li>App外无法通过<code>file://</code>访问私有文件.</li><li>链接非NDK的Lib不行了.</li></ul><p>Nougat 7.1 Level 25</p><ul><li>App Shortcuts</li><li>支持Image到Keyboard里,通过<a href="https://developer.android.com/guide/topics/text/image-keyboard" target="_blank" rel="noopener">Commit Content API</a>.</li><li>添加了<code>android:roundIcon</code></li></ul><p>Oreo 8.0 Leve26</p><ul><li>必须通过<code>startForeground</code>和<code>startForegroundService</code>来启动前台的服务,无法启动后台服务.</li><li>移除了几乎所有的隐式广播,除了<a href="https://developer.android.com/guide/components/broadcast-exceptions" target="_blank" rel="noopener">部分</a>.</li><li>后台位置信息收到限制,推荐使用GCM的<code>FusedLocationProviderClient</code>或者<code>Geofencing</code>.</li><li>必须制定Notification Channel,否则收不到通知.</li></ul><h2 id="My-first-weeks-as-an-Android-Dev"><a href="#My-first-weeks-as-an-Android-Dev" class="headerlink" title="My first weeks as an Android Dev "></a><a href="https://engineering.udacity.com/my-first-weeks-as-an-android-dev-e956ee49418d" target="_blank" rel="noopener">My first weeks as an Android Dev </a></h2><p>介绍了自己第一周做Android开发的经历,面对自己的任务,接触到了譬如<code>Design</code>,<code>ConstraintLayout</code>,<code>Data Binding &amp; ViewModel</code>, <code>DI</code>,以及<code>Kotlin</code>的东西,有点应接不暇.</p><h2 id="Espresso-animations-disabled-flag"><a href="#Espresso-animations-disabled-flag" class="headerlink" title="Espresso animations disabled flag "></a><a href="https://github.com/ghostbuster91/espresso-animations-disabled-test" target="_blank" rel="noopener">Espresso animations disabled flag </a></h2><p>通过设置flag来禁止测试中动画, 方便测试.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testOptions &#123;</span><br><span class="line">    animationsDisabled = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exploring-Firebase-MLKit-on-Android-Barcode-Scanning-Part-Three"><a href="#Exploring-Firebase-MLKit-on-Android-Barcode-Scanning-Part-Three" class="headerlink" title="Exploring Firebase MLKit on Android: Barcode Scanning (Part Three) "></a><a href="https://medium.com/@hitherejoe/exploring-firebase-mlkit-on-android-barcode-scanning-part-three-cc6f5921a108" target="_blank" rel="noopener">Exploring Firebase MLKit on Android: Barcode Scanning (Part Three) </a></h2><p>文章介绍了用Firebase的VisionBarcode来扫条形码.</p><h2 id="Introducing-Slice-Builders-KTX"><a href="#Introducing-Slice-Builders-KTX" class="headerlink" title="Introducing Slice Builders KTX "></a><a href="https://medium.com/google-developers/introducing-slice-builders-ktx-2218ebde356" target="_blank" rel="noopener">Introducing Slice Builders KTX </a></h2><p>Android Slice是最新推出的AndroidX里面的控件,主要是给Google Search App来提供一些类似Google Assistant的那种UI,支持静态与动态的布局.</p><p>KTX也推出了对该组件的支持,以便通过Kotlin来简化Slice Build使用过程.</p><p>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list(context, sliceUri, ListBuilder.INFINITY) &#123;</span><br><span class="line">        row &#123;</span><br><span class="line">           setTitle(&quot;Hello world&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Building-an-Action-to-Solve-a-Real-World-Problem-Part-1-Plan-amp-Design"><a href="#Building-an-Action-to-Solve-a-Real-World-Problem-Part-1-Plan-amp-Design" class="headerlink" title="Building an Action to Solve a Real World Problem: Part 1, Plan &amp; Design "></a><a href="https://medium.com/google-developers/building-an-action-to-solve-a-real-world-problem-part-1-plan-design-2a701fa004c8" target="_blank" rel="noopener">Building an Action to Solve a Real World Problem: Part 1, Plan &amp; Design </a></h2><p>通过Dialogflow等一系列技术搭建了一个给面试者出题的训练系统,根据对话提供不同的题目.</p><h2 id="Introduction-to-MotionLayout-part-I"><a href="#Introduction-to-MotionLayout-part-I" class="headerlink" title="Introduction to MotionLayout (part I) "></a><a href="https://medium.com/google-developers/introduction-to-motionlayout-part-i-29208674b10d" target="_blank" rel="noopener">Introduction to MotionLayout (part I) </a></h2><p>介绍了Google最新的ConstraintLayout 2.0的子类<code>MotionLayout</code>的使用,它可以通过在xml文件里定义的<code>MotionScene</code>来指定一些动画.</p><p>这些都是通过<code>TransitionManager</code>完成的,它会自己计算开始与结束之间的位置,完成动画,有点像Activity之间的SharedElement Transition Animation.</p><h2 id="Testing-with-Koin"><a href="#Testing-with-Koin" class="headerlink" title="Testing with Koin "></a><a href="https://proandroiddev.com/testing-with-koin-ade8a46eb4d" target="_blank" rel="noopener">Testing with Koin </a></h2><p>通过Koin依赖注入框架来简化Kotlin Test里面的mock注入.</p><h2 id="MVVM-with-Kotlin"><a href="#MVVM-with-Kotlin" class="headerlink" title="MVVM with Kotlin "></a><a href="https://proandroiddev.com/mvvm-with-kotlin-android-architecture-components-dagger-2-retrofit-and-rxandroid-1a4ebb38c699" target="_blank" rel="noopener">MVVM with Kotlin </a></h2><p>介绍了Kotlin下Android的MVVM的全套实践,包含了DataBinding, Retrofit, Dagger等等.</p><h2 id="Introducing-adb-enhanced-A-swiss-army-knife-for-Android-development"><a href="#Introducing-adb-enhanced-A-swiss-army-knife-for-Android-development" class="headerlink" title="Introducing adb-enhanced: A swiss army knife for Android development "></a><a href="https://ashishb.net/tech/introducing-adb-enhanced-a-swiss-army-knife-for-android-development/" target="_blank" rel="noopener">Introducing adb-enhanced: A swiss army knife for Android development </a></h2><p>一个Python的应用, enhance的adb,可以方便的进行clean安装,节能模式,doze模式的调试等等.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install adb-enhanced</span><br></pre></td></tr></table></figure><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="ColorPickerView"><a href="#ColorPickerView" class="headerlink" title="ColorPickerView "></a><a href="https://github.com/skydoves/ColorPickerView" target="_blank" rel="noopener">ColorPickerView </a></h2><p>一个选择颜色的picker view</p><h2 id="adb-enhanced"><a href="#adb-enhanced" class="headerlink" title="adb-enhanced "></a><a href="https://github.com/ashishb/adb-enhanced" target="_blank" rel="noopener">adb-enhanced </a></h2><p>上面介绍的加强型Adb</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="Google IO" scheme="http://talentprince.github.io/tags/Google-IO/"/>
    
      <category term="Kotlin Espresso" scheme="http://talentprince.github.io/tags/Kotlin-Espresso/"/>
    
      <category term="Navigation Architecture Component" scheme="http://talentprince.github.io/tags/Navigation-Architecture-Component/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #315</title>
    <link href="http://talentprince.github.io/2018/06/24/Android-Weekly-Issue-315/"/>
    <id>http://talentprince.github.io/2018/06/24/Android-Weekly-Issue-315/</id>
    <published>2018-06-24T07:00:01.000Z</published>
    <updated>2020-06-22T09:44:59.474Z</updated>
    
    <content type="html"><![CDATA[<p>June 24th, 2018</p><h2 id="Android-Weekly-Issue-315"><a href="#Android-Weekly-Issue-315" class="headerlink" title="Android Weekly Issue #315"></a><a href="http://androidweekly.net/issues/issue-315" target="_blank" rel="noopener">Android Weekly Issue #315</a></h2><p>本篇内容包括,Android P的优先级队列管理,Yelp性能测试系列最后一篇帧率监控,以及近期比较火的Airbnb下一步移动战略,还包含连接Clould IoT Core的Library介绍,ML Kit文字识别,与如何从AndroidJob迁移到WorkManager.还有一篇如何搭建面试机器人的介绍,以及尚在早期的Kotlin Native跨平台数据库的概况等.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="Exploring-Android-P-Priority-Buckets"><a href="#Exploring-Android-P-Priority-Buckets" class="headerlink" title="Exploring Android P: Priority Buckets "></a><a href="https://medium.com/google-developer-experts/exploring-android-p-priority-buckets-d34d12059d36" target="_blank" rel="noopener">Exploring Android P: Priority Buckets </a></h2><p>这次Google IO Android P推出了Priority Buckets来提供更好的电池管理.</p><p>通过使用频率,将App分为<code>Active</code>,<code>Working Set</code>,<code>Frequent</code>,<code>Rare</code>,<code>Never</code>几个级别, 不同级别会对Jobs还有Alarms有不同的最大延时.</p><p>分组是动态改变的.</p><h2 id="My-checklist-for-fixing-build-issues"><a href="#My-checklist-for-fixing-build-issues" class="headerlink" title="My checklist for fixing build issues "></a><a href="https://medium.com/@mikewolfson/android-studio-is-borked-my-checklist-for-fixing-build-issues-e41a9dd8cba8" target="_blank" rel="noopener">My checklist for fixing build issues </a></h2><p>作者的AndroidTest里面Import都无法识别了,提示<code>Cannot find symbol</code>,解决办法是清掉一些缓存.</p><p>包括本地Gradle,Project idea与gradle,以及AS的Cache…而后解决了.</p><h2 id="Understanding-the-emotions-of-users-through-NLP"><a href="#Understanding-the-emotions-of-users-through-NLP" class="headerlink" title="Understanding the emotions of users through NLP "></a><a href="https://medium.com/azimolabs/understanding-the-emotions-of-users-through-natural-language-processing-4535ff90f50b" target="_blank" rel="noopener">Understanding the emotions of users through NLP </a></h2><p>作者讲解了通过Firebase functions platform + Google Cloud Natural搭建一个App的客服系统.</p><h2 id="Introducing-Billingx"><a href="#Introducing-Billingx" class="headerlink" title="Introducing Billingx "></a><a href="https://ryanharter.com/blog/introducing-billingx/" target="_blank" rel="noopener">Introducing Billingx </a></h2><p>Google唯一渠道实现App内购买的API就是Billing Library,但是对于测试者来说使用起来很麻烦,而且直到2018 Google I/O也没有新的动作.</p><p>之前也分享过一个叫做<a href="https://github.com/NYTimes/Register" target="_blank" rel="noopener">Register</a>,通过Mock,实现了本地的测试,但是会在Production Apk中引入没必要的代码.</p><p>作者自己封装了一个叫<a href="https://github.com/pixiteapps/billingx" target="_blank" rel="noopener">BillingX</a>的库,提供了空实现给Production版,通过<code>releaseImplementation</code>引入.</p><h2 id="Text-Recognition-with-ML-Kit"><a href="#Text-Recognition-with-ML-Kit" class="headerlink" title="Text Recognition with ML Kit "></a><a href="https://www.raywenderlich.com/197292/text-recognition-with-ml-kit" target="_blank" rel="noopener">Text Recognition with ML Kit </a></h2><p>介绍了这次ML Kit中的云端文字识别API,通过Firebase服务Enable,可以实现图片中文字的<code>in-cloud text recognition</code>,不想掏钱可以试用哦,选择Blaze Plan按需缴费,头1000次请求免费的.</p><h2 id="Publishing-your-Android-Kotlin-or-Java-library-to-mavenCentral"><a href="#Publishing-your-Android-Kotlin-or-Java-library-to-mavenCentral" class="headerlink" title="Publishing your Android, Kotlin or Java library to mavenCentral "></a><a href="https://medium.com/@vanniktech/publishing-your-android-kotlin-or-java-library-to-mavencentral-e22f343b9659" target="_blank" rel="noopener">Publishing your Android, Kotlin or Java library to mavenCentral </a></h2><p>大家平时常用的<a href="https://github.com/chrisbanes/gradle-mvn-push" target="_blank" rel="noopener">Chris Banes</a>的脚本要迁移到Kotlin上还要做一些改动,作者自己弄了一份,并且把它做成了plugin,只需要加到自己的plugin dependencies里面就行了.</p><h2 id="Performance-Improvements-for-Search-on-The-Yelp-Android-App-Part-3"><a href="#Performance-Improvements-for-Search-on-The-Yelp-Android-App-Part-3" class="headerlink" title="Performance Improvements for Search on The Yelp Android App - Part 3 "></a><a href="https://engineeringblog.yelp.com/2018/06/android-search-perf-improvements-part-3.html" target="_blank" rel="noopener">Performance Improvements for Search on The Yelp Android App - Part 3 </a></h2><p>本篇为系列文章的最后一部分,主要介绍了CI上面的Performance如何检测系统帧率变化.</p><p>Yelp通过<a href="https://developer.android.com/reference/android/view/FrameMetrics.html" target="_blank" rel="noopener">FrameMetrics API</a>来获取帧率信息,低于16ms就是快帧,高于就是慢帧,他们会对装有信息的JSON进行分析,其中dopped frame会列出各个部分所消耗的时间.</p><p>最后又总结了整个性能提升过程中所采取的措施,除去这节的Performance Monitoring来防止Regression导致的问题,还包括之前的减少主线程工作,异步inflating layout,对搜索结果view model的caching等.</p><h2 id="Android-Things-client-library-for-Google-Cloud-IoT-Core"><a href="#Android-Things-client-library-for-Google-Cloud-IoT-Core" class="headerlink" title="Android Things client library for Google Cloud IoT Core "></a><a href="https://android-developers.googleblog.com/2018/06/android-things-client-library-for.html?linkId=53347194" target="_blank" rel="noopener">Android Things client library for Google Cloud IoT Core </a></h2><p>为广大IoT爱好者带来福音,client library提供了硬件设备轻松连接google Cloud IoT Core,通过几行代码,便可以轻松的上传传感器信息到云端进行控制.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.google.android.things:cloud-iot-core:1.0.0&apos;</span><br></pre></td></tr></table></figure><p>由于硬件设备所在的环境多变,library还提供了很多错误处理机制,数据信息缓存等.</p><h2 id="How-to-Migrate-from-Android-Job-to-WorkManager"><a href="#How-to-Migrate-from-Android-Job-to-WorkManager" class="headerlink" title="How to Migrate from Android-Job to WorkManager "></a><a href="https://articles.caster.io/android/how-to-migrate-from-android-job-to-workmanager/" target="_blank" rel="noopener">How to Migrate from Android-Job to WorkManager </a></h2><p>作者以前用的是Evernote搞的AndroidJob,本篇介绍了他如何迁移到google最新的WorkManager上面.</p><p>基本使用方法跟AndroidJob类似,Woker通过<code>OneTimeWorkRequestBuilder</code>去build单发事件,通过<code>PeriodicWorkRequestBuilder</code>去build周期性事件,通过<code>setInputData</code>可以添加一些数据,通过<code>setConstraints</code>添加约束,如网络要求等,通过<code>WorkManager.getInstance().enqueue</code>讲Work加入队列.</p><p>Work触发时会执行<code>doWork</code>方法, 返回值<code>Worker.Result.SUCCESS</code>表示成功,类对象<code>inputData</code>可以获取传进来的数据.</p><h2 id="What’s-Next-for-Mobile-at-Airbnb"><a href="#What’s-Next-for-Mobile-at-Airbnb" class="headerlink" title="What’s Next for Mobile at Airbnb "></a><a href="https://medium.com/airbnb-engineering/whats-next-for-mobile-at-airbnb-5e71618576ab" target="_blank" rel="noopener">What’s Next for Mobile at Airbnb </a></h2><p>作者介绍了在Airbnb放弃RN之后下一步要走的路线.</p><ul><li>通过<a href="https://airbnb.design/building-a-visual-language/" target="_blank" rel="noopener">DSL</a>定义跨平台统一的设计语言,实现<code>Server-Driven Rendering</code>,通过自己开发的基于Sketch的设计软件<a href="https://github.com/airbnb/Lona/" target="_blank" rel="noopener">Lona</a>做到一套设计生成不同平台的代码.当然这一切都是在Build的时候做的.</li><li>基于之前的<a href="https://github.com/airbnb/epoxy" target="_blank" rel="noopener">Epoxy</a>,推出新的<code>MvRx</code>,并且支持Android与iOS,Android上是对RecyclerView的封装,可以更方便的实现复杂List的渲染.</li><li>通过<a href="https://developer.android.com/studio/build/build-variants#product-flavors" target="_blank" rel="noopener">gradle product flavors</a>来实现编译速度的提升,只去下载自己关心的Module.</li></ul><h2 id="SQLite-on-Kotlin-Native"><a href="#SQLite-on-Kotlin-Native" class="headerlink" title="SQLite on Kotlin/Native "></a><a href="https://medium.com/@kpgalligan/sqlite-on-kotlin-native-9bcf47854cae" target="_blank" rel="noopener">SQLite on Kotlin/Native </a></h2><p><a href="https://github.com/touchlab/knarch.db/tree/96bb6a2e370bd90d2b42d46b23ba1b2e74b0d4ff" target="_blank" rel="noopener">Knarch</a>, Kotlin跨平台数据库的一个非常早起的版本.很多地方还不成熟,尤其是对Android的支持,如何架构还在讨论总,在使用过程中,多线程也是个问题.</p><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="SaveState"><a href="#SaveState" class="headerlink" title="SaveState "></a><a href="https://github.com/PrototypeZ/SaveState" target="_blank" rel="noopener">SaveState </a></h2><p>保存状态的一个库,相较于Icepick支持Kotlin.</p><h2 id="morph-bottom-navigation"><a href="#morph-bottom-navigation" class="headerlink" title="morph-bottom-navigation "></a><a href="https://github.com/tommybuonomo/morph-bottom-navigation" target="_blank" rel="noopener">morph-bottom-navigation </a></h2><p>基于Bottom Navigation的一个库,有比较好看的动画效果.</p><h2 id="gradle-maven-publish-plugin"><a href="#gradle-maven-publish-plugin" class="headerlink" title="gradle-maven-publish-plugin "></a><a href="https://github.com/vanniktech/gradle-maven-publish-plugin" target="_blank" rel="noopener">gradle-maven-publish-plugin </a></h2><p>支持kotlin的maven发布插件.</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="Priority Bucket" scheme="http://talentprince.github.io/tags/Priority-Bucket/"/>
    
      <category term="Cloud IoT Core" scheme="http://talentprince.github.io/tags/Cloud-IoT-Core/"/>
    
      <category term="ML Kit" scheme="http://talentprince.github.io/tags/ML-Kit/"/>
    
      <category term="WorkManager" scheme="http://talentprince.github.io/tags/WorkManager/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #310</title>
    <link href="http://talentprince.github.io/2018/06/13/Android-Weekly-Issue-310/"/>
    <id>http://talentprince.github.io/2018/06/13/Android-Weekly-Issue-310/</id>
    <published>2018-06-13T01:00:01.000Z</published>
    <updated>2020-06-22T09:44:59.474Z</updated>
    
    <content type="html"><![CDATA[<p>May 20th, 2018</p><h2 id="Android-Weekly-Issue-290"><a href="#Android-Weekly-Issue-290" class="headerlink" title="Android Weekly Issue #290"></a><a href="http://androidweekly.net/issues/issue-310" target="_blank" rel="noopener">Android Weekly Issue #290</a></h2><p>本期既有本次Google IO对于Play Console的更新简介, 又有数篇对于简化UI Test的工具与方法的介绍,还有JetPack Worker Manager的推介,以及如何仅仅通过Firebase快速搭建一个自己的Instgram小App,当然还有一篇关于Google最新的Navigation Architecture Component的介绍,精彩内容不容错过.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="Rxify-The-startWith-MVI-pitfall"><a href="#Rxify-The-startWith-MVI-pitfall" class="headerlink" title="Rxify : The startWith { MVI } pitfall "></a><a href="https://medium.com/@ragdroid/rxify-the-startwith-mvi-pitfall-68764ae8946d" target="_blank" rel="noopener">Rxify : The startWith { MVI } pitfall </a></h2><p>在实现MVI返回State Intent的时候, 可以通过startWith可以添加一些初始化状态,它就类似于concat,将一个新的Observable与之结合,再通过onErrorReturn返回一个错误的状态,保证我们的chain的完备性.</p><h2 id="Discover-everything-new-in-the-Google-Play-Console"><a href="#Discover-everything-new-in-the-Google-Play-Console" class="headerlink" title="Discover everything new in the Google Play Console "></a><a href="https://android-developers.googleblog.com/2018/05/io-2018-everything-new-in-google-play.html" target="_blank" rel="noopener">Discover everything new in the Google Play Console </a></h2><p>最新的GoogleIO更新了Play Console的新功能,有一些还是挺厉害的.</p><ul><li>App Bundle, 就是你的res可以根据设备加载,比如图片资源,对于xxxdpi的设备就下载一份,语言包也类似.</li><li>提升了质量检测过程, 通过100个内部测试机运行你upload的程序,还有各种report与analysis帮助你分析潜在问题.</li><li>dashboard以及一些数据呈现更加优化,还可以通过acquisition report获得更多信息,如用户从哪里得到的你的app等等.</li><li>提升用户订阅服务,通过Billing Library可以轻松实现订阅服务,在Subscriptions Center可以轻松管理用户的订阅订单,还有详细的report帮你分析多种订阅之间的时间,地点等等因素的关系.</li><li>八月份之前必须得Target到26了.</li></ul><h2 id="Kakao-how-to-make-UI-testing-great-again"><a href="#Kakao-how-to-make-UI-testing-great-again" class="headerlink" title="Kakao - how to make UI testing great again "></a><a href="https://medium.com/@ilyalim/kakao-how-to-make-ui-testing-great-again-19972cf13740" target="_blank" rel="noopener">Kakao - how to make UI testing great again </a></h2><p>Kakao是一个kotlin的UI测试框架,基于Espresso,可以大幅度简化使用Espresso的过程,通过Lambda以及Kakao内置的一些操作符,完成测试.</p><p>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> screen &#123;</span><br><span class="line">      content &#123; isVisible() &#125;</span><br><span class="line"></span><br><span class="line">      textViewSmall &#123;</span><br><span class="line">          isVisible()</span><br><span class="line">          hasAnyText()</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Best-Practices-for-Unit-Testing-in-Kotlin"><a href="#Best-Practices-for-Unit-Testing-in-Kotlin" class="headerlink" title="Best Practices for Unit Testing in Kotlin "></a><a href="https://blog.philipphauer.de/best-practices-unit-testing-kotlin/" target="_blank" rel="noopener">Best Practices for Unit Testing in Kotlin </a></h2><p>作者提了好几条建议来提升Kotlin测试的体验</p><ul><li>使用JUnit5的<code>@TestInstance(Lifecycle.PER_CLASS)</code>来避免出现一些静态field,这些静态field主要是为了保证在整个测试类中只初始化一次,而JUnit4每一个Test都会重新创建新的Class.取而代之的是可以使用<code>init{}</code>加<code>@BeforeEach</code>.</li><li>使用JUnit5的<code>@Nested</code>包装测试类中一些特殊的模块,使之更加清晰.</li><li>使用<code></code>(backticks)去自定义方法名.</li><li><a href="http://joel-costigliola.github.io/assertj/" target="_blank" rel="noopener">AssertJ</a>依旧好使.</li><li>使用<a href="https://github.com/nhaarman/mockito-kotlin" target="_blank" rel="noopener">Mokito-Kotlin</a>跟<a href="http://mockk.io/" target="_blank" rel="noopener">MockK</a>来做mock</li></ul><h2 id="Exploring-Moshi’s-Kotlin-Code-Gen"><a href="#Exploring-Moshi’s-Kotlin-Code-Gen" class="headerlink" title="Exploring Moshi’s Kotlin Code Gen "></a><a href="https://medium.com/@sweers/exploring-moshis-kotlin-code-gen-dec09d72de5e" target="_blank" rel="noopener">Exploring Moshi’s Kotlin Code Gen </a></h2><p>Moshi是一个JSON解析库,文章介绍了1.6版本使用了新的Kotlin代码生成器,更好的处理了类似<code>Mutablility</code>,<code>Nullability</code>,<code>in/out</code>等等的问题,感兴趣可以自己看一下.</p><h2 id="Life-with-without-services-and-WorkManager"><a href="#Life-with-without-services-and-WorkManager" class="headerlink" title="Life with/without services and WorkManager "></a><a href="https://medium.com/google-developer-experts/services-the-life-with-without-and-worker-6933111d62a6" target="_blank" rel="noopener">Life with/without services and WorkManager </a></h2><p>随着Android对于内存管理的越来越严格,首先是26以上Service无法在后台<code>startService</code>被限制,而系统提供的<code>JobScheduler</code>在23以下有问题,而<code>JobDispatcher</code>又需要Google Service…让人甚是苦恼.</p><p>值得高兴的是,Google最近推出的强大的JetPack里面的<code>WorkerManager</code>将解决这个问题.</p><p>它内部融合了<code>JobScheduer</code>,<code>JobDispather</code>,<code>AlarmManager</code>等等,并提供了两种Woker,<code>OneTime</code>跟<code>Periodic</code>.让后台操作变得非常轻松.</p><h2 id="A-year-as-Android-Engineer"><a href="#A-year-as-Android-Engineer" class="headerlink" title="A year as Android Engineer "></a><a href="https://proandroiddev.com/a-year-as-android-engineer-55e2a428dfc8" target="_blank" rel="noopener">A year as Android Engineer </a></h2><p>文章介绍了作者从一个QA转型为一个Android Dev,并找到新工作的经历,可以当故事看看…</p><h2 id="The-missing-migration-guide-to-the-Gradle-Kotlin-DSL"><a href="#The-missing-migration-guide-to-the-Gradle-Kotlin-DSL" class="headerlink" title="The missing migration guide to the Gradle Kotlin DSL "></a><a href="https://github.com/jnizet/gradle-kotlin-dsl-migration-guide" target="_blank" rel="noopener">The missing migration guide to the Gradle Kotlin DSL </a></h2><p>一个REAMME,介绍了如何从Gradle迁移到Kotlin DSL,喜欢Kotlin的朋友们可以对照着迁移了,一步两步.</p><h2 id="Build-an-Instagram-Like-Android-App-Using-Google-Firebase"><a href="#Build-an-Instagram-Like-Android-App-Using-Google-Firebase" class="headerlink" title="Build an Instagram-Like Android App Using Google Firebase "></a><a href="https://dragosholban.com/2018/05/13/build-an-instagram-like-android-app-using-google-firebase/" target="_blank" rel="noopener">Build an Instagram-Like Android App Using Google Firebase </a></h2><p>通过Firebase搭建一个类似Instgram的App.</p><p>通过Firebase Authenicate来实现登录认证,通过Firebase Storage来实现图片上传,通过Firebase Database来实现数据存储.</p><p>自己只需要实现简单的UI,便可以完成简易化的Ins,是不是很开森.</p><h2 id="A-problem-like-Navigation"><a href="#A-problem-like-Navigation" class="headerlink" title="A problem like Navigation "></a><a href="https://medium.com/a-problem-like-maria/a-problem-like-navigation-e9821625a70e" target="_blank" rel="noopener">A problem like Navigation </a></h2><p>介绍了Google最新推出的Navigation Archtecture Component,来处理Fragment之间的跳转,通过定义xml中的<code>action</code>,就可以完成跳转,通过定义<code>argument</code>就可以完成值传递,以及定义<code>deepLink</code>,可以轻松支持Deeplink.</p><h2 id="Pleasant-fun-painless-delightful-Espresso-testing-with-Kotlin"><a href="#Pleasant-fun-painless-delightful-Espresso-testing-with-Kotlin" class="headerlink" title="Pleasant fun painless delightful Espresso testing with Kotlin "></a><a href="https://medium.com/@Zhuinden/pleasant-fun-painless-delightful-espresso-testing-with-kotlin-3ffeda58d45c" target="_blank" rel="noopener">Pleasant fun painless delightful Espresso testing with Kotlin </a></h2><p>一个基于Kakao(Kotlin DSL for Espresso)的Kotlin Espresso库,用于简化UI test的书写.</p><p>如可以直接通过Id来索引View直接perform操作,而不必在通过<code>onView</code>…<code>withId</code>…<code>perform</code>来搞的很长.</p><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="MockK"><a href="#MockK" class="headerlink" title="MockK "></a><a href="http://mockk.io/ANDROID" target="_blank" rel="noopener">MockK </a></h2><p>kotlin的Mock lib</p><h2 id="espresso-helper"><a href="#espresso-helper" class="headerlink" title="espresso-helper "></a><a href="https://github.com/Zhuinden/espresso-helper" target="_blank" rel="noopener">espresso-helper </a></h2><p>Espresso的Kotlin封装</p><h2 id="Kakao"><a href="#Kakao" class="headerlink" title="Kakao "></a><a href="https://github.com/agoda-com/Kakao" target="_blank" rel="noopener">Kakao </a></h2><p>上面那个库基于的,也是对于Espresso的封装.</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="Google IO" scheme="http://talentprince.github.io/tags/Google-IO/"/>
    
      <category term="Kotlin Espresso" scheme="http://talentprince.github.io/tags/Kotlin-Espresso/"/>
    
      <category term="Navigation Architecture Component" scheme="http://talentprince.github.io/tags/Navigation-Architecture-Component/"/>
    
  </entry>
  
  <entry>
    <title>如何从RxJava升级到RxJava2</title>
    <link href="http://talentprince.github.io/2018/04/02/From-RxJava-to-RxJava2/"/>
    <id>http://talentprince.github.io/2018/04/02/From-RxJava-to-RxJava2/</id>
    <published>2018-04-02T02:29:31.000Z</published>
    <updated>2020-06-22T09:44:59.477Z</updated>
    
    <content type="html"><![CDATA[<p>RxJava2已经推出有一年半的时间,由于之前RxJava已经在现有项目中广泛使用,而RxJava2在除了很多命名外并没有太多革新,所以相信有很多人跟我一样都还没有升级.</p><p>随着老版本渐渐的失去维护,更重要的是有一定时间允许我来做这个迁移,其实弃老从新一直都是程序员的喜好.</p><p>虽然官方提供了<a href="https://github.com/ReactiveX/RxJava/wiki/What&#39;s-different-in-2.0" target="_blank" rel="noopener">文档</a>详尽的介绍了区别,但是文章之长,可能很多人读不下去,却有想快速的迁移过来,我将除了命名改变之外有用的地方总结成了几点,供大家参考.</p><a id="more"></a><h2 id="不能再发射Null了"><a href="#不能再发射Null了" class="headerlink" title="不能再发射Null了"></a>不能再发射Null了</h2><p>RxJava2的最大改变就是不能再流里发射Null了,有人会问发射了就怎么了,答案是你的流会因为<code>NPE</code>断开.</p><p>比如以前我们会写出这样的代码(详见RxPermission):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(null).compose....</span><br></pre></td></tr></table></figure><p>在RxJava二中我们需要将它改为(详见RxPermission2):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TRIGGER = new Object()</span><br><span class="line">Observer.just(TRIGGER).compose(xxx)</span><br></pre></td></tr></table></figure><p>还有我们常常完成某个工作而不需要返回值,或者根本不关心返回值,将返回的Observable定义为Observable<void>, 如:</void></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xxx.flatMap &#123;</span><br><span class="line">   ....</span><br><span class="line">   return null;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在不能这么写了,对于不需要返回值的,我们应该使用Completable,当然这个在RxJava的时候也已经存在了.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.flatMapCompletable &#123; Completable.fromAction&#123; &#125; &#125;</span><br></pre></td></tr></table></figure><p>还有我们在实现Local Cache与Remote Cache的时候常用的办法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localObservable = just(localReference);</span><br><span class="line"></span><br><span class="line">concat(localObservable, remoteObservable).filter&#123; i != null &#125;.first()...</span><br></pre></td></tr></table></figure><p>会因为在没有Local Cache的时候出错,所以应该改成:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localObservable = just(Optional.fromNullable(localReference));</span><br><span class="line"></span><br><span class="line">concat(localObservable, remoteObservable).filter&#123; i.isPresent() &#125;.firstElement()/.first(defaultValue)...</span><br></pre></td></tr></table></figure><h2 id="flatMap方法多了"><a href="#flatMap方法多了" class="headerlink" title="flatMap方法多了"></a>flatMap方法多了</h2><p>在上面的介绍中可能已经发现了,老版本只有同类型的flatMap,即Observable <-> Observable, Single <-> Single, 而RxJava2除了同类型的flatMap,还增添了flatMapCompletable,flatMapSingle,flatMapObservable帮助你任意切换.</-></-></p><h2 id="订阅与反订阅"><a href="#订阅与反订阅" class="headerlink" title="订阅与反订阅"></a>订阅与反订阅</h2><p>我们有时候需要在必要的时刻手动的将订阅取消,而防止产生我们不想要的问题,如在跳出定位页面时取消订阅,防止位置信息后面回来造成程序崩溃.</p><p>而在RxJava中,我们一般是这么做的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Subscription subscription = xxxx.subscribe(xxxSubscriber);</span><br><span class="line"></span><br><span class="line">subscription.unsubscribe();</span><br></pre></td></tr></table></figure><p>在RxJava2中,这个发生了变化,因为你会发现<code>subscribe</code>方法基本上都返回void的,如果你需要手动取消的话,需要使用<code>T subscribeWith(T extends Disposal)</code>方法.</p><p>其实我们可以看到,新版的<code>Subscriber</code>或者<code>Observer</code>都多了一个方法<code>void onSubscribe(Subscription s)</code>或者<code>void onSubscribe(Disposable d)</code>, 也就是说以前的<code>Subscription</code>是通过订阅后通过回调返回了.</p><p>这里RxJava2统一接口到<code>Disposable</code>,提供<code>dispose</code>方法进行反订阅,并且还提供了<code>DisposableObservable</code>,<code>DisposableSingle</code>,<code>DisposableCompletable</code>已经帮我们处理了回调返回的Disposable对象.</p><p>所以需要做的改动不大:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Disposable disposable = xxx.subscribeWith(xxxDisposableObserver);</span><br><span class="line"></span><br><span class="line">disposable.dispose();</span><br></pre></td></tr></table></figure><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>错误处理最棒的一点是之前必须实现onError来handle错误,如果不实现,就会抛出<code>OnErrorNotImplement</code>,导致程序崩溃,根据最新的Doc,在RxJava2中,可以轻松Handle未处理的错误.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RxJavaPlugins.setErrorHandler(xxx);</span><br></pre></td></tr></table></figure><p>还有一点变化需要注意是的是,当你有并行任务的时候,如果一个线程出错,将会导致整个流中断,其他线程可能会抛出<code>IOInterupedException</code>并且onError无法Handle,这时候必须有上面讲到的ErrorHandler来处理这一类<code>UnDeliveriedException</code>,否则程序会Crash.</p><h2 id="Flowable"><a href="#Flowable" class="headerlink" title="Flowable"></a>Flowable</h2><p>RxJava2将处理背压(BackPressure)的部分抽出来弄了一个新的对象,叫做<code>Flowable</code>.</p><p>以前我们处理背压可能直接通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.onBackpressureXXXStrategy()...</span><br></pre></td></tr></table></figure><p>就可以了.</p><p>现在我们得通过Flowable来处理.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.toFlowable(XXXStrategy)...</span><br></pre></td></tr></table></figure><p>当然Flowable还提供比较强大的新方法,来处理并发.</p><p>比如之前我们需要实现并发,得通过flatMap来实现.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.from(urls).flatMap &#123; </span><br><span class="line">       v -&gt; Observable.just(v).subscribeOn(io()).....</span><br><span class="line">&#125;.subscribe(...)</span><br></pre></td></tr></table></figure><p>使用Flowable,可以简化为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flowable.fromIterable(listingIds)</span><br><span class="line">    .parallel().runOn(io())</span><br><span class="line">    .map &#123; v -&gt; xxx &#125;</span><br><span class="line">    .sequential()</span><br></pre></td></tr></table></figure><p>看起来是不是有点炫酷…</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>对于RxJava2,任何一个Observable都可以转化为一个<code>TestObservable</code>, 通过<code>...test()</code>来进行转换.</p><p>而TestObservable提供很多与测试相关的方法,就不用我们亲自去判断.</p><p>如<code>assertResult</code>,<code>assertError</code>,<code>assertSubscribed</code>.</p><h2 id="其他改动"><a href="#其他改动" class="headerlink" title="其他改动"></a>其他改动</h2><p>关于名字的变化,这里都不一一论述,包含<code>Func1</code> -&gt; <code>Function</code>, <code>Action</code> -&gt; <code>Consumer</code>, <code>Observable.Transformer</code> -&gt; <code>ObservableTransformer</code>等等. </p>]]></content>
    
    <summary type="html">
    
      RxJava 升级 RxJava2
    
    </summary>
    
      <category term="Android" scheme="http://talentprince.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://talentprince.github.io/tags/Android/"/>
    
      <category term="RxJava" scheme="http://talentprince.github.io/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #290</title>
    <link href="http://talentprince.github.io/2018/04/01/Android-Weekly-Issue-290/"/>
    <id>http://talentprince.github.io/2018/04/01/Android-Weekly-Issue-290/</id>
    <published>2018-04-01T02:37:28.000Z</published>
    <updated>2020-06-22T09:44:59.473Z</updated>
    
    <content type="html"><![CDATA[<p>December 31st, 2017</p><h2 id="Android-Weekly-Issue-290"><a href="#Android-Weekly-Issue-290" class="headerlink" title="Android Weekly Issue #290"></a><a href="http://androidweekly.net/issues/issue-290" target="_blank" rel="noopener">Android Weekly Issue #290</a></h2><p>本期内容包括介绍Kotlin逆变协变的一篇(虽然没说清楚,但我补充了),IoT相关制作MIDI Controler的Part two,以及比较炫酷的Shared Element Reveal动画,以及LiveData与DataBinding相关,Kotlin扩展Fragment/Activity方法做测试,Rx逐条打Log等等.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="Lessons-learned-implementing-Redux-on-Android"><a href="#Lessons-learned-implementing-Redux-on-Android" class="headerlink" title="Lessons learned implementing Redux on Android "></a><a href="https://blog.pusher.com/lessons-learned-implementing-redux-on-android/" target="_blank" rel="noopener">Lessons learned implementing Redux on Android </a></h2><p>文章介绍了模仿Web的Redux,实现其kotlin版本,实现<code>Reducer</code>,通过<code>State</code>与<code>Action</code>来驱动状态的转换.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">State -&gt; UI -&gt; Action -&gt; Reducer -&gt; Store.</span><br></pre></td></tr></table></figure><h2 id="In-and-out-type-variant-of-Kotlin"><a href="#In-and-out-type-variant-of-Kotlin" class="headerlink" title="In and out type variant of Kotlin "></a><a href="https://android.jlelse.eu/in-and-out-type-variant-of-kotlin-587e4fa2944c" target="_blank" rel="noopener">In and out type variant of Kotlin </a></h2><p>文章介绍了Kotlin中泛型添加<code>in</code>与<code>out</code>的意义.</p><p>实际上<code>in</code>作为参数表示的是consume方,可以将super type可以赋值给sub type.类似于Java里面的<code>&lt;? super X&gt;</code>,其作为泛型的Collection只能add数据,无法get访问内部成员.</p><p>而<code>out</code>作为返回值表示producer,与in相反,它可以将sub type赋值给super type.类似于Java中的&lt;? extends X&gt;,其作为反省的Collection<out t>只能get访问,不能add数据.</out></p><h2 id="Building-a-distributed-MIDI-Controller-with-Android-Things-and-Nearby-API-2"><a href="#Building-a-distributed-MIDI-Controller-with-Android-Things-and-Nearby-API-2" class="headerlink" title="Building a distributed MIDI Controller with Android Things and Nearby API #2 "></a><a href="https://proandroiddev.com/building-a-distributed-midi-controller-with-android-things-and-nearby-api-2-b4b0531d645e" target="_blank" rel="noopener">Building a distributed MIDI Controller with Android Things and Nearby API #2 </a></h2><p>IoT的MIDI播放器第二篇,感兴趣的可以仔细看.</p><h2 id="Meaningful-Motion-Circular-Reveal-amp-Shared-Elements"><a href="#Meaningful-Motion-Circular-Reveal-amp-Shared-Elements" class="headerlink" title="Meaningful Motion: Circular Reveal &amp; Shared Elements "></a><a href="https://medium.com/@jossiwolf/meaningful-motion-circular-reveal-shared-elements-ea495b99adf4" target="_blank" rel="noopener">Meaningful Motion: Circular Reveal &amp; Shared Elements </a></h2><p>在Shared Element Transaction Animation的基础上加上了<code>ViewAnimationUtils#createCircularReveal</code>实现Reveal效果. 即Activity/Fragment跳转过程中Shared Element先移动再充满Container.</p><h2 id="RxAndroid-Handle-Interrupt-With-“switchMap”"><a href="#RxAndroid-Handle-Interrupt-With-“switchMap”" class="headerlink" title="RxAndroid: Handle Interrupt With “switchMap” "></a><a href="https://tech.pic-collage.com/rxandroid-handle-interrupt-with-switchmap-3a650393299f" target="_blank" rel="noopener">RxAndroid: Handle Interrupt With “switchMap” </a></h2><p>通过switchMap将Happy与Unhappy的pass都加进来(Observer.merge)进行处理,switchMap与flatMap的区别是它内部只有一个active的observer,简单的来说,它不会对转换后的Observable进行merge,而是在新的来到的时候cancel之前的.</p><h2 id="The-curious-case-of-haunting-fragments"><a href="#The-curious-case-of-haunting-fragments" class="headerlink" title="The curious case of haunting fragments "></a><a href="https://jeroenmols.com/blog/2017/12/18/fragmentback/" target="_blank" rel="noopener">The curious case of haunting fragments </a></h2><p>作者研究Fragment addToBackStack以及pop之间的事情,但是作者貌似没用对…</p><p>所以之后他居然推荐用Activity了,说Fragment太难用…</p><h2 id="Unit-testing-protected-lifecycle-methods-with-Kotlin"><a href="#Unit-testing-protected-lifecycle-methods-with-Kotlin" class="headerlink" title="Unit testing protected lifecycle methods with Kotlin "></a><a href="https://medium.com/@dpreussler/unit-testing-activity-lifecycle-4e740f71e68a" target="_blank" rel="noopener">Unit testing protected lifecycle methods with Kotlin </a></h2><p>作者写了个工具库,给Activity的生命周期方法都写了扩展,这样就可以直接通过对象调用了…可以用来写Activity的单元测试.</p><h2 id="Kotlin-Coding-Conventions"><a href="#Kotlin-Coding-Conventions" class="headerlink" title="Kotlin Coding Conventions "></a><a href="http://kotlinlang.org/docs/reference/coding-conventions.html" target="_blank" rel="noopener">Kotlin Coding Conventions </a></h2><p>Kotlin最新的code style,基本跟Java类似,但这里比较详细,包括什么时候换行,什么时候single line等等.</p><h2 id="Lessons-from-my-first-multi-platform-Kotlin-project"><a href="#Lessons-from-my-first-multi-platform-Kotlin-project" class="headerlink" title="Lessons from my first multi-platform Kotlin project "></a><a href="https://blog.kotlin-academy.com/lessons-from-my-first-multiplatform-kotlin-project-d4e311f15874" target="_blank" rel="noopener">Lessons from my first multi-platform Kotlin project </a></h2><p>作者对Kotlin Multiple Platform进行总结,首先platform层应该根据js/jvm/native进行划分,而不是操作系统,操作系统的划分应该属于之下的regular层,而最上层为common层.</p><p>MVP的应用非常重要,其次是下层可以访问上层的一切,上层需要访问下层应该通过expected与actual来实现.</p><h2 id="Android-Architecture-Components-LiveData-with-Data-Binding"><a href="#Android-Architecture-Components-LiveData-with-Data-Binding" class="headerlink" title="Android Architecture Components LiveData with Data Binding "></a><a href="https://android.jlelse.eu/android-architecture-components-livedata-with-data-binding-7bf85871bbd8" target="_blank" rel="noopener">Android Architecture Components LiveData with Data Binding </a></h2><p>Google最新的Databinding已经支持LiveData了,通过与LiveData进行绑定,可以保证UI在后台的时候不会因为数据变化而刷新,避免了没有必要的操作.</p><h2 id="Briefly-about-RxJava-Logging"><a href="#Briefly-about-RxJava-Logging" class="headerlink" title="Briefly about RxJava Logging "></a><a href="https://proandroiddev.com/briefly-about-rxjava-logging-20308b013e6d" target="_blank" rel="noopener">Briefly about RxJava Logging </a></h2><p>作者介绍了通过<code>doOnEach</code> (Flowable)以及<code>doOnEvent</code>(others)来了解Observable的状态,帮助你添加新的feature中debug遇到的问题,不至于整个Rx Chains出现问题而不知道问题处在哪里.</p><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="TableView"><a href="#TableView" class="headerlink" title="TableView "></a><a href="https://github.com/evrencoskun/TableView" target="_blank" rel="noopener">TableView </a></h2><p>很项强大TableView,基于RecyclerView,用来显示复杂数据.有点类似数据库表格.</p><h2 id="retrofit2-kotlin-coroutines-adapter"><a href="#retrofit2-kotlin-coroutines-adapter" class="headerlink" title="retrofit2-kotlin-coroutines-adapter "></a><a href="https://github.com/JakeWharton/retrofit2-kotlin-coroutines-adapter" target="_blank" rel="noopener">retrofit2-kotlin-coroutines-adapter </a></h2><p>Jake Warthon写的支持Kotlin Coroutine的Retrofit2, 返回<code>Deferred</code>类型.</p><h2 id="RxTest"><a href="#RxTest" class="headerlink" title="RxTest "></a><a href="https://github.com/RubyLichtenstein/RxTest" target="_blank" rel="noopener">RxTest </a></h2><p>像这个来测Rx的Observable,是不是很牛.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(&quot;Hello RxTest!&quot;)</span><br><span class="line">    .test &#123;</span><br><span class="line">        it shouldEmit &quot;Hello RxTest!&quot;</span><br><span class="line">        it should complete()</span><br><span class="line">        it shouldHave noErrors()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="MockK"><a href="#MockK" class="headerlink" title="MockK "></a><a href="http://mockk.io/" target="_blank" rel="noopener">MockK </a></h2><p>支持Koltin DSL的mock库, 叫mockk….</p><h2 id="KotlinAndroidViewBindings"><a href="#KotlinAndroidViewBindings" class="headerlink" title="KotlinAndroidViewBindings "></a><a href="https://github.com/MarcinMoskala/KotlinAndroidViewBindings" target="_blank" rel="noopener">KotlinAndroidViewBindings </a></h2><p>其实感觉跟ViewBinding没多大关系, 主要是实现了Delegate,可以取代<code>findViewById</code>,<code>Butterknife</code>以及<code>Kotlin Android Extension</code>.</p><p>直接通过<code>by bindWithXX()</code>来找到View.</p><h2 id="litho-kotlin"><a href="#litho-kotlin" class="headerlink" title="litho-kotlin "></a><a href="https://github.com/vinc3m1/litho-kotlin" target="_blank" rel="noopener">litho-kotlin </a></h2><p>Facebook litho的kotlin dsl support.</p><h2 id="kotlin-math"><a href="#kotlin-math" class="headerlink" title="kotlin-math "></a><a href="https://github.com/romainguy/kotlin-math" target="_blank" rel="noopener">kotlin-math </a></h2><p>支持很多vector计算的lib,帮助简化graphic math.</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Android" scheme="http://talentprince.github.io/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://talentprince.github.io/tags/Kotlin/"/>
    
      <category term="IoT" scheme="http://talentprince.github.io/tags/IoT/"/>
    
      <category term="Animation" scheme="http://talentprince.github.io/tags/Animation/"/>
    
      <category term="LiveData" scheme="http://talentprince.github.io/tags/LiveData/"/>
    
      <category term="DataBinding" scheme="http://talentprince.github.io/tags/DataBinding/"/>
    
      <category term="RxLog" scheme="http://talentprince.github.io/tags/RxLog/"/>
    
  </entry>
  
  <entry>
    <title>Android Weekly Issue #289</title>
    <link href="http://talentprince.github.io/2017/12/31/Android-Weekly-Issue-289/"/>
    <id>http://talentprince.github.io/2017/12/31/Android-Weekly-Issue-289/</id>
    <published>2017-12-31T03:36:24.000Z</published>
    <updated>2020-06-22T09:44:59.473Z</updated>
    
    <content type="html"><![CDATA[<p>December 24th, 2017</p><h2 id="Android-Weekly-Issue-289"><a href="#Android-Weekly-Issue-289" class="headerlink" title="Android Weekly Issue #289"></a><a href="http://androidweekly.net/issues/issue-289" target="_blank" rel="noopener">Android Weekly Issue #289</a></h2><p>今年最后一篇, 包含了可以上传log记录的HyperLog,以及Android的面试技巧,还有Model的分层,以及如何迁移到Room.<br>还有比较炫酷的一个Path动画的实现方法值得去看.剩下的多是一些入门介绍,如kotlin,firebase messaging,contraintset animation等.</p><a id="more"></a><h2 id="ARTICLES-amp-TUTORIALS"><a href="#ARTICLES-amp-TUTORIALS" class="headerlink" title="ARTICLES &amp; TUTORIALS"></a>ARTICLES &amp; TUTORIALS</h2><h2 id="HyperLog-Android-Remote-Logger-Library-for-Debugging"><a href="#HyperLog-Android-Remote-Logger-Library-for-Debugging" class="headerlink" title="HyperLog: Android Remote Logger Library for Debugging "></a><a href="https://android.jlelse.eu/android-remote-logger-library-for-debugging-343443bd38b7" target="_blank" rel="noopener">HyperLog: Android Remote Logger Library for Debugging </a></h2><p>作者讲了很多人苦恼有时候插线数据线Logcat给清掉了,也看不到日志信息,而Timber活着Logger也没法支持Production环境,推荐了<code>HyperLog</code>,可以上传日志文件到远端服务器,可以设定一些schedular定时上传.</p><h2 id="Bring-life-to-your-custom-view"><a href="#Bring-life-to-your-custom-view" class="headerlink" title="Bring life to your custom view "></a><a href="https://medium.com/@romandanylyk96/android-bring-life-to-your-custom-view-8604ab3967b3" target="_blank" rel="noopener">Bring life to your custom view </a></h2><p>文章介绍了通过动画来绘制一个自定义View,原理是通用的,就是首先分析你的图形构成的元素,需要哪些变量的变化,然后通过<code>ValueAnimator</code>控制这些变量的变化,再通过<code>invalidate</code>触发onDraw依照变量的值进行绘制.</p><h2 id="Interviewing-Tips-for-Android-Engineers"><a href="#Interviewing-Tips-for-Android-Engineers" class="headerlink" title="Interviewing Tips for Android Engineers "></a><a href="https://eng.lyft.com/interviewing-tips-for-android-engineers-f01ce7fba163" target="_blank" rel="noopener">Interviewing Tips for Android Engineers </a></h2><p>作者作为Lyfy的一员,作者很高兴的分享自己的一些新的帮助面试者,介绍了Android面试的一些tips,包含从开始的电话初面或者作业,到后来的Java面,Android UI相关技能面,Android Infrastructure面,以及Design与Background的面所应该注意的点以及准备的方法.</p><h2 id="Using-Architecture-Components-with-Firebase-Database-Part-3"><a href="#Using-Architecture-Components-with-Firebase-Database-Part-3" class="headerlink" title="Using Architecture Components with Firebase Database - Part 3 "></a><a href="https://firebase.googleblog.com/2017/12/using-android-architecture-components_22.html" target="_blank" rel="noopener">Using Architecture Components with Firebase Database - Part 3 </a></h2><p>文章继续之前通过LiveData封装FirebaseDatabase,与ViewModel结合实现MVVM的工作.</p><p>这是第三部分,主要介绍如何优化没有必要的query,Activity有可能因为转屏导致configuration changed,从而引起LiveData瞬间切换到Inactive又变成Active,导致数据库重复的query.</p><p>解决方案是将销毁操作封装到延迟的Runnable里面,发送给Handler,并设置标记位.在onActive中检测标记为,如果发现仍然在pending状态,就<code>removeCallbacks</code>,清楚消息…</p><h2 id="Data-model-mapping-in-Android-Apps"><a href="#Data-model-mapping-in-Android-Apps" class="headerlink" title="Data model mapping in Android Apps "></a><a href="https://overflow.buffer.com/2017/12/21/even-map-though-data-model-mapping-android-apps/" target="_blank" rel="noopener">Data model mapping in Android Apps </a></h2><p>文章一步一步介绍了我们应该如何处理我们的Model,其实是希望我们应该对我们的Model进行分层.</p><p>API与Cache的原始数据,以及与我们核心业务相关的Domain层,再者就是包含UI state等信息的Presentation层了.</p><p>其实就是我们常说的Model-&gt;Domain-&gt;Presentation.</p><p>当然在我们所谓BFF(backends for frontends)理论下(简单来说就是Server为Mobile加一层转换,直接输出显示内容相关数据),可以省去Model与Domain层,但一些UI的state我们仍需想办法维护.</p><h2 id="Incrementally-migrate-from-SQLite-to-Room"><a href="#Incrementally-migrate-from-SQLite-to-Room" class="headerlink" title="Incrementally migrate from SQLite to Room "></a><a href="https://medium.com/google-developers/incrementally-migrate-from-sqlite-to-room-66c2f655b377" target="_blank" rel="noopener">Incrementally migrate from SQLite to Room </a></h2><p>介绍了如何逐步将你的db迁移到room.</p><ul><li>首先根据你的table定义<code>Entity</code>.</li><li>其次实现<code>RoomDatabase</code>,增加版本号并加上空的Migration逻辑.</li><li>使用<code>SupportSQLiteOpenHelper</code>替换原有的SQLiteOpenHelper,如果你之前没有使用raw的sql语句,需要用使用<code>SupportSQLiteQuery</code>拼出query条件.</li><li>写自己的<code>DAO</code>,替换掉Cusor的操作.</li></ul><h2 id="Boost-your-app-reviews-with-Firebase-Predictions"><a href="#Boost-your-app-reviews-with-Firebase-Predictions" class="headerlink" title="Boost your app reviews with Firebase Predictions! "></a><a href="https://medium.com/@Tajchert/boost-your-app-reviews-with-firebase-predictions-19aff4001f27" target="_blank" rel="noopener">Boost your app reviews with Firebase Predictions! </a></h2><p>介绍了利用Firebase正在测试阶段的<code>Predictions</code>帮助我们决定何时弹提醒用户评分的框框.</p><h2 id="Playing-with-Paths"><a href="#Playing-with-Paths" class="headerlink" title="Playing with Paths "></a><a href="https://medium.com/@crafty/playing-with-paths-3fbc679a6f77" target="_blank" rel="noopener">Playing with Paths </a></h2><p>介绍了如何绘制轨迹动画,挺炫酷的,主要使用到了<code>PathDashPathEffect</code>.</p><h2 id="How-to-add-Push-Notification-capability-to-your-Android-app"><a href="#How-to-add-Push-Notification-capability-to-your-Android-app" class="headerlink" title="How to add Push Notification capability to your Android app "></a><a href="https://medium.com/@nileshsingh/how-to-add-push-notification-capability-to-your-android-app-a3cac745e56e" target="_blank" rel="noopener">How to add Push Notification capability to your Android app </a></h2><p>文章介绍了如何通过Firebase Messaging来做推送,包含了详细的Client端的配置,以及Server端的Initialize.</p><h2 id="Animations-with-ConstraintLayout-and-ConstraintSet"><a href="#Animations-with-ConstraintLayout-and-ConstraintSet" class="headerlink" title="Animations with ConstraintLayout and ConstraintSet "></a><a href="https://hellsoft.se/animations-with-constraintlayout-and-constraintset-b4634d38981f" target="_blank" rel="noopener">Animations with ConstraintLayout and ConstraintSet </a></h2><p>文章介绍了通过<code>ConstraintSet</code>对<code>ConstraintLayout</code>添加一些如<code>ChangeBounds</code>的动画.</p><h2 id="Getting-started-with-Kotlin-on-Android"><a href="#Getting-started-with-Kotlin-on-Android" class="headerlink" title="Getting started with Kotlin on Android "></a><a href="https://blog.sourcerer.io/getting-started-with-kotlin-on-android-6242a5f6fd57" target="_blank" rel="noopener">Getting started with Kotlin on Android </a></h2><p>Kotlin简单的入门教程,包含IDE的配置,以及几个Kotlin的特点,如when等等.非常初级,想入门的可以多看看…呵呵…</p><h2 id="LIBRARIES-amp-CODE"><a href="#LIBRARIES-amp-CODE" class="headerlink" title="LIBRARIES &amp; CODE"></a>LIBRARIES &amp; CODE</h2><h2 id="hyperlog-android"><a href="#hyperlog-android" class="headerlink" title="hyperlog-android "></a><a href="https://github.com/hypertrack/hyperlog-android" target="_blank" rel="noopener">hyperlog-android </a></h2><p>可以将log记录发到后台的一个库.</p><h2 id="android-clean-architecture-mvi-boilerplate"><a href="#android-clean-architecture-mvi-boilerplate" class="headerlink" title="android-clean-architecture-mvi-boilerplate "></a><a href="https://github.com/bufferapp/android-clean-architecture-mvi-boilerplate" target="_blank" rel="noopener">android-clean-architecture-mvi-boilerplate </a></h2><p>所谓基于MVI的Clean Architecture.</p><h2 id="ReactiveNetwork"><a href="#ReactiveNetwork" class="headerlink" title="ReactiveNetwork "></a><a href="https://github.com/pwittchen/ReactiveNetwork" target="_blank" rel="noopener">ReactiveNetwork </a></h2><p>基于RxJava监听网络状态的库.</p>]]></content>
    
    <summary type="html">
    
      Android Weekly 中文概要
    
    </summary>
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/categories/Android-Weekly/"/>
    
    
      <category term="Android Weekly" scheme="http://talentprince.github.io/tags/Android-Weekly/"/>
    
      <category term="Kotlin" scheme="http://talentprince.github.io/tags/Kotlin/"/>
    
      <category term="Room" scheme="http://talentprince.github.io/tags/Room/"/>
    
      <category term="Clean Architecture" scheme="http://talentprince.github.io/tags/Clean-Architecture/"/>
    
      <category term="Android Notification" scheme="http://talentprince.github.io/tags/Android-Notification/"/>
    
      <category term="Path Animation" scheme="http://talentprince.github.io/tags/Path-Animation/"/>
    
      <category term="ConstraintSet Animation" scheme="http://talentprince.github.io/tags/ConstraintSet-Animation/"/>
    
  </entry>
  
</feed>
