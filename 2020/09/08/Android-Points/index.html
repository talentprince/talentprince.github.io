
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Weyoung&#39;s Blog">
    <title>Java与Android知识点总结 - Weyoung&#39;s Blog</title>
    <meta name="author" content="Prince Chen">
    
    
        <link rel="icon" href="http://talentprince.github.io/assets/images/favicon.ico">
    
    
        
            <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Prince Chen","sameAs":["https://github.com/","mailto"],"image":"https://www.gravatar.com/avatar/ff771efeac20ab47f827e759b38f6d53"},"articleBody":"最近在看关于Java以及Android开发相关的一些知识点, 有的非常细节, 有的则很概括, 将其要点总结于此, 以供日后查阅.\n\n\nChar\nChar两个字节, 里面使用UTF-16编码\nString的length是字符占据的长度, 而不是字符个数, python3.3以后已经改成实际个数了, 如果在微博输入一个emoj, 就会减2/3个字符\nJava9会优化字符存储, 字母会用Byte来存字母, 而不是以前的2个字节\nUnicode是字符集, 而不是编码\nASCII (Windows上简体中文用GB2312), Unicode (只规定了二进制代码, 不规定如何存, Windows上用UCS-2), UTF8 (1~4表示一个字符), UTF16 (UCS-2的父集, 2/4字节)\n\n\nString\n栈中的String, 使用CONSTANT_Utf8_info来存储, 长度为u2即两个字节长度, 所以最多65534个字节 (Java编译器用了&lt;而不是&lt;=, Kotlin没问题), 最终储存在方法区内的常量池\n对于汉字, 得通过Utf8编码才知道占用字节, 这里使用了&gt;MAX所以可以存入65535/3个汉字\n堆中的长度跟Int.Max一样, 有些虚拟机有头部保留, 可能为Max - 8\n\n\n方法绑定\nJava方法重载, 编译期就决定了, 调用声明类型\n但是Groovy调用实际类型, 因为它先反射你的变量得到实际类型, 再调用\nC++非虚方法只会调用声明类型方法, 虚方法只有指针调用时才触发虚绑定, C++对象本身赋值会触发赋值/复制构造, 进行裁剪, 所以无法触发绑定\nJava方法都是虚方法, 覆写会动态绑定, 调用实际类型\n注解扩展\nTarget\n限制注解使用位置, 如METHOD, FIELD, TYPE(class/interface)等\n\n\nRetention\n约束其生命周期\nSOURCE 只会在代码里, 编译后丢失\nCLASS 会保留在源码里, 但是不会加载到虚拟机, 如Override, Deprecate\nRUNTIME 加载JVM,  运行时可通过反射用\n\n\n\n\n\n\n\n\nJava泛型\n为了兼容性, Java用了假泛型, 类型擦出\n基本类型无法作为泛型类型, 必须装箱拆箱, Android可以用SparseArray省去装箱\n静态方法没法用类泛型, 因为会早于类实例化, 但可以自己定义方法泛型\n即便有泛型, 1.5以后强转开销还在\nGson的TypeToken(){}.getType()就是通过getGenericReturnType等方法拿到运行时泛型信息, 前提得- keepattributes Signature保存泛型签名\nTypeToken的构造为protected, 通过创建其匿名内部类调用getType方法\n\n\nRetrofit的接口定义Call泛型信息也是通过类似方法\nKotlin反射原理来自最终的注解Metadata, 反射得把kotlin.Metadata{*;}给keep了\n混淆扩展\nkeep 类所有东西都保留\nkeepclassmembers 指定的成员保留, 比如方法, 类成员\nkeepclasseswithmember 保留满足条件(含某成员或者方法)的类\n\n\n\n\nonActivityResult\n不能使用简单回调是因为activity可能重建, 回调匿名类持有的已经不是显示出来的\n新API里通过prepareCall/launch或者直接ActivityResultRegistry注册\n改造回调办法\n基于DummyFragment实现回调 \n将回调存在一个地方, 再次返回调用新Fragment的onResult时将回调中的activity替换成新的\n\n\n基于AOP\nAOP hook住所有activiy的onResult, callback存全局map\n\n\n基于Hook\n向ActivityThread的handler callback里加入自己的handler, 然后拿出返回的activty进行回调\n\n\n\n\n\n\n线程停止\nstop/suspend被废弃了\nstop主要是因为stop后会释放所有线程锁, 这样其他线程就获取一些被保护的变量获取不一致的状态, 因为数据没有机会清理\nsuspend主要因为可能会造成死锁, 或者卡主其他的线程\n\n\n正常的中断方式\nboolean\ninterupt\n\n\n中断\ninterrupted()\n静态方法, 获取当前线程,  读取后状态清空, 除非等到下一次打断信号\n\n\nisInterrupted()\n状态清除前一直是true\n\n\nJava层调用interrupted其实底层给interrupted_加锁并置位\n除非用了sleep, 一般用boolean标志位就够了, boolean需要加上volatile, 并且比底层操作性能高\n\n\n\n\n线程安全\nJava内存模型\n每一个线程都有内存副本, 更改完副本后, JMM会控制刷新主内存, 其他共享该内存的线程会去主内存拉去状态, 更新副本. 类似于线程一向线程二发消息.\nJVM的内存会被分为, 线程栈区跟堆区.\n本地变量原始类型, 放在栈区, 对象类型引用在栈区, 实际对象在堆区\n对象成员方法中的变量, 全部在栈区, 即便对象本身在堆区\n对象的成员变量, 不管什么类型, 都在堆区\n静态类本身与变量都会在堆区\n\n\n堆区的变量是多个线程共享的\nvolatile变量JMM会在写入字段后插入指令, 保证写入时其他线程也能看到更新\nJava5以后提出happens-before模型, 保证前一个操作执行结果对后一个可见\n同一个线程, 顺序执行\n解锁操作与随后的加锁操作\nvolatile的写入与其他线程的读取\n传递性, A-hb-B, B-hb-C, 则A-hb-C\n\n\n\n\n可变资源线程共享\n共享不可变资源\n不共享资源\n函数不使用外部内存\nThreadLocal\n弱引用\n定义全局静态final\n避免存储大量对象\n因为它内部的map使用的开放定址, hash值为magicnumber的倍数\n\n\n用完即时移除\n因为它自己得线程退出才移除\n\n\n\n\n\n\n共享可变\n遵循原则\n可见性\nvolitale防止操作副本\nfinal防止重排序\n加锁, 锁释放时会刷新主内存\n\n\n原子\n++不是原子操作, 因为会把原值放进tmp内再加\n通过加锁保证\n使用CAS指令, 如Unsafe.compareAndSwapInt\n这个方法得通过反射Unsafe内的theUnsafe得到实例\n方法swap成功返回true, 否则返回false\n\n\nAtomicInteger等\nAtomicReferenceFieldUpdater\n\n\n禁止重排序\nfinal可以禁止重排序, 保证赋值操作在构造体内完成\n1.5之后, volitale也能保证改造函数一定在赋值操作之前调用, 写单例必须加上volatile\n\n\n\n\n\n\n\n\n\n\nConcurrentHashMap\nHashTable是全表加锁\n优化进程\n1.5 分段加锁, 必要时加锁\n1.6 优化二次hash算法\n1.7 段懒加载, volatile加cas\n1.8 摒弃段, 基于hashmap实现并发\n\n\n\n\nAtomicReference与AtomicReferenceFieldUpdater\nARFU指向前者, 占用16字节(压缩指针)或者24个字节 \nARFU使用反射, 创建一个静态的用于原子赋值, 节省内存\nAR使用更简单\nkotlin by lazy(PUBLICATION)使用的就是ARFU\n\n\n异步代码\n异步不一定快, 如果是CPU密集型可能会更慢, 因为切换需要消耗\n通过RxJava解决回调低于, 注意异常处理, 以及disposable的处理, 如使用AutoDisposable\n通过Kotlin协程处理, 参考AutoDiaposable写自动cancel, 通过class AutoDisposable(view, job): Job by job, OnAttachStateChangeListener的扩展+代理, 保证不改变原本launch的返回值为Job, 且可链式调用添加Listener控制cancel\n\n\nCPU架构适配(native)\n普通开发者与sdk开发者考虑问题不同, sdk要尽可能全, 并且优化体积\n架构分为mips64/mips(废弃了) x86_64/x86(兼容armeabi) armeabi-v7a/v8a/armeabi\n优先去对应目录找so, 如果不全, 则加载失败, 如果一个都没提供, 则会自动找兼容\n简单的使用v7a最通用的so\n复杂一些把不同的架构都放在armeabi里, 通过代码来加载对应, 获取优化, 如libmath.so\n混用限于同一种位数, 比如都是32位 (arm与v7), 如果v8a机器加载armeabi中的v8a库则会以32位加载出问题\n太大的so库又不是启动项则可以后期增量下载\n-fvisibility=hidden隐藏符号表, 只公开必要, -fno-exceptions -fno ftti用处不大可以去掉, 不要使用iostream使用android log, 可以通过gc-sections去除无用代码, 如cflags-ffunction-sections -fdata-sections, 以及ldflags-WL --gc-sections\n也可以使用官方的splits { abi {} }分包\n\n\nJNI绑定\n分静态绑定与动态绑定\n全部可见占用符号表, 名字写死, 但是AS可以跳转 \n动态绑定(env-&gt;RegisterNative)任何时候都可以触发, 可以覆盖静态绑定\n\n\n需要暴露的JNI方法通过extern &quot;C&quot; JNIEXPORT void JNICALL进行声明\nJNIEXPORT设置了函数的visibility为default\nJNICALL在某些平台上有定义, 如Windows定义了函数如何入栈等惯例规则\n\n\n\n\nJNI数据传递\n指针通过long传递\n字符串传递\nGetStringUTFChars/ReleaseStringUTFChars\nconst char* Modified-UTF-8字节流, \\0编码为0xc080, 不影响c字符串结尾\n\n\nGetStringChars/ReleaseStringChars\nconst jchar* 自动处理字节序转换, Java是大端, C是小端\n\n\nGetStringUTFRegion/GetStringRegion\n需要自己开辟内存, 可以控制长短\n\n\nGetStringCritical/ReleaseStringCritical\n调用会暂停Jvm Gc 与 其他JNI操作\n\n\n这些函数大部分第二个参数都是jboolean* isCopy, 告诉你是不是复制的, 虚拟机支持的话, 可以指向Java层的字符串\n\n\nLocal Reference有个数限制, 使用完就释放, 如果个数少可以等函数调用结束自动释放\nByteBuffer直接在物理内存开辟 (ByteBuffer.allocateDirect), 不需要拷贝, 底层直接通过GetDirectBufferAddress获取指针地址, 但是需要自己处理字节序\n尽可能让底层访问少的Java对象, 减少反射, 多使用基本类型\n\n\n捕获Native异常\nstruct sigaction handler结构体\n调用sigaction(SIGNAL, &amp;handler, &amp;old_hanlders[SIGNAL])设置新的handler, 保存旧的\n然后再新handler内处理不同信号的异常, 处理完再交给oldhandler处理, 类似Java\n对于底层pthread创建的线程, 要通过Jvm-&gt;AttatchCurrentThread来获得新的env, 并且结束后Detach\n如果Jvm-&gt;GetEnv返回JNI_OK, 则可以直接使用, 利用这两个机制创建Helper对象, 析构函数Detach简化Env的获取\n如果Env是attach到native线程上的, 就无法拿到Java层的类了, 就需要通过底层保存的classLoader对象调用findClass来找到jclass\nJNI只有GlobalRef才可以被返回, LocalRef出了函数就被回收了\n需要使用备用栈 (action.sa_flags |= SA_ONSTACK;),  防止SIGSEGV栈循环溢出无法拿到\n通过独立线程收集, 通过libcorkscrew.so(4.1-5.0),libunwind.so(5.0+)\n通过线程对应Java崩溃堆栈, 分析问题\n\n\n只有C/C++才能编译so吗\n只要符合规定就可以运行\n静态绑定\n符号表可见\n命名符合报名_类名_方法名\n符号使用extern C修饰, 不能用C++\n\n\n动态绑定\n只要在JNI_OnLoad里注册就行\n\n\n\n\n可选的编译成native的语言都可以\nGolang, Rust, Kotlin Native, Scala Native\n\n\nKotlin Native\n@CName静态绑定native函数签名\nJEnv*通过对象包装, CPointer\nmemScoped可以自动管理内存\n动态注册需要通过staticCFunction(::function)拿到指针然后register\n\n\n\n\nActivity启动\nActivity通过AMP(Proxy/Client)访问AMS\n解析Activity信息\n处理启动参数\n启动与绑定进程, 通过Zygote fork进程, 以便可以复用资源加快速度\n\n\nAMS通过ATP(Proxy/Client)#scheduleLaunchActivity返回Activity\n控制生命周期回调\n\n\n插件化就是在发起跟结束的时候欺上瞒下, hook发给AMS的信息, 并在返回ActivityThread后改回来\nBundler有缓冲区, 大小有限制, 数据必须序列化\n同一个进程就通过全局共享内存传大数据\n进程间则可能需要ContentProvider之类的\n\n\nActivity跟Fragment都需要无参构造, 系统通过反射创建它\nnew-&gt;attach-&gt;create-&gt;start-&gt;restoreState-&gt;postCreate-&gt;resume-&gt;makeVisible\nattach-&gt;createPhoneWindow\ncreate-&gt;installDecor (add, setContentView)\nresume-&gt;显示 (status bar, action bar, content view)\n\n\n转场动画\n新页面显示之前, 拿到之前页面元素(共享元素)的位置信息, 应用到新元素并播放动画, 达到新页面位置\n\n\n跨App启动Activity\nsharedUserId相同, 直接通过Intent.setComponentName来启动\nexported暴露, 公开可见\n定义了私有的的action\n加上一个自定义permission, 但是必须主应用先安装, 才能申请到权限\n\n\n暴露的Activity如何防止其他人传未知类型导致crash, 拒绝服务漏洞\ntrycatch包住intent.getExtra\n\n\n\n\nActivity传参繁琐\n通过Builder设置Require以及Optional\n在ActivityLifeCycleCallback的onActivityCreated里注入, 这是被onCreate触发的\nonNewIntent需要单独手动处理\n这些都可以通过注解生成器来生成\n需要合并父类的fields, 父类可能不需要生成builder\n万一Activity是内部类可能需要特殊处理, 命名会有$\n尽量少生成代码, kotlin与java之间类型的映射\n\n\n元编程\napt (dagger, arouter), bytecode(replugin), generic, reflect, proxy(retrofit)\n\n\n\n\n任意位置添加View\nGC回收\n被GCRoots持有都不会被回收\n虚拟机栈, 方法栈\n静态类属性\n常量引用\nNative方法引用\n\n\nSoftRef\n内存快满才回收\n\n\nWeakRef\nGC一次就回收\n\n\n\n\nActivity里面添加\n因为只有addContentView, 没有remove, 需要拿到decorview\n\n\n全局View\n通过window来添加\n\n\n\n\nApp右滑效果\nFragment\n不涉及Window, View跟随手势\n手势结束判断取消或者归位动画等\n\n\nActivity\n顶层Window背景为透明\nwindowBackground\nwindowIsTranslucent (如果不设置, window背景会强制被改为不透明)\n\n\n多个Task\n在切task后会先显示另一个task最顶层再打开目标\n可以通过偷偷放截图在下面障眼\n\n\n透明与生命周期\n看不到是create, 能看到是start, 顶层是resume\n\n\nSwipeBackActivity\n必须继承父类\n必须设置windowIsTranslucent\n设置后下面的activity生命周期会变化, 永远会被绘制, 不会进入onStop \n\n\n\n\n优化降低成本\n改继承为实现接口\n通过隐藏方法在滑动的时候转换透明\nconvertToTranslucent/convertFromTranslucent\n\n\n\n\n造轮子, 或者改造现有轮子\n\n\n\n\n\n\n非UI线程更新UI\nZygote–main函数–&gt;ActivtyThread-&gt;Loop–退出后–&gt;RuntimeException\nHandler.post-&gt;Looper.loop-&gt;MessageQueue-&gt;Handler.dispatchMessage-&gt;MainThread\nUI变化快需要高效, 所以不能加锁, 所以必须单线程更新\nSurfaceView可以在非UI线程绘制, lockCanvas-&gt;draw-&gt;unLockCanvasAndPost, 主线程只显示, 所以帧率高\nGLSurfaceView是SurfaceView的子类, 有GLThread进行绘制, 死循环不断onDrawFrame\nHandler.postDelay\nenqueueMessage-&gt;wake-&gt;write\nepoll_wait-&gt;pollOnce-&gt;next(当前时间与消息队列第一条消息时间, 到了就执行, 不到就继续等)-&gt;执行消息\ndelay不靠谱, 大于Looper周期基本可靠 (&gt;50ms)\n消息队列优化\n重复消息过滤\n互斥消息取消\nobtain复用消息, 避免太多触发gc\nIdleHandler, glide3是用它移除ReferenceQueue监听到需要移除的弱引用\nHandlerThread可以自己开线程穿件Looper, 内部已经Loop.prepare+loop过了\n\n\n\n\nLooper与ANR\nService(20s/200s), Broadcast(10s/60s), ContentProvider(10s), InputDispatch(5s)卡久了就ANR\nAMS-&gt;ActiveService-&gt;到app启动Service, 开始后AS会发一个延迟的消息, scheduleServiceTimeoutLocked, 如果规定时间内没有执行完调用doneExecutingLocked, 就会发送handler message到UI线程, 弹出ANR对话框\nLooper是消息循环, 里面出问题了才会有ANR\nLooper空消息后调用epoll_wait, 等待文件消息, 不占用CPU\nepoll_ctl建立监听管道, rbtree\nepoll_wait监听就绪列表, rdlist\n\n\n简单的Handler-Looper\nHandler内部用了开机后消耗了多少时间, 简单实现可以使用当前时间\nLooper.prepare把对象存放在ThreadLocal里\nLooper.loop启动循环调用next拿消息执行\nMessageQueue可以用现成的DelayQueue来实现\n取消息阻塞类似于MessageQueue的nativePollOnce\n不过take阻塞底层通过pthread_cond_timeout来实现\nAndroid为何不使用DelayQueue\n没有合适的remove, android通过msg里的token(obj)移除\n自己实现底层, 自由度更高\nMessageQueue对单线程读取优化, 只有Looper现成读, 提前读取下一条消息\n\n\n\n\n\n\n\n\n\n\n避免OOM \n选择合适的数据结构\nSparseArray+ArrayMap\n数量少于1000, 增删不频繁就用, 扩容慢, 还能缩容\n内存复用, \n\n\n\n\n整形替代枚举 4byte vs 24byte\n@IntDef限制类型, 只能提示不能阻止, kotlin也不支持\ninline class\n\n\n图片使用\n选择合适分辨率, 注意原始分辨率与缩放关系\nxxhdpi放的匹配图片放入hdpi里面会缩放2倍, 占用更多内存\n\n\nbitmap使用重采样, 缩略图\n\n\n不用帧动画, 用代码实现\n谨慎使用多进程, 因为进程本身分配了很多内存\n使用NDK内存跳出JVM限制\n5R原则\nReduce, Reuse, Recycle, Refactor, Revalue\n\n\n图片如何缓存\n三级缓存\n获取成本 缓存成本 缓存价值(命中率) 随着时间的变化\nLRU(对应的还有LFU), 最近使用交换位置排在最后, 干掉最开始不常用的\nLRU内部有一些private的算法统计字段xxxCount\nLRU线程安全, 采用短锁\nLRU内部使用LinkedHashMap, accessOrder设置true会自动发访问过的放最后\n\n\n\n\n图片占用内存大小\n根据dpi抽象出canvas层, 在不同设备上进行缩放\ngetByteCount应该占用内存\ngetAllocationByteCount实际占用, 当小图复用大图时\n预先计算\n宽高像素编码位数\n高dpi手机拿低dpi文件夹下的, 图片会变大 (scale=屏幕dpi/图片目录dpi + 0.5f)\n\n\ninSampleSize采样大变小, 矩阵变换小变大\n使用svg, rgb_565, 9-patch, 不用图\n通过assets中透明的indexed-png+rgb565强行加载index-8类型\n因为skia库中对于透明的565格式返回图本身\n该类型不能通过Bitmap创建Canvas, 不能放入缩放目录\n8.1底层开始被移除了\n\n\n\n\n\n\nAndroid P隐藏API\n@hide的函数可以通过自编jar骗过编译器\nprivate的只能使用反射\nsetAccessible绕过权限控制, 还可以修改final变量\n\n\nAPI名单\n白名单\n浅灰名单 反射依旧可以用\n深灰名单\nTarge低于28 可以使用\nTarge&gt;=28 反射也不能用\n\n\n黑名单 反射也不能用\n\n\nAndroid修改了getDeclaredMethods方法, 调用底层检查是否在白名单或者是否是No_check的Policy\n使用FreeReflection绕过检查\n修改Runtime的hidden_api_policy\n底层通过JavaVM拿到JavaVMExt的私有变量Runtime\n自己写个Struct凑位数, 第二个void*(没虚方法少一个vp)类型就是Runtime变量\nRuntime里面通过每4个字节(内存对齐)查找定位变量位置\n查找target_sdk_version做为定位点, 将Runtime转换为PartialRuntime拿到Policy修改\n\n\n修改hidden_api_exemptions, 让程序豁免\n类似于第一种方法拿到Runtime, 修改HiddenApiExemptions \n\n\n\n\n修改想要使用的Class, 将其ClassLoader置空 \nfn_caller_is_trusted判断如果classLoader是空认为是bootClassLoader\n可以在Java层修改, 也可以在native层修改\n\n\n\n\n换肤功能\nTheme只支持定义的时候配置的值, 无法外部与动态加载\n资源加载Context-&gt;Resource-&gt;AssetsManager (xml, 非xml, ResourceValue, ResourceText)\nResources内缓存替换\n替换资源有限, 只能替换缓存过的\nHook繁琐\n\n\nResourcesWrapper包装\n不支持style, assets目录\n包装起来代码量大\nid映射可以在编译时期一致, 或者动态映射\nId映射成资源name, 然后替换package再查找资源包新Id\n\n\n\n\nAssertManager替换\n支持style, assets, 替换简洁\n不能动态映射, 只能编译器需要对齐资源ID\naapt输入主包的id映射表, public.xml\n或者修改resource.arsc\n如果皮肤资源少, 不能剔除public.xml, 因为剔除后位置会被后续非public资源补位, 保持资源紧凑\n皮肤包资源需要对自己没有而主包有的资源进行占位/补位, 保证主包资源能加载进来\n修改AAPT, 或者直接修改resource.arsc\nResourceTable#applyPublicEntryOrder中间为不存在的占坑\n如果最后有少资源还需要补位\n\n\n\n\n非运行时替换\n编译器主包跟皮肤包差分, 应用阶段主包再与差分包合成皮肤包, 需要资源重定向\n创建新的AssertManager只需要加入一个包即可, 因为包含所有资源\n\n\n反射创建并调用AssertManager#addAssetPath方法加入主包, 皮肤包, L以上要单独把Assets拿出来最后再加一次\n插件化是为了资源并存\n皮肤是为了覆盖\n\n\n创建WrapContext\nattatchBaseContext的时候包装, 替换掉里面的resource, assertManager, classLoader\nResource可以通过AssertManager构造\n\n\ngetBaseContext的时候解包\n可以使用JavaAssist改字节码插入attatch/detach方法\n\n\n\n\n\n\nVirtualAPK\nClassLoader双亲委派\nDexClassLoader (user/plugin) -&gt; PathClassLoader (context) -&gt; BootClassLoader (parent)\n先查看是否加载, 然后由父类查找, 父类查不到再让子类查找\n他们都继承了BaseClassLoader-&gt;ClassLoader\nBaseClassLoader#findClass会在pathList里查找类, 而这个list就是dex的list\n\n\n\n\nTinker\nPatch与Apk组成新Apk并放在Dex数组最前面\n基于Dex的差分, DexSectionDiffAlgorithm/DexSectionPatchAlogrithm\n先排序再用双指针分别指向\n如果Old指针指向小于New指针指向, 说明DEL了\n如果Old指针指向大于New指针指向, 说明ADD了\n如果相等, 则更新映射\n最后Index相同内容不同, 删除ADD/DEL操作, 标识为REPLACE\n最终把变化转换为差分后的操作\n\n\n\n\nAssets直接创建新的AssetsManager\n基于Entry的BSDiff, 得出资源差分包\n与旧资源组成新包, 创建新的AssetsManager加载\n\n\n异常熔断\n加载之前checkpatch\n单一进程启动三次失败\n十秒钟内崩溃多次\n大量注释, 46000代码, 69%代码\n早起监控129个\n\n\n\n\nShadow\n使用Hook在海外直接下架\n由反射转入编译器字节码, 注解处理器的方案\nShadow属于静态代理流派, 使用了很多字节码编辑\n插件化流派\n动态Hook\n发送的时候靠占坑Activity替换绕过AMS检测, AMS返回的时候再换回PluginActivity\n\n\n静态代理\n将Activity的启动与生命周期靠ProxyActivity代理, 然后传递给PluginActivity, Plugin寄生与Proxy不被系统获知\n在编译的时候, 通过字节码修改, 将PluginActivity修改成寄生的ShadowActivity\n\n\n\n\nShadow结构\nmanager (插件管理, 如版本)\nplugin (ShadowActivity)\nruntime (PluginContainerAcitity, Proxy)\nloader (实现插件加载)\nplugin, runtime, loader可以有多组, 没各插件都有一组, manager只有一个, 他们都是单独的apk\n\n\n\n\nShadow模块\nDynamicPluginManager与PluginProcessService都在Host里, 前者负责加载Manger, 反射创建PluginManager实例, 而该实例负责启动跨进程通信Service\nPluginProcessService负责启动Loader与Runtime\nManager通过Binder接口直接控制Loader加载对应Plugin\n\n\n宿主与插件ClassLoader关系\nApkClassLoader负责加载Manager, Loader\nRuntimeClassLoader负责加载Runtime, 唯一的反射将其挂在PathClassLoader之上, 为了让系统启动Proxy壳子\n\n\n宿主与插件资源关系\n分开, ShadowActivity默认注入插件资源\n\n\n字节码编辑\nJava -&gt; APT (AST-&gt;Symbol)-&gt;Class-&gt;Dex-&gt;Apk\nClass-&gt;Transform-&gt;Dex通过Transform修改\n源码-&gt;Javassit-&gt;ASM-&gt;字节码, 越来越抽象\n\n\n插件系统通信机制\n主从通信\n插件注册Callback到宿主\n插件通过binder与宿主通信\n\n\n对等结构\n通信模块可能也是特殊的插件\n低频用Broadcast, 高频用LocalSocket\n\n\n\n\n插件更新管理\n差分包\nDex使用DexDiff(Tinker)\nso使用Courgette(指令差分)\nbinary使用BSDiff\n\n\nv2签名\n插件包可以不需要签名\n自研的更新服务器可重新签名\n可以拿到签名   \n先解包重新排列再签名\n与重排列的完整包进行差分\n合并插件\n\n\n拿不到签名\n拿到原始包压缩级别， entrylist\n合成新的包, 可以做到复制签名信息等同等MD5值\ngoogle/archive-patcher\n\n\n\n\n\n\n工程管理\nMaven版本管理, 但有缓存不好用\n所有都在一个project中, 耦合性大\nGit Submodule, 依赖git, 手动管理更新代码\nGradle CompositeBuild\nsetting.gradle里面直接includeBuild=path-to-other-project\n也有一些插件简化该操作\n\n\n\n\n\n\n\n\n如何开展优化\n目标必须明确, 从定性到定量\n定位关键问题, 找出最大的点, 梳理优先级\n二八定律\n前期20%时间解决80%问题\n后期则相反\n\n\n业内对比, 造轮子成本高\n优化需要监控\n算法策略优化\n对比现有方案, 论文或者经验交流\n不同角度问题分析, 选择痛点\n算法能否动态下发\n监控报表与收益\n\n\n工程技术优化\n现有方案对比 \n系统方案, 开源方案, 基于开源自研方案\n\n\n基于开源自研优化\n针对特定Case进行处理, 如估算+再次判断\n与产品探讨是否接受妥协, 使用估算代替精确\n\n\n开源协议License\nGPL 使用了就必须开源\nLGPL 不用开源\n\n\n\n\n\n\n系统设计\n需求分析与系统设计\n需求-&gt;流程-&gt;细节\n细节\nIO密集还是CPU密集\n线程如何调度, 需要多少线程\n使用RxJava还是Koroutine\n网络接入\n长连接, 高频交互, 维护复杂\n心跳保活, 要求高6-9s, 一般30-40s\n\n\n短连接, 低频交互, 查询为主\n短轮询, 固定时间抓取\n长轮询, 60秒时间如果有就返回, 没有就超时让客户端重新抓\n\n\n\n\n加密算法\n对称加密 \n非对称加密, 耗时太长, 对数据长度有限制(RSA)\n一般用对称加密, 用非对称加密将对称加密秘钥加密\n\n\n热修复与插件化\n是否需要立即生效\n是否修改或者新增类\n是否有未来做平台的打算\n\n\n脚本化\n存在很多模式化逻辑, 游戏关卡, 自定义UI体系等\n经常调整的策略\n\n\n可以执行\n是否存在复杂平台不想管逻辑, 抽象为so库\n\n\n性能问题\n算法时间空间复杂度\n内存峰值OOM\nCPU占用与耗电量\n\n\n监控\n异常捕获Java+Native\n性能监控\n优化指标监控\n运营数据监控\n\n\n\n\n\n\n短视频APP\n网络\n相机\n新API都是异步, 状态难维护\n\n\n滤镜\n下发Shader Script给OpenGL渲染\n\n\n播放器\nH265 文件小, 硬件支持差, 解码慢, 适合热点小规模\nH264 文件大一些, 硬件支持好, 解码快, 适合大规模\n自带播放器一般收到一组GOP才能播放, FFmpeg收到关键帧就可以\n\n\n封装模式调整\nMpeg4 (File Type Box, Movie Box, Media Data Box)\n将一般的顺序由ftyp-mdat-moov改为ftyp-moov-mdat, 边下边播\n\n\n\n\n网络请求框架\n依赖简单, 接口简单, 功能纯粹\n协议 Http, WebSocket\n基础组件\n连接管理\n线程管理\n\n\n拦截器, 日志系统也是类似\n重试机制, 渐进式重试, 最大重试次数与衰减因子\n使用注解配置请求, 类似于retrofit与spring\n支持第三方扩展, 支持rx, suspend\nDNS增强, HttpDnsServer, 提速防止被劫持\n\n\n\n","dateCreated":"2020-09-08T12:25:31+08:00","dateModified":"2020-09-08T12:38:34+08:00","datePublished":"2020-09-08T12:25:31+08:00","description":"最近在看关于Java以及Android开发相关的一些知识点, 有的非常细节, 有的则很概括, 将其要点总结于此, 以供日后查阅.","headline":"Java与Android知识点总结","image":["https://res.cloudinary.com/dtn0pkdmg/image/upload/v1599539474/note_zuxqpg.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"http://talentprince.github.io/2020/09/08/Android-Points/"},"publisher":{"@type":"Organization","name":"Prince Chen","sameAs":["https://github.com/","mailto"],"image":"https://www.gravatar.com/avatar/ff771efeac20ab47f827e759b38f6d53","logo":{"@type":"ImageObject","url":"https://www.gravatar.com/avatar/ff771efeac20ab47f827e759b38f6d53"}},"url":"http://talentprince.github.io/2020/09/08/Android-Points/","keywords":"Android, Note","thumbnailUrl":"https://res.cloudinary.com/dtn0pkdmg/image/upload/v1599539474/note_zuxqpg.jpg"}</script>
    <meta name="description" content="Android 知识点">
<meta name="keywords" content="Android,Note">
<meta property="og:type" content="blog">
<meta property="og:title" content="Java与Android知识点总结">
<meta property="og:url" content="http://talentprince.github.io/2020/09/08/Android-Points/index.html">
<meta property="og:site_name" content="Weyoung&#39;s Blog">
<meta property="og:description" content="Android 知识点">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2020-09-08T04:38:34.237Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java与Android知识点总结">
<meta name="twitter:description" content="Android 知识点">
    
    
        
    
    
    
        <meta property="og:image" content="https://res.cloudinary.com/dtn0pkdmg/image/upload/v1599539474/note_zuxqpg.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://res.cloudinary.com/dtn0pkdmg/image/upload/v1599539474/note_zuxqpg.jpg"/>
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-mfdqvh3ohnpramsqqbc7zbl79sacpxx7rmxse96gjjfq9veqgomv4f7jzw28.min.css">
    <!--STYLES END-->
    

    
    <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?26839bbbc9c89fbe9eb99aba7bceb413";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>


    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="5">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            Weyoung&#39;s Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打开链接: /#about"
            >
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="5">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="首页"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="分类"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="标签"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="归档"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜索"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="关于"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/mailto"
                            
                            rel="noopener"
                            title="邮箱"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="5"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Java与Android知识点总结
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2020-09-08T12:25:31+08:00">
	
		    9月 08, 2020
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Android-Note/">Android Note</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>最近在看关于Java以及Android开发相关的一些知识点, 有的非常细节, 有的则很概括, 将其要点总结于此, 以供日后查阅.</p>
<a id="more"></a>
<ul>
<li>Char<ul>
<li>Char两个字节, 里面使用UTF-16编码</li>
<li>String的length是字符占据的长度, 而不是字符个数, python3.3以后已经改成实际个数了, 如果在微博输入一个emoj, 就会减2/3个字符</li>
<li>Java9会优化字符存储, 字母会用Byte来存字母, 而不是以前的2个字节</li>
<li>Unicode是字符集, 而不是编码</li>
<li>ASCII (Windows上简体中文用GB2312), Unicode (只规定了二进制代码, 不规定如何存, Windows上用UCS-2), UTF8 (1~4表示一个字符), UTF16 (UCS-2的父集, 2/4字节)</li>
</ul>
</li>
<li>String<ul>
<li>栈中的String, 使用<code>CONSTANT_Utf8_info</code>来存储, 长度为u2即两个字节长度, 所以最多65534个字节 (Java编译器用了&lt;而不是&lt;=, Kotlin没问题), 最终储存在方法区内的常量池</li>
<li>对于汉字, 得通过Utf8编码才知道占用字节, 这里使用了&gt;MAX所以可以存入65535/3个汉字</li>
<li>堆中的长度跟Int.Max一样, 有些虚拟机有头部保留, 可能为Max - 8</li>
</ul>
</li>
<li>方法绑定<ul>
<li>Java方法重载, 编译期就决定了, 调用声明类型</li>
<li>但是Groovy调用实际类型, 因为它先反射你的变量得到实际类型, 再调用</li>
<li>C++非虚方法只会调用声明类型方法, 虚方法只有指针调用时才触发虚绑定, C++对象本身赋值会触发赋值/复制构造, 进行裁剪, 所以无法触发绑定</li>
<li>Java方法都是虚方法, 覆写会动态绑定, 调用实际类型</li>
<li>注解扩展<ul>
<li>Target<ul>
<li>限制注解使用位置, 如METHOD, FIELD, TYPE(class/interface)等</li>
</ul>
</li>
<li>Retention<ul>
<li>约束其生命周期<ul>
<li>SOURCE 只会在代码里, 编译后丢失</li>
<li>CLASS 会保留在源码里, 但是不会加载到虚拟机, 如Override, Deprecate</li>
<li>RUNTIME 加载JVM,  运行时可通过反射用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Java泛型<ul>
<li>为了兼容性, Java用了假泛型, 类型擦出</li>
<li>基本类型无法作为泛型类型, 必须装箱拆箱, Android可以用SparseArray省去装箱</li>
<li>静态方法没法用类泛型, 因为会早于类实例化, 但可以自己定义方法泛型</li>
<li>即便有泛型, 1.5以后强转开销还在</li>
<li>Gson的TypeToken<x>(){}.getType()就是通过getGenericReturnType等方法拿到运行时泛型信息, 前提得<code>- keepattributes Signature</code>保存泛型签名<ul>
<li>TypeToken的构造为protected, 通过创建其匿名内部类调用getType方法</li>
</ul>
</x></li>
<li>Retrofit的接口定义Call<x>泛型信息也是通过类似方法</x></li>
<li>Kotlin反射原理来自最终的注解Metadata, 反射得把<code>kotlin.Metadata{*;}</code>给keep了</li>
<li>混淆扩展<ul>
<li>keep 类所有东西都保留</li>
<li>keepclassmembers 指定的成员保留, 比如方法, 类成员</li>
<li>keepclasseswithmember 保留满足条件(含某成员或者方法)的类</li>
</ul>
</li>
</ul>
</li>
<li>onActivityResult<ul>
<li>不能使用简单回调是因为activity可能重建, 回调匿名类持有的已经不是显示出来的</li>
<li>新API里通过prepareCall/launch或者直接ActivityResultRegistry注册</li>
<li>改造回调办法<ul>
<li>基于DummyFragment实现回调 <ul>
<li>将回调存在一个地方, 再次返回调用新Fragment的onResult时将回调中的activity替换成新的</li>
</ul>
</li>
<li>基于AOP<ul>
<li>AOP hook住所有activiy的onResult, callback存全局map</li>
</ul>
</li>
<li>基于Hook<ul>
<li>向ActivityThread的handler callback里加入自己的handler, 然后拿出返回的activty进行回调</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>线程停止<ul>
<li>stop/suspend被废弃了<ul>
<li>stop主要是因为stop后会释放所有线程锁, 这样其他线程就获取一些被保护的变量获取不一致的状态, 因为数据没有机会清理</li>
<li>suspend主要因为可能会造成死锁, 或者卡主其他的线程</li>
</ul>
</li>
<li>正常的中断方式<ul>
<li>boolean</li>
<li>interupt</li>
</ul>
</li>
<li>中断<ul>
<li>interrupted()<ul>
<li>静态方法, 获取当前线程,  读取后状态清空, 除非等到下一次打断信号</li>
</ul>
</li>
<li>isInterrupted()<ul>
<li>状态清除前一直是true</li>
</ul>
</li>
<li>Java层调用interrupted其实底层给<code>interrupted_</code>加锁并置位</li>
<li>除非用了sleep, 一般用boolean标志位就够了, boolean需要加上volatile, 并且比底层操作性能高</li>
</ul>
</li>
</ul>
</li>
<li>线程安全<ul>
<li>Java内存模型<ul>
<li>每一个线程都有内存副本, 更改完副本后, JMM会控制刷新主内存, 其他共享该内存的线程会去主内存拉去状态, 更新副本. 类似于线程一向线程二发消息.</li>
<li>JVM的内存会被分为, 线程栈区跟堆区.<ul>
<li>本地变量原始类型, 放在栈区, 对象类型引用在栈区, 实际对象在堆区</li>
<li>对象成员方法中的变量, 全部在栈区, 即便对象本身在堆区</li>
<li>对象的成员变量, 不管什么类型, 都在堆区</li>
<li>静态类本身与变量都会在堆区</li>
</ul>
</li>
<li>堆区的变量是多个线程共享的</li>
<li>volatile变量JMM会在写入字段后插入指令, 保证写入时其他线程也能看到更新</li>
<li>Java5以后提出happens-before模型, 保证前一个操作执行结果对后一个可见<ul>
<li>同一个线程, 顺序执行</li>
<li>解锁操作与随后的加锁操作</li>
<li>volatile的写入与其他线程的读取</li>
<li>传递性, A-hb-B, B-hb-C, 则A-hb-C</li>
</ul>
</li>
</ul>
</li>
<li>可变资源线程共享<ul>
<li>共享不可变资源</li>
<li>不共享资源<ul>
<li>函数不使用外部内存</li>
<li>ThreadLocal<ul>
<li>弱引用</li>
<li>定义全局静态final</li>
<li>避免存储大量对象<ul>
<li>因为它内部的map使用的开放定址, hash值为magicnumber的倍数</li>
</ul>
</li>
<li>用完即时移除<ul>
<li>因为它自己得线程退出才移除</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>共享可变<ul>
<li>遵循原则<ul>
<li>可见性<ul>
<li>volitale防止操作副本</li>
<li>final防止重排序</li>
<li>加锁, 锁释放时会刷新主内存</li>
</ul>
</li>
<li>原子<ul>
<li>++不是原子操作, 因为会把原值放进tmp内再加</li>
<li>通过加锁保证</li>
<li>使用CAS指令, 如Unsafe.compareAndSwapInt<ul>
<li>这个方法得通过反射Unsafe内的<code>theUnsafe</code>得到实例</li>
<li>方法swap成功返回true, 否则返回false</li>
</ul>
</li>
<li>AtomicInteger等</li>
<li>AtomicReferenceFieldUpdater</li>
</ul>
</li>
<li>禁止重排序<ul>
<li>final可以禁止重排序, 保证赋值操作在构造体内完成</li>
<li>1.5之后, volitale也能保证改造函数一定在赋值操作之前调用, 写单例必须加上volatile</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>ConcurrentHashMap<ul>
<li>HashTable是全表加锁</li>
<li>优化进程<ul>
<li>1.5 分段加锁, 必要时加锁</li>
<li>1.6 优化二次hash算法</li>
<li>1.7 段懒加载, volatile加cas</li>
<li>1.8 摒弃段, 基于hashmap实现并发</li>
</ul>
</li>
</ul>
</li>
<li>AtomicReference与AtomicReferenceFieldUpdater<ul>
<li>ARFU指向前者, 占用16字节(压缩指针)或者24个字节 </li>
<li>ARFU使用反射, 创建一个静态的用于原子赋值, 节省内存</li>
<li>AR使用更简单</li>
<li>kotlin by lazy(PUBLICATION)使用的就是ARFU</li>
</ul>
</li>
<li>异步代码<ul>
<li>异步不一定快, 如果是CPU密集型可能会更慢, 因为切换需要消耗</li>
<li>通过RxJava解决回调低于, 注意异常处理, 以及disposable的处理, 如使用AutoDisposable</li>
<li>通过Kotlin协程处理, 参考AutoDiaposable写自动cancel, 通过class AutoDisposable(view, job): Job by job, OnAttachStateChangeListener的扩展+代理, 保证不改变原本launch的返回值为Job, 且可链式调用添加Listener控制cancel</li>
</ul>
</li>
<li>CPU架构适配(native)<ul>
<li>普通开发者与sdk开发者考虑问题不同, sdk要尽可能全, 并且优化体积</li>
<li>架构分为mips64/mips(废弃了) x86_64/x86(兼容armeabi) armeabi-v7a/v8a/armeabi</li>
<li>优先去对应目录找so, 如果不全, 则加载失败, 如果一个都没提供, 则会自动找兼容</li>
<li>简单的使用v7a最通用的so</li>
<li>复杂一些把不同的架构都放在armeabi里, 通过代码来加载对应, 获取优化, 如libmath.so</li>
<li>混用限于同一种位数, 比如都是32位 (arm与v7), 如果v8a机器加载armeabi中的v8a库则会以32位加载出问题</li>
<li>太大的so库又不是启动项则可以后期增量下载</li>
<li><code>-fvisibility=hidden</code>隐藏符号表, 只公开必要, <code>-fno-exceptions -fno ftti</code>用处不大可以去掉, 不要使用iostream使用android log, 可以通过gc-sections去除无用代码, 如cflags<code>-ffunction-sections</code> <code>-fdata-sections</code>, 以及ldflags<code>-WL</code> <code>--gc-sections</code></li>
<li>也可以使用官方的splits { abi {} }分包</li>
</ul>
</li>
<li>JNI绑定<ul>
<li>分静态绑定与动态绑定<ul>
<li>全部可见占用符号表, 名字写死, 但是AS可以跳转 </li>
<li>动态绑定(env-&gt;RegisterNative)任何时候都可以触发, 可以覆盖静态绑定</li>
</ul>
</li>
<li>需要暴露的JNI方法通过<code>extern &quot;C&quot; JNIEXPORT void JNICALL</code>进行声明<ul>
<li><code>JNIEXPORT</code>设置了函数的visibility为default</li>
<li><code>JNICALL</code>在某些平台上有定义, 如Windows定义了函数如何入栈等惯例规则</li>
</ul>
</li>
</ul>
</li>
<li>JNI数据传递<ul>
<li>指针通过long传递</li>
<li>字符串传递<ul>
<li>GetStringUTFChars/ReleaseStringUTFChars<ul>
<li>const char* Modified-UTF-8字节流, <code>\0</code>编码为0xc080, 不影响c字符串结尾</li>
</ul>
</li>
<li>GetStringChars/ReleaseStringChars<ul>
<li>const jchar* 自动处理字节序转换, Java是大端, C是小端</li>
</ul>
</li>
<li>GetStringUTFRegion/GetStringRegion<ul>
<li>需要自己开辟内存, 可以控制长短</li>
</ul>
</li>
<li>GetStringCritical/ReleaseStringCritical<ul>
<li>调用会暂停Jvm Gc 与 其他JNI操作</li>
</ul>
</li>
<li>这些函数大部分第二个参数都是<code>jboolean* isCopy</code>, 告诉你是不是复制的, 虚拟机支持的话, 可以指向Java层的字符串</li>
</ul>
</li>
<li>Local Reference有个数限制, 使用完就释放, 如果个数少可以等函数调用结束自动释放</li>
<li>ByteBuffer直接在物理内存开辟 (ByteBuffer.allocateDirect), 不需要拷贝, 底层直接通过<code>GetDirectBufferAddress</code>获取指针地址, 但是需要自己处理字节序</li>
<li>尽可能让底层访问少的Java对象, 减少反射, 多使用基本类型</li>
</ul>
</li>
<li>捕获Native异常<ul>
<li><code>struct sigaction</code> handler结构体</li>
<li>调用sigaction(SIGNAL, &amp;handler, &amp;old_hanlders[SIGNAL])设置新的handler, 保存旧的</li>
<li>然后再新handler内处理不同信号的异常, 处理完再交给oldhandler处理, 类似Java</li>
<li>对于底层pthread创建的线程, 要通过<code>Jvm-&gt;AttatchCurrentThread</code>来获得新的env, 并且结束后Detach</li>
<li>如果<code>Jvm-&gt;GetEnv</code>返回JNI_OK, 则可以直接使用, 利用这两个机制创建Helper对象, 析构函数Detach简化Env的获取</li>
<li>如果Env是attach到native线程上的, 就无法拿到Java层的类了, 就需要通过底层保存的<code>classLoader</code>对象调用findClass来找到jclass</li>
<li>JNI只有GlobalRef才可以被返回, LocalRef出了函数就被回收了</li>
<li>需要使用备用栈 (<code>action.sa_flags |= SA_ONSTACK;</code>),  防止SIGSEGV栈循环溢出无法拿到</li>
<li>通过独立线程收集, 通过libcorkscrew.so(4.1-5.0),libunwind.so(5.0+)</li>
<li>通过线程对应Java崩溃堆栈, 分析问题</li>
</ul>
</li>
<li>只有C/C++才能编译so吗<ul>
<li>只要符合规定就可以运行<ul>
<li>静态绑定<ul>
<li>符号表可见</li>
<li>命名符合报名_类名_方法名</li>
<li>符号使用extern C修饰, 不能用C++</li>
</ul>
</li>
<li>动态绑定<ul>
<li>只要在JNI_OnLoad里注册就行</li>
</ul>
</li>
</ul>
</li>
<li>可选的编译成native的语言都可以<ul>
<li>Golang, Rust, Kotlin Native, Scala Native</li>
</ul>
</li>
<li>Kotlin Native<ul>
<li>@CName静态绑定native函数签名</li>
<li>JEnv*通过对象包装, CPointer<jnienvvar></jnienvvar></li>
<li>memScoped可以自动管理内存</li>
<li>动态注册需要通过<code>staticCFunction(::function)</code>拿到指针然后register</li>
</ul>
</li>
</ul>
</li>
<li>Activity启动<ul>
<li>Activity通过AMP(Proxy/Client)访问AMS<ul>
<li>解析Activity信息</li>
<li>处理启动参数</li>
<li>启动与绑定进程, 通过Zygote fork进程, 以便可以复用资源加快速度</li>
</ul>
</li>
<li>AMS通过ATP(Proxy/Client)#scheduleLaunchActivity返回Activity<ul>
<li>控制生命周期回调</li>
</ul>
</li>
<li>插件化就是在发起跟结束的时候欺上瞒下, hook发给AMS的信息, 并在返回ActivityThread后改回来</li>
<li>Bundler有缓冲区, 大小有限制, 数据必须序列化<ul>
<li>同一个进程就通过全局共享内存传大数据</li>
<li>进程间则可能需要ContentProvider之类的</li>
</ul>
</li>
<li>Activity跟Fragment都需要无参构造, 系统通过反射创建它<ul>
<li>new-&gt;attach-&gt;create-&gt;start-&gt;restoreState-&gt;postCreate-&gt;resume-&gt;makeVisible</li>
<li>attach-&gt;createPhoneWindow</li>
<li>create-&gt;installDecor (add, setContentView)</li>
<li>resume-&gt;显示 (status bar, action bar, content view)</li>
</ul>
</li>
<li>转场动画<ul>
<li>新页面显示之前, 拿到之前页面元素(共享元素)的位置信息, 应用到新元素并播放动画, 达到新页面位置</li>
</ul>
</li>
<li>跨App启动Activity<ul>
<li>sharedUserId相同, 直接通过Intent.setComponentName来启动</li>
<li>exported暴露, 公开可见</li>
<li>定义了私有的的action<ul>
<li>加上一个自定义permission, 但是必须主应用先安装, 才能申请到权限</li>
</ul>
</li>
<li>暴露的Activity如何防止其他人传未知类型导致crash, 拒绝服务漏洞<ul>
<li>trycatch包住intent.getExtra</li>
</ul>
</li>
</ul>
</li>
<li>Activity传参繁琐<ul>
<li>通过Builder设置Require以及Optional</li>
<li>在ActivityLifeCycleCallback的onActivityCreated里注入, 这是被onCreate触发的</li>
<li>onNewIntent需要单独手动处理</li>
<li>这些都可以通过注解生成器来生成<ul>
<li>需要合并父类的fields, 父类可能不需要生成builder</li>
<li>万一Activity是内部类可能需要特殊处理, 命名会有$</li>
<li>尽量少生成代码, kotlin与java之间类型的映射</li>
</ul>
</li>
<li>元编程<ul>
<li>apt (dagger, arouter), bytecode(replugin), generic, reflect, proxy(retrofit)</li>
</ul>
</li>
</ul>
</li>
<li>任意位置添加View<ul>
<li>GC回收<ul>
<li>被GCRoots持有都不会被回收<ul>
<li>虚拟机栈, 方法栈</li>
<li>静态类属性</li>
<li>常量引用</li>
<li>Native方法引用</li>
</ul>
</li>
<li>SoftRef<ul>
<li>内存快满才回收</li>
</ul>
</li>
<li>WeakRef<ul>
<li>GC一次就回收</li>
</ul>
</li>
</ul>
</li>
<li>Activity里面添加<ul>
<li>因为只有addContentView, 没有remove, 需要拿到decorview</li>
</ul>
</li>
<li>全局View<ul>
<li>通过window来添加</li>
</ul>
</li>
</ul>
</li>
<li>App右滑效果<ul>
<li>Fragment<ul>
<li>不涉及Window, View跟随手势</li>
<li>手势结束判断取消或者归位动画等</li>
</ul>
</li>
<li>Activity<ul>
<li>顶层Window背景为透明<ul>
<li>windowBackground</li>
<li>windowIsTranslucent (如果不设置, window背景会强制被改为不透明)</li>
</ul>
</li>
<li>多个Task<ul>
<li>在切task后会先显示另一个task最顶层再打开目标</li>
<li>可以通过偷偷放截图在下面障眼</li>
</ul>
</li>
<li>透明与生命周期<ul>
<li>看不到是create, 能看到是start, 顶层是resume</li>
</ul>
</li>
<li>SwipeBackActivity<ul>
<li>必须继承父类</li>
<li>必须设置windowIsTranslucent<ul>
<li>设置后下面的activity生命周期会变化, 永远会被绘制, 不会进入onStop </li>
</ul>
</li>
</ul>
</li>
<li>优化降低成本<ul>
<li>改继承为实现接口</li>
<li>通过隐藏方法在滑动的时候转换透明<ul>
<li>convertToTranslucent/convertFromTranslucent</li>
</ul>
</li>
</ul>
</li>
<li>造轮子, 或者改造现有轮子</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>非UI线程更新UI<ul>
<li>Zygote–main函数–&gt;ActivtyThread-&gt;Loop–退出后–&gt;RuntimeException</li>
<li>Handler.post-&gt;Looper.loop-&gt;MessageQueue-&gt;Handler.dispatchMessage-&gt;MainThread</li>
<li>UI变化快需要高效, 所以不能加锁, 所以必须单线程更新</li>
<li>SurfaceView可以在非UI线程绘制, lockCanvas-&gt;draw-&gt;unLockCanvasAndPost, 主线程只显示, 所以帧率高</li>
<li>GLSurfaceView是SurfaceView的子类, 有GLThread进行绘制, 死循环不断onDrawFrame</li>
<li>Handler.postDelay<ul>
<li>enqueueMessage-&gt;wake-&gt;write</li>
<li>epoll_wait-&gt;pollOnce-&gt;next(当前时间与消息队列第一条消息时间, 到了就执行, 不到就继续等)-&gt;执行消息</li>
<li>delay不靠谱, 大于Looper周期基本可靠 (&gt;50ms)</li>
<li>消息队列优化<ul>
<li>重复消息过滤</li>
<li>互斥消息取消</li>
<li>obtain复用消息, 避免太多触发gc</li>
<li>IdleHandler, glide3是用它移除ReferenceQueue监听到需要移除的弱引用</li>
<li>HandlerThread可以自己开线程穿件Looper, 内部已经Loop.prepare+loop过了</li>
</ul>
</li>
</ul>
</li>
<li>Looper与ANR<ul>
<li>Service(20s/200s), Broadcast(10s/60s), ContentProvider(10s), InputDispatch(5s)卡久了就ANR</li>
<li>AMS-&gt;ActiveService-&gt;到app启动Service, 开始后AS会发一个延迟的消息, scheduleServiceTimeoutLocked, 如果规定时间内没有执行完调用doneExecutingLocked, 就会发送handler message到UI线程, 弹出ANR对话框</li>
<li>Looper是消息循环, 里面出问题了才会有ANR</li>
<li>Looper空消息后调用epoll_wait, 等待文件消息, 不占用CPU<ul>
<li>epoll_ctl建立监听管道, rbtree</li>
<li>epoll_wait监听就绪列表, rdlist</li>
</ul>
</li>
<li>简单的Handler-Looper<ul>
<li>Handler内部用了开机后消耗了多少时间, 简单实现可以使用当前时间</li>
<li>Looper.prepare把对象存放在ThreadLocal里</li>
<li>Looper.loop启动循环调用next拿消息执行</li>
<li>MessageQueue可以用现成的DelayQueue来实现<ul>
<li>取消息阻塞类似于MessageQueue的nativePollOnce</li>
<li>不过take阻塞底层通过<code>pthread_cond_timeout</code>来实现</li>
<li>Android为何不使用DelayQueue<ul>
<li>没有合适的remove, android通过msg里的token(obj)移除</li>
<li>自己实现底层, 自由度更高</li>
<li>MessageQueue对单线程读取优化, 只有Looper现成读, 提前读取下一条消息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>避免OOM <ul>
<li>选择合适的数据结构<ul>
<li>SparseArray+ArrayMap<ul>
<li>数量少于1000, 增删不频繁就用, 扩容慢, 还能缩容</li>
<li>内存复用, </li>
</ul>
</li>
</ul>
</li>
<li>整形替代枚举 4byte vs 24byte<ul>
<li>@IntDef限制类型, 只能提示不能阻止, kotlin也不支持</li>
<li>inline class</li>
</ul>
</li>
<li>图片使用<ul>
<li>选择合适分辨率, 注意原始分辨率与缩放关系<ul>
<li>xxhdpi放的匹配图片放入hdpi里面会缩放2倍, 占用更多内存</li>
</ul>
</li>
<li>bitmap使用重采样, 缩略图</li>
</ul>
</li>
<li>不用帧动画, 用代码实现</li>
<li>谨慎使用多进程, 因为进程本身分配了很多内存</li>
<li>使用NDK内存跳出JVM限制</li>
<li>5R原则<ul>
<li>Reduce, Reuse, Recycle, Refactor, Revalue</li>
</ul>
</li>
<li>图片如何缓存<ul>
<li>三级缓存</li>
<li>获取成本 缓存成本 缓存价值(命中率) 随着时间的变化</li>
<li>LRU(对应的还有LFU), 最近使用交换位置排在最后, 干掉最开始不常用的<ul>
<li>LRU内部有一些private的算法统计字段xxxCount</li>
<li>LRU线程安全, 采用短锁</li>
<li>LRU内部使用LinkedHashMap, accessOrder设置true会自动发访问过的放最后</li>
</ul>
</li>
</ul>
</li>
<li>图片占用内存大小<ul>
<li>根据dpi抽象出canvas层, 在不同设备上进行缩放</li>
<li>getByteCount应该占用内存</li>
<li>getAllocationByteCount实际占用, 当小图复用大图时</li>
<li>预先计算<ul>
<li>宽<em>高</em>像素编码位数</li>
<li>高dpi手机拿低dpi文件夹下的, 图片会变大 (scale=屏幕dpi/图片目录dpi + 0.5f)</li>
</ul>
</li>
<li>inSampleSize采样大变小, 矩阵变换小变大</li>
<li>使用svg, rgb_565, 9-patch, 不用图</li>
<li>通过assets中透明的indexed-png+rgb565强行加载index-8类型<ul>
<li>因为skia库中对于透明的565格式返回图本身</li>
<li>该类型不能通过Bitmap创建Canvas, 不能放入缩放目录</li>
<li>8.1底层开始被移除了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Android P隐藏API<ul>
<li>@hide的函数可以通过自编jar骗过编译器</li>
<li>private的只能使用反射<ul>
<li>setAccessible绕过权限控制, 还可以修改final变量</li>
</ul>
</li>
<li>API名单<ul>
<li>白名单</li>
<li>浅灰名单 反射依旧可以用</li>
<li>深灰名单<ul>
<li>Targe低于28 可以使用</li>
<li>Targe&gt;=28 反射也不能用</li>
</ul>
</li>
<li>黑名单 反射也不能用</li>
</ul>
</li>
<li>Android修改了getDeclaredMethods方法, 调用底层检查是否在白名单或者是否是No_check的Policy</li>
<li>使用FreeReflection绕过检查<ul>
<li>修改Runtime的<code>hidden_api_policy</code><ul>
<li>底层通过JavaVM拿到JavaVMExt的私有变量Runtime</li>
<li>自己写个Struct凑位数, 第二个<code>void*</code>(没虚方法少一个vp)类型就是Runtime变量</li>
<li>Runtime里面通过每4个字节(内存对齐)查找定位变量位置</li>
<li>查找<code>target_sdk_version</code>做为定位点, 将Runtime转换为PartialRuntime拿到Policy修改</li>
</ul>
</li>
<li>修改<code>hidden_api_exemptions</code>, 让程序豁免<ul>
<li>类似于第一种方法拿到Runtime, 修改HiddenApiExemptions </li>
</ul>
</li>
</ul>
</li>
<li>修改想要使用的Class, 将其ClassLoader置空 <ul>
<li><code>fn_caller_is_trusted</code>判断如果classLoader是空认为是bootClassLoader</li>
<li>可以在Java层修改, 也可以在native层修改</li>
</ul>
</li>
</ul>
</li>
<li>换肤功能<ul>
<li>Theme只支持定义的时候配置的值, 无法外部与动态加载</li>
<li>资源加载Context-&gt;Resource-&gt;AssetsManager (xml, 非xml, ResourceValue, ResourceText)</li>
<li>Resources内缓存替换<ul>
<li>替换资源有限, 只能替换缓存过的</li>
<li>Hook繁琐</li>
</ul>
</li>
<li>ResourcesWrapper包装<ul>
<li>不支持style, assets目录</li>
<li>包装起来代码量大</li>
<li>id映射可以在编译时期一致, 或者动态映射<ul>
<li>Id映射成资源name, 然后替换package再查找资源包新Id</li>
</ul>
</li>
</ul>
</li>
<li>AssertManager替换<ul>
<li>支持style, assets, 替换简洁</li>
<li>不能动态映射, 只能编译器需要对齐资源ID<ul>
<li>aapt输入主包的id映射表, public.xml</li>
<li>或者修改resource.arsc</li>
<li>如果皮肤资源少, 不能剔除public.xml, 因为剔除后位置会被后续非public资源补位, 保持资源紧凑</li>
<li>皮肤包资源需要对自己没有而主包有的资源进行占位/补位, 保证主包资源能加载进来<ul>
<li>修改AAPT, 或者直接修改resource.arsc</li>
<li>ResourceTable#applyPublicEntryOrder中间为不存在的占坑</li>
<li>如果最后有少资源还需要补位</li>
</ul>
</li>
</ul>
</li>
<li>非运行时替换<ul>
<li>编译器主包跟皮肤包差分, 应用阶段主包再与差分包合成皮肤包, 需要资源重定向</li>
<li>创建新的AssertManager只需要加入一个包即可, 因为包含所有资源</li>
</ul>
</li>
<li>反射创建并调用AssertManager#addAssetPath方法加入主包, 皮肤包, L以上要单独把Assets拿出来最后再加一次<ul>
<li>插件化是为了资源并存</li>
<li>皮肤是为了覆盖</li>
</ul>
</li>
<li>创建WrapContext<ul>
<li>attatchBaseContext的时候包装, 替换掉里面的resource, assertManager, classLoader<ul>
<li>Resource可以通过AssertManager构造</li>
</ul>
</li>
<li>getBaseContext的时候解包</li>
<li>可以使用JavaAssist改字节码插入attatch/detach方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>VirtualAPK<ul>
<li>ClassLoader双亲委派<ul>
<li>DexClassLoader (user/plugin) -&gt; PathClassLoader (context) -&gt; BootClassLoader (parent)</li>
<li>先查看是否加载, 然后由父类查找, 父类查不到再让子类查找</li>
<li>他们都继承了BaseClassLoader-&gt;ClassLoader</li>
<li>BaseClassLoader#findClass会在pathList里查找类, 而这个list就是dex的list</li>
</ul>
</li>
</ul>
</li>
<li>Tinker<ul>
<li>Patch与Apk组成新Apk并放在Dex数组最前面<ul>
<li>基于Dex的差分, DexSectionDiffAlgorithm/DexSectionPatchAlogrithm<ul>
<li>先排序再用双指针分别指向</li>
<li>如果Old指针指向小于New指针指向, 说明DEL了</li>
<li>如果Old指针指向大于New指针指向, 说明ADD了</li>
<li>如果相等, 则更新映射</li>
<li>最后Index相同内容不同, 删除ADD/DEL操作, 标识为REPLACE</li>
<li>最终把变化转换为差分后的操作</li>
</ul>
</li>
</ul>
</li>
<li>Assets直接创建新的AssetsManager<ul>
<li>基于Entry的BSDiff, 得出资源差分包</li>
<li>与旧资源组成新包, 创建新的AssetsManager加载</li>
</ul>
</li>
<li>异常熔断<ul>
<li>加载之前checkpatch</li>
<li>单一进程启动三次失败</li>
<li>十秒钟内崩溃多次</li>
<li>大量注释, 46000代码, 69%代码</li>
<li>早起监控129个</li>
</ul>
</li>
</ul>
</li>
<li>Shadow<ul>
<li>使用Hook在海外直接下架</li>
<li>由反射转入编译器字节码, 注解处理器的方案</li>
<li>Shadow属于静态代理流派, 使用了很多字节码编辑</li>
<li>插件化流派<ul>
<li>动态Hook<ul>
<li>发送的时候靠占坑Activity替换绕过AMS检测, AMS返回的时候再换回PluginActivity</li>
</ul>
</li>
<li>静态代理<ul>
<li>将Activity的启动与生命周期靠ProxyActivity代理, 然后传递给PluginActivity, Plugin寄生与Proxy不被系统获知</li>
<li>在编译的时候, 通过字节码修改, 将PluginActivity修改成寄生的ShadowActivity</li>
</ul>
</li>
</ul>
</li>
<li>Shadow结构<ul>
<li>manager (插件管理, 如版本)<ul>
<li>plugin (ShadowActivity)</li>
<li>runtime (PluginContainerAcitity, Proxy)</li>
<li>loader (实现插件加载)</li>
<li>plugin, runtime, loader可以有多组, 没各插件都有一组, manager只有一个, 他们都是单独的apk</li>
</ul>
</li>
</ul>
</li>
<li>Shadow模块<ul>
<li>DynamicPluginManager与PluginProcessService都在Host里, 前者负责加载Manger, 反射创建PluginManager实例, 而该实例负责启动跨进程通信Service</li>
<li>PluginProcessService负责启动Loader与Runtime</li>
<li>Manager通过Binder接口直接控制Loader加载对应Plugin</li>
</ul>
</li>
<li>宿主与插件ClassLoader关系<ul>
<li>ApkClassLoader负责加载Manager, Loader</li>
<li>RuntimeClassLoader负责加载Runtime, 唯一的反射将其挂在PathClassLoader之上, 为了让系统启动Proxy壳子</li>
</ul>
</li>
<li>宿主与插件资源关系<ul>
<li>分开, ShadowActivity默认注入插件资源</li>
</ul>
</li>
<li>字节码编辑<ul>
<li>Java -&gt; APT (AST-&gt;Symbol)-&gt;Class-&gt;Dex-&gt;Apk</li>
<li>Class-&gt;Transform-&gt;Dex通过Transform修改</li>
<li>源码-&gt;Javassit-&gt;ASM-&gt;字节码, 越来越抽象</li>
</ul>
</li>
<li>插件系统通信机制<ul>
<li>主从通信<ul>
<li>插件注册Callback到宿主</li>
<li>插件通过binder与宿主通信</li>
</ul>
</li>
<li>对等结构<ul>
<li>通信模块可能也是特殊的插件</li>
<li>低频用Broadcast, 高频用LocalSocket</li>
</ul>
</li>
</ul>
</li>
<li>插件更新管理<ul>
<li>差分包<ul>
<li>Dex使用DexDiff(Tinker)</li>
<li>so使用Courgette(指令差分)</li>
<li>binary使用BSDiff</li>
</ul>
</li>
<li>v2签名<ul>
<li>插件包可以不需要签名</li>
<li>自研的更新服务器可重新签名<ul>
<li>可以拿到签名   <ul>
<li>先解包重新排列再签名</li>
<li>与重排列的完整包进行差分</li>
<li>合并插件</li>
</ul>
</li>
<li>拿不到签名<ul>
<li>拿到原始包压缩级别， entrylist</li>
<li>合成新的包, 可以做到复制签名信息等同等MD5值</li>
<li>google/archive-patcher</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>工程管理<ul>
<li>Maven版本管理, 但有缓存不好用</li>
<li>所有都在一个project中, 耦合性大</li>
<li>Git Submodule, 依赖git, 手动管理更新代码</li>
<li>Gradle CompositeBuild<ul>
<li>setting.gradle里面直接<code>includeBuild=path-to-other-project</code></li>
<li>也有一些插件简化该操作</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如何开展优化<ul>
<li>目标必须明确, 从定性到定量</li>
<li>定位关键问题, 找出最大的点, 梳理优先级</li>
<li>二八定律<ul>
<li>前期20%时间解决80%问题</li>
<li>后期则相反</li>
</ul>
</li>
<li>业内对比, 造轮子成本高</li>
<li>优化需要监控</li>
<li>算法策略优化<ul>
<li>对比现有方案, 论文或者经验交流</li>
<li>不同角度问题分析, 选择痛点</li>
<li>算法能否动态下发</li>
<li>监控报表与收益</li>
</ul>
</li>
<li>工程技术优化<ul>
<li>现有方案对比 <ul>
<li>系统方案, 开源方案, 基于开源自研方案</li>
</ul>
</li>
<li>基于开源自研优化<ul>
<li>针对特定Case进行处理, 如估算+再次判断</li>
<li>与产品探讨是否接受妥协, 使用估算代替精确</li>
</ul>
</li>
<li>开源协议License<ul>
<li>GPL 使用了就必须开源</li>
<li>LGPL 不用开源</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>系统设计<ul>
<li>需求分析与系统设计</li>
<li>需求-&gt;流程-&gt;细节</li>
<li>细节<ul>
<li>IO密集还是CPU密集</li>
<li>线程如何调度, 需要多少线程</li>
<li>使用RxJava还是Koroutine</li>
<li>网络接入<ul>
<li>长连接, 高频交互, 维护复杂<ul>
<li>心跳保活, 要求高6-9s, 一般30-40s</li>
</ul>
</li>
<li>短连接, 低频交互, 查询为主<ul>
<li>短轮询, 固定时间抓取</li>
<li>长轮询, 60秒时间如果有就返回, 没有就超时让客户端重新抓</li>
</ul>
</li>
</ul>
</li>
<li>加密算法<ul>
<li>对称加密 </li>
<li>非对称加密, 耗时太长, 对数据长度有限制(RSA)</li>
<li>一般用对称加密, 用非对称加密将对称加密秘钥加密</li>
</ul>
</li>
<li>热修复与插件化<ul>
<li>是否需要立即生效</li>
<li>是否修改或者新增类</li>
<li>是否有未来做平台的打算</li>
</ul>
</li>
<li>脚本化<ul>
<li>存在很多模式化逻辑, 游戏关卡, 自定义UI体系等</li>
<li>经常调整的策略</li>
</ul>
</li>
<li>可以执行<ul>
<li>是否存在复杂平台不想管逻辑, 抽象为so库</li>
</ul>
</li>
<li>性能问题<ul>
<li>算法时间空间复杂度</li>
<li>内存峰值OOM</li>
<li>CPU占用与耗电量</li>
</ul>
</li>
<li>监控<ul>
<li>异常捕获Java+Native</li>
<li>性能监控</li>
<li>优化指标监控</li>
<li>运营数据监控</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>短视频APP<ul>
<li>网络</li>
<li>相机<ul>
<li>新API都是异步, 状态难维护</li>
</ul>
</li>
<li>滤镜<ul>
<li>下发Shader Script给OpenGL渲染</li>
</ul>
</li>
<li>播放器<ul>
<li>H265 文件小, 硬件支持差, 解码慢, 适合热点小规模</li>
<li>H264 文件大一些, 硬件支持好, 解码快, 适合大规模</li>
<li>自带播放器一般收到一组GOP才能播放, FFmpeg收到关键帧就可以</li>
</ul>
</li>
<li>封装模式调整<ul>
<li>Mpeg4 (File Type Box, Movie Box, Media Data Box)</li>
<li>将一般的顺序由ftyp-mdat-moov改为ftyp-moov-mdat, 边下边播</li>
</ul>
</li>
</ul>
</li>
<li>网络请求框架<ul>
<li>依赖简单, 接口简单, 功能纯粹</li>
<li>协议 Http, WebSocket</li>
<li>基础组件<ul>
<li>连接管理</li>
<li>线程管理</li>
</ul>
</li>
<li>拦截器, 日志系统也是类似</li>
<li>重试机制, 渐进式重试, 最大重试次数与衰减因子</li>
<li>使用注解配置请求, 类似于retrofit与spring</li>
<li>支持第三方扩展, 支持rx, suspend</li>
<li>DNS增强, HttpDnsServer, 提速防止被劫持</li>
</ul>
</li>
</ul>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/Android/">Android</a> <a class="tag tag--primary tag--small t-link" href="/tags/Note/">Note</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a
                        class="post-action-btn btn btn--disabled"
                        aria-hidden="true"
                    >
                        
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/09/01/Refresh-Refactor/"
                    data-tooltip="Refresh Refactor"
                    aria-label="下一篇: Refresh Refactor"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://talentprince.github.io/2020/09/08/Android-Points/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=http://talentprince.github.io/2020/09/08/Android-Points/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=http://talentprince.github.io/2020/09/08/Android-Points/"
                    title="分享到 Google+"
                    aria-label="分享到 Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 Prince Chen. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a
                        class="post-action-btn btn btn--disabled"
                        aria-hidden="true"
                    >
                        
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/09/01/Refresh-Refactor/"
                    data-tooltip="Refresh Refactor"
                    aria-label="下一篇: Refresh Refactor"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://talentprince.github.io/2020/09/08/Android-Points/"
                    title="分享到 Facebook"
                    aria-label="分享到 Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=http://talentprince.github.io/2020/09/08/Android-Points/"
                    title="分享到 Twitter"
                    aria-label="分享到 Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=http://talentprince.github.io/2020/09/08/Android-Points/"
                    title="分享到 Google+"
                    aria-label="分享到 Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="5">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=http://talentprince.github.io/2020/09/08/Android-Points/"
                        aria-label="分享到 Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=http://talentprince.github.io/2020/09/08/Android-Points/"
                        aria-label="分享到 Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=http://talentprince.github.io/2020/09/08/Android-Points/"
                        aria-label="分享到 Google+"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>分享到 Google+</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <h4 id="about-card-name">Prince Chen</h4>
        
            <div id="about-card-bio"><p>Xi’an B/M EE <br> 热爱生活, 关爱老婆 <br> 友情链接 <a href="https://www.cnblogs.com/mengdd/">圣骑士</a></p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Worker</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Xi&#39;an
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="/assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">没有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2014/12/15/2014-12-15-first-blog/"
                            aria-label=": First Blog"
                        >
                            <h3 class="media-heading">First Blog</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2014年12月15日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2014/12/15/2014-12-15-robolectric-in-android-studio/"
                            aria-label=": Robolectric in Android Studio"
                        >
                            <img class="media-image" src="http://res.cloudinary.com/dtn0pkdmg/image/upload/v1506326188/robolectric_f8qftj.png" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2014/12/15/2014-12-15-robolectric-in-android-studio/"
                            aria-label=": Robolectric in Android Studio"
                        >
                            <h3 class="media-heading">Robolectric in Android Studio</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2014年12月15日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><h2 id="Robolectric"><a href="#Robolectric" class="headerlink" title="Robolectric"></a>Robolectric</h2><p>Robolectric is a unit test framework that de-fangs the Android SDK jar so you can test-drive the development of your Android app. Tests run inside the JVM on your workstation in seconds. With Robolectric you can write tests like this:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test class for MyActivity @RunWith(RobolectricTestRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivityTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Test</span>   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clickingButton_shouldChangeResultsViewText</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Activity activity = Robolectric.buildActivity(MyActivity.class).create().get();</span><br><span class="line">    Button pressMeButton = (Button) activity.findViewById(R.id.press_me_button);</span><br><span class="line">    TextView results = (TextView) activity.findViewById(R.id.results_text_view);</span><br><span class="line"></span><br><span class="line">    pressMeButton.performClick();</span><br><span class="line">    String resultsText = results.getText().toString();</span><br><span class="line">    assertThat(resultsText, equalTo(<span class="string">"Testing Android Rocks!"</span>));   &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>Robolectric makes this possible by rewriting Android SDK classes as they’re being loaded and making it possible for them to run on a regular JVM. </p>
<hr></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2014/12/18/2014-12-18-activity-chang-yong-shu-xing-yu-launch-mode-zheng-jie/"
                            aria-label=": Activity LaunchMode 与 Intent Flags 揭秘"
                        >
                            <img class="media-image" src="http://res.cloudinary.com/dtn0pkdmg/image/upload/v1506326188/lunchmode_fvssls.jpg" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2014/12/18/2014-12-18-activity-chang-yong-shu-xing-yu-launch-mode-zheng-jie/"
                            aria-label=": Activity LaunchMode 与 Intent Flags 揭秘"
                        >
                            <h3 class="media-heading">Activity LaunchMode 与 Intent Flags 揭秘</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2014年12月18日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>Android Activity所涉及的四种Launch Mode与其重要的几个属性，如taskAffinity，allowTaskReparenting等，包括Intent内的各种Flag的功效，一直是为广大开发者所苦恼，网上文章众说纷纭，开发文档又及其模糊且与实际情况有一定偏差，那么今天我们就来真正的揭秘，还原事实的真相。<br></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2014/12/23/2014-12-23-joda-time-zhong-ying-ge-shi-hua-xiang-guan-wen-ti/"
                            aria-label=": Joda Time 中英格式化相关问题 for Java"
                        >
                            <img class="media-image" src="http://res.cloudinary.com/dtn0pkdmg/image/upload/v1506326187/joda_e277de.png" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2014/12/23/2014-12-23-joda-time-zhong-ying-ge-shi-hua-xiang-guan-wen-ti/"
                            aria-label=": Joda Time 中英格式化相关问题 for Java"
                        >
                            <h3 class="media-heading">Joda Time 中英格式化相关问题 for Java</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2014年12月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><h1 id="Joda-Time"><a href="#Joda-Time" class="headerlink" title="Joda Time"></a>Joda Time</h1><p>Joda-Time提供了一组Java类包用于处理包括ISO8601标准在内的date和time。可以利用它把JDK Date和Calendar类完全替换掉，而且仍然能够提供很好的集成。  </p>
<h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>Joda已经更新到2.6版本,jar包的下载可以到<a href="https://github.com/JodaOrg/joda-time/releases/tag/v2.6" target="_blank" rel="noopener">Joda Jar</a>进行下载.<br>如果使用gradle管理,可添加 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;joda-time:joda-time:2.6&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2015/01/04/2015-01-04-android-yu-inject-yi-lai-zhu-ru-de-bu-jie-zhi-yuan/"
                            aria-label=": Android 与Inject(依赖注入)的不解之缘"
                        >
                            <img class="media-image" src="http://res.cloudinary.com/dtn0pkdmg/image/upload/v1506326188/butterknife_g7rpiq.png" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2015/01/04/2015-01-04-android-yu-inject-yi-lai-zhu-ru-de-bu-jie-zhi-yuan/"
                            aria-label=": Android 与Inject(依赖注入)的不解之缘"
                        >
                            <h3 class="media-heading">Android 与Inject(依赖注入)的不解之缘</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年1月4日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p> 依赖注入(DI)<br> 有些人说Android使用依赖注入是因为很多J2EE的人带来的异域思想, 满天飞的<code>注解</code>让人莫不找头脑, 使简单的行为变得复杂, 表面简化, 实则复杂.</p>
<p> 但是在使用其一段时间后, 确实还是挺不错的. 正如其思想之精髓, 让你只关注<strong>结果</strong>,而忽略<strong>制作过程</strong>, 呵呵, 跟<code>周星驰</code>他老母恰巧相反.  </p>
<p> 那么下面就讲讲Android开发中常常的用的一些DI框架, 来简化亲们的开发流程吧.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2015/01/07/2015-01-07-android-activity-quan-ping-fang-fa-zong-jie/"
                            aria-label=": Android Activity 全屏方法总结"
                        >
                            <img class="media-image" src="http://res.cloudinary.com/dtn0pkdmg/image/upload/v1506326189/fullscreen_lkruui.jpg" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2015/01/07/2015-01-07-android-activity-quan-ping-fang-fa-zong-jie/"
                            aria-label=": Android Activity 全屏方法总结"
                        >
                            <h3 class="media-heading">Android Activity 全屏方法总结</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年1月7日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>Android版本繁多, 新API, 新Flag层出不穷, 针对于如何完美全屏, 下面做以总结.</p>
<p>所有方法只涉及<strong>代码</strong>操作, 非xml修改Activity属性所致</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2015/01/26/2015-01-26-android-zhang-hao-yu-tong-bu-xi-tong-part-one/"
                            aria-label=": Android 构建账号与同步服务 Part One"
                        >
                            <img class="media-image" src="http://res.cloudinary.com/dtn0pkdmg/image/upload/v1506326189/sync1_sbvugj.png" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2015/01/26/2015-01-26-android-zhang-hao-yu-tong-bu-xi-tong-part-one/"
                            aria-label=": Android 构建账号与同步服务 Part One"
                        >
                            <h3 class="media-heading">Android 构建账号与同步服务 Part One</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年1月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><h4 id="账号与同步"><a href="#账号与同步" class="headerlink" title="账号与同步"></a>账号与同步</h4><p>Android从<code>API Level5</code>就有了自己的同步服务, 但很少有程序使用到, 一来大多数程序不需要所谓的同步,二来很多程序自己实现了后台的同步更新. 随着Android程序开发的逐渐程序, 越来越的的程序使用到了系统提供的服务来完成<code>账号认证</code>与<code>同步更新</code>, 我们可以打开系统设置–&gt;账号进行查看, 就能看到很多应用都这么做了. 这样做有两个好处, 一来系统服务做更新同步(<code>SyncAdapter</code>)唤醒更加绿色环保, 二来实现了账号认证(<code>Authenticator</code>)还可以为其他应用提供第三方认证服务, 如大家常见的使用QQ或者微博账号登录, 由于你手机上安装的QQ与微博实现了该接口, 便可以通过开发者账号获得授权Token来做第三方认证.</p>
<p>本期博客分三部分来讲, 通过一个小应用(Part Three提供源码)来概述所有相关内容, 大体章节如下</p>
<ul>
<li><p>数据模型建立与加载 (ContentProvider LoaderManager)</p>
</li>
<li><p>更新系统建立 (SyncAdapter)</p>
</li>
<li><p>账号系统建立 (Account Authenticator)</p>
</li>
</ul>
<p>下面先来讲讲如何轻松本地数据库并完成数据到界面的加载</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2015/02/04/2015-02-04-android-gou-jian-zhang-hao-yu-tong-bu-fu-wu-part-two/"
                            aria-label=": Android 构建账号与同步服务 Part Two"
                        >
                            <img class="media-image" src="http://res.cloudinary.com/dtn0pkdmg/image/upload/v1506326189/sync2_uyvihr.jpg" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2015/02/04/2015-02-04-android-gou-jian-zhang-hao-yu-tong-bu-fu-wu-part-two/"
                            aria-label=": Android 构建账号与同步服务 Part Two"
                        >
                            <h3 class="media-heading">Android 构建账号与同步服务 Part Two</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月4日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>紧接<a href="http://talentprince.github.io/blog/2015/01/26/android-zhang-hao-yu-tong-bu-xi-tong-part-one/">上一部分</a></p>
<h4 id="更新系统的建立"><a href="#更新系统的建立" class="headerlink" title="更新系统的建立"></a>更新系统的建立</h4><p>更新系统即是所说的<a href="http://developer.android.com/training/sync-adapters/creating-sync-adapter.html" target="_blank" rel="noopener">SyncAdapter</a>, 实现了这个系统服务, 就可以利用系统的定时器对程序数据<code>ContentProvider</code>进行更新, 也可以在系统设置-&gt;账号里面控制开启或者关闭(如果<code>SyncAdapter</code>的配置文件允许的话)</p>
<p>完成这些服务的布置大概有三步</p>
<ul>
<li>创建SyncService并提供SyncAdapter的IBinder接口以便让系统调用</li>
<li>声明Sync服务, 并制定SyncAdapter的配置文件</li>
<li>生成账户启动Sync</li>
</ul></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2015/02/10/2015-02-10-android-gou-jian-zhang-hao-yu-tong-bu-fu-wu-part-three/"
                            aria-label=": Android 构建账号与同步服务 Part Three"
                        >
                            <img class="media-image" src="http://res.cloudinary.com/dtn0pkdmg/image/upload/v1506326189/sync3_trl1qb.jpg" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2015/02/10/2015-02-10-android-gou-jian-zhang-hao-yu-tong-bu-fu-wu-part-three/"
                            aria-label=": Android 构建账号与同步服务 Part Three"
                        >
                            <h3 class="media-heading">Android 构建账号与同步服务 Part Three</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月10日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><h4 id="紧接上期"><a href="#紧接上期" class="headerlink" title="紧接上期"></a>紧接<a href="http://talentprince.github.io/blog/2015/02/04/android-gou-jian-zhang-hao-yu-tong-bu-fu-wu-part-two/">上期</a></h4><h4 id="账号系统建立-Account-Authenticator"><a href="#账号系统建立-Account-Authenticator" class="headerlink" title="账号系统建立 Account Authenticator"></a>账号系统建立 Account Authenticator</h4><p>如果只需要借助系统更新服务(SyncAdapter)来做定期维护, 那么通过前两部分的介绍, 已经可以达到所预期的目标了.</p>
<p>本期话题将会解决</p>
<ul>
<li>添加账号</li>
<li>获得授权</li>
</ul>
<p>这些服务全部都是可以跨进程的操作, 完成了这些操作, 我们就可以完成像<code>QQ</code> <code>新浪微博</code> 一样的功能, 账号系统可以为第三方应用授权.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2016/01/26/2016-01-26-qing-chu-yu-ming-bai/"
                            aria-label=": 清楚与明白"
                        >
                            <img class="media-image" src="http://res.cloudinary.com/dtn0pkdmg/image/upload/v1506326189/understand_fuwgh9.jpg" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2016/01/26/2016-01-26-qing-chu-yu-ming-bai/"
                            aria-label=": 清楚与明白"
                        >
                            <h3 class="media-heading">清楚与明白</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年1月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>许久未更新, 已渐渐落草, 回顾过去一年, checklist总归是完成为多, pending为少, 但这并不意味着很多事情都得到了清楚的解决, 也有很多事情可能还需要时间去琢磨才能想的明白.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="没有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 44 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/new_cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-aps5gauztkpi1ygcutx4tgx00wcsooq0okdwjt46e3hduxfhmurq7md3aeoa.min.js"></script>
<!--SCRIPTS END-->


    



    <script src="/assets/js/moment-with-locales.js"></script>
    <script src="/assets/js/algoliasearch.js"></script>
    <script>
      var algoliaClient = algoliasearch('Z7A3XW4R2I', '12db1ad54372045549ef465881c17e743');
      var algoliaIndex = algoliaClient.initIndex('my-hexo-blog');
    </script>


    </body>
</html>
