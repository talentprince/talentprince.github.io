
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Weyoung&#39;s Blog">
    <title>标签: Android - Weyoung&#39;s Blog</title>
    <meta name="author" content="Prince Chen">
    
    
        <link rel="icon" href="http://talentprince.github.io/assets/images/favicon.ico">
    
    
        
            <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
        
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Weyoung&#39;s Blog">
<meta property="og:url" content="http://talentprince.github.io/tags/Android/index.html">
<meta property="og:site_name" content="Weyoung&#39;s Blog">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Weyoung&#39;s Blog">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-mfdqvh3ohnpramsqqbc7zbl79sacpxx7rmxse96gjjfq9veqgomv4f7jzw28.min.css">
    <!--STYLES END-->
    

    
    <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?26839bbbc9c89fbe9eb99aba7bceb413";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>


    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            Weyoung&#39;s Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打开链接: /#about"
            >
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="首页"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="分类"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="标签"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="归档"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜索"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="关于"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/mailto"
                            
                            rel="noopener"
                            title="邮箱"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/09/08/Android-Points/"
                            aria-label=": Java与Android的一些知识点"
                        >
                            Java与Android的一些知识点
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-09-08T12:25:31+08:00">
	
		    9月 08, 2020
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Android-Note/">Android Note</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>最近在看关于Java以及Android开发相关的一些知识点, 有的非常细节, 有的则很概括, 将其要点总结于此, 以供日后查阅.</p>
<ul>
<li>Char<ul>
<li>Char两个字节, 里面使用UTF-16编码</li>
<li>String的length是字符占据的长度, 而不是字符个数, python3.3以后已经改成实际个数了, 如果在微博输入一个emoj, 就会减2/3个字符</li>
<li>Java9会优化字符存储, 字母会用Byte来存字母, 而不是以前的2个字节</li>
<li>Unicode是字符集, 而不是编码</li>
<li>ASCII (Windows上简体中文用GB2312), Unicode (只规定了二进制代码, 不规定如何存, Windows上用UCS-2), UTF8 (1~4表示一个字符), UTF16 (UCS-2的父集, 2/4字节)</li>
</ul>
</li>
<li>String<ul>
<li>栈中的String, 使用<code>CONSTANT_Utf8_info</code>来存储, 长度为u2即两个字节长度, 所以最多65534个字节 (Java编译器用了&lt;而不是&lt;=, Kotlin没问题), 最终储存在方法区内的常量池</li>
<li>对于汉字, 得通过Utf8编码才知道占用字节, 这里使用了&gt;MAX所以可以存入65535/3个汉字</li>
<li>堆中的长度跟Int.Max一样, 有些虚拟机有头部保留, 可能为Max - 8</li>
</ul>
</li>
<li>方法绑定<ul>
<li>Java方法重载, 编译期就决定了, 调用声明类型</li>
<li>但是Groovy调用实际类型, 因为它先反射你的变量得到实际类型, 再调用</li>
<li>C++非虚方法只会调用声明类型方法, 虚方法只有指针调用时才触发虚绑定, C++对象本身赋值会触发赋值/复制构造, 进行裁剪, 所以无法触发绑定</li>
<li>Java方法都是虚方法, 覆写会动态绑定, 调用实际类型</li>
<li>注解扩展<ul>
<li>Target<ul>
<li>限制注解使用位置, 如METHOD, FIELD, TYPE(class/interface)等</li>
</ul>
</li>
<li>Retention<ul>
<li>约束其生命周期<ul>
<li>SOURCE 只会在代码里, 编译后丢失</li>
<li>CLASS 会保留在源码里, 但是不会加载到虚拟机, 如Override, Deprecate</li>
<li>RUNTIME 加载JVM,  运行时可通过反射用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Java泛型<ul>
<li>为了兼容性, Java用了假泛型, 类型擦出</li>
<li>基本类型无法作为泛型类型, 必须装箱拆箱, Android可以用SparseArray省去装箱</li>
<li>静态方法没法用类泛型, 因为会早于类实例化, 但可以自己定义方法泛型</li>
<li>即便有泛型, 1.5以后强转开销还在</li>
<li>Gson的TypeToken<x>(){}.getType()就是通过getGenericReturnType等方法拿到运行时泛型信息, 前提得<code>- keepattributes Signature</code>保存泛型签名<ul>
<li>TypeToken的构造为protected, 通过创建其匿名内部类调用getType方法</li>
</ul>
</x></li>
<li>Retrofit的接口定义Call<x>泛型信息也是通过类似方法</x></li>
<li>Kotlin反射原理来自最终的注解Metadata, 反射得把<code>kotlin.Metadata{*;}</code>给keep了</li>
<li>混淆扩展<ul>
<li>keep 类所有东西都保留</li>
<li>keepclassmembers 指定的成员保留, 比如方法, 类成员</li>
<li>keepclasseswithmember 保留满足条件(含某成员或者方法)的类</li>
</ul>
</li>
</ul>
</li>
<li>onActivityResult<ul>
<li>不能使用简单回调是因为activity可能重建, 回调匿名类持有的已经不是显示出来的</li>
<li>新API里通过prepareCall/launch或者直接ActivityResultRegistry注册</li>
<li>改造回调办法<ul>
<li>基于DummyFragment实现回调 <ul>
<li>将回调存在一个地方, 再次返回调用新Fragment的onResult时将回调中的activity替换成新的</li>
</ul>
</li>
<li>基于AOP<ul>
<li>AOP hook住所有activiy的onResult, callback存全局map</li>
</ul>
</li>
<li>基于Hook<ul>
<li>向ActivityThread的handler callback里加入自己的handler, 然后拿出返回的activty进行回调</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>线程停止<ul>
<li>stop/suspend被废弃了<ul>
<li>stop主要是因为stop后会释放所有线程锁, 这样其他线程就获取一些被保护的变量获取不一致的状态, 因为数据没有机会清理</li>
<li>suspend主要因为可能会造成死锁, 或者卡主其他的线程</li>
</ul>
</li>
<li>正常的中断方式<ul>
<li>boolean</li>
<li>interupt</li>
</ul>
</li>
<li>中断<ul>
<li>interrupted()<ul>
<li>静态方法, 获取当前线程,  读取后状态清空, 除非等到下一次打断信号</li>
</ul>
</li>
<li>isInterrupted()<ul>
<li>状态清除前一直是true</li>
</ul>
</li>
<li>Java层调用interrupted其实底层给<code>interrupted_</code>加锁并置位</li>
<li>除非用了sleep, 一般用boolean标志位就够了, boolean需要加上volatile, 并且比底层操作性能高</li>
</ul>
</li>
</ul>
</li>
<li>线程安全<ul>
<li>Java内存模型<ul>
<li>每一个线程都有内存副本, 更改完副本后, JMM会控制刷新主内存, 其他共享该内存的线程会去主内存拉去状态, 更新副本. 类似于线程一向线程二发消息.</li>
<li>JVM的内存会被分为, 线程栈区跟堆区.<ul>
<li>本地变量原始类型, 放在栈区, 对象类型引用在栈区, 实际对象在堆区</li>
<li>对象成员方法中的变量, 全部在栈区, 即便对象本身在堆区</li>
<li>对象的成员变量, 不管什么类型, 都在堆区</li>
<li>静态类本身与变量都会在堆区</li>
</ul>
</li>
<li>堆区的变量是多个线程共享的</li>
<li>volatile变量JMM会在写入字段后插入指令, 保证写入时其他线程也能看到更新</li>
<li>Java5以后提出happens-before模型, 保证前一个操作执行结果对后一个可见<ul>
<li>同一个线程, 顺序执行</li>
<li>解锁操作与随后的加锁操作</li>
<li>volatile的写入与其他线程的读取</li>
<li>传递性, A-hb-B, B-hb-C, 则A-hb-C</li>
</ul>
</li>
</ul>
</li>
<li>可变资源线程共享<ul>
<li>共享不可变资源</li>
<li>不共享资源<ul>
<li>函数不使用外部内存</li>
<li>ThreadLocal<ul>
<li>弱引用</li>
<li>定义全局静态final</li>
<li>避免存储大量对象<ul>
<li>因为它内部的map使用的开放定址, hash值为magicnumber的倍数</li>
</ul>
</li>
<li>用完即时移除<ul>
<li>因为它自己得线程退出才移除</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>共享可变<ul>
<li>遵循原则<ul>
<li>可见性<ul>
<li>volitale防止操作副本</li>
<li>final防止重排序</li>
<li>加锁, 锁释放时会刷新主内存</li>
</ul>
</li>
<li>原子<ul>
<li>++不是原子操作, 因为会把原值放进tmp内再加</li>
<li>通过加锁保证</li>
<li>使用CAS指令, 如Unsafe.compareAndSwapInt<ul>
<li>这个方法得通过反射Unsafe内的<code>theUnsafe</code>得到实例</li>
<li>方法swap成功返回true, 否则返回false</li>
</ul>
</li>
<li>AtomicInteger等</li>
<li>AtomicReferenceFieldUpdater</li>
</ul>
</li>
<li>禁止重排序<ul>
<li>final可以禁止重排序, 保证赋值操作在构造体内完成</li>
<li>1.5之后, volitale也能保证改造函数一定在赋值操作之前调用, 写单例必须加上volatile</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>ConcurrentHashMap<ul>
<li>HashTable是全表加锁</li>
<li>优化进程<ul>
<li>1.5 分段加锁, 必要时加锁</li>
<li>1.6 优化二次hash算法</li>
<li>1.7 段懒加载, volatile加cas</li>
<li>1.8 摒弃段, 基于hashmap实现并发</li>
</ul>
</li>
</ul>
</li>
<li>AtomicReference与AtomicReferenceFieldUpdater<ul>
<li>ARFU指向前者, 占用16字节(压缩指针)或者24个字节 </li>
<li>ARFU使用反射, 创建一个静态的用于原子赋值, 节省内存</li>
<li>AR使用更简单</li>
<li>kotlin by lazy(PUBLICATION)使用的就是ARFU</li>
</ul>
</li>
<li>异步代码<ul>
<li>异步不一定快, 如果是CPU密集型可能会更慢, 因为切换需要消耗</li>
<li>通过RxJava解决回调低于, 注意异常处理, 以及disposable的处理, 如使用AutoDisposable</li>
<li>通过Kotlin协程处理, 参考AutoDiaposable写自动cancel, 通过class AutoDisposable(view, job): Job by job, OnAttachStateChangeListener的扩展+代理, 保证不改变原本launch的返回值为Job, 且可链式调用添加Listener控制cancel</li>
</ul>
</li>
<li>CPU架构适配(native)<ul>
<li>普通开发者与sdk开发者考虑问题不同, sdk要尽可能全, 并且优化体积</li>
<li>架构分为mips64/mips(废弃了) x86_64/x86(兼容armeabi) armeabi-v7a/v8a/armeabi</li>
<li>优先去对应目录找so, 如果不全, 则加载失败, 如果一个都没提供, 则会自动找兼容</li>
<li>简单的使用v7a最通用的so</li>
<li>复杂一些把不同的架构都放在armeabi里, 通过代码来加载对应, 获取优化, 如libmath.so</li>
<li>混用限于同一种位数, 比如都是32位 (arm与v7), 如果v8a机器加载armeabi中的v8a库则会以32位加载出问题</li>
<li>太大的so库又不是启动项则可以后期增量下载</li>
<li><code>-fvisibility=hidden</code>隐藏符号表, 只公开必要, <code>-fno-exceptions -fno ftti</code>用处不大可以去掉, 不要使用iostream使用android log, 可以通过gc-sections去除无用代码, 如cflags<code>-ffunction-sections</code> <code>-fdata-sections</code>, 以及ldflags<code>-WL</code> <code>--gc-sections</code></li>
<li>也可以使用官方的splits { abi {} }分包</li>
</ul>
</li>
<li>JNI绑定<ul>
<li>分静态绑定与动态绑定<ul>
<li>全部可见占用符号表, 名字写死, 但是AS可以跳转 </li>
<li>动态绑定(env-&gt;RegisterNative)任何时候都可以触发, 可以覆盖静态绑定</li>
</ul>
</li>
<li>需要暴露的JNI方法通过<code>extern &quot;C&quot; JNIEXPORT void JNICALL</code>进行声明<ul>
<li><code>JNIEXPORT</code>设置了函数的visibility为default</li>
<li><code>JNICALL</code>在某些平台上有定义, 如Windows定义了函数如何入栈等惯例规则</li>
</ul>
</li>
</ul>
</li>
<li>JNI数据传递<ul>
<li>指针通过long传递</li>
<li>字符串传递<ul>
<li>GetStringUTFChars/ReleaseStringUTFChars<ul>
<li>const char* Modified-UTF-8字节流, <code>\0</code>编码为0xc080, 不影响c字符串结尾</li>
</ul>
</li>
<li>GetStringChars/ReleaseStringChars<ul>
<li>const jchar* 自动处理字节序转换, Java是大端, C是小端</li>
</ul>
</li>
<li>GetStringUTFRegion/GetStringRegion<ul>
<li>需要自己开辟内存, 可以控制长短</li>
</ul>
</li>
<li>GetStringCritical/ReleaseStringCritical<ul>
<li>调用会暂停Jvm Gc 与 其他JNI操作</li>
</ul>
</li>
<li>这些函数大部分第二个参数都是<code>jboolean* isCopy</code>, 告诉你是不是复制的, 虚拟机支持的话, 可以指向Java层的字符串</li>
</ul>
</li>
<li>Local Reference有个数限制, 使用完就释放, 如果个数少可以等函数调用结束自动释放</li>
<li>ByteBuffer直接在物理内存开辟 (ByteBuffer.allocateDirect), 不需要拷贝, 底层直接通过<code>GetDirectBufferAddress</code>获取指针地址, 但是需要自己处理字节序</li>
<li>尽可能让底层访问少的Java对象, 减少反射, 多使用基本类型</li>
</ul>
</li>
<li>捕获Native异常<ul>
<li><code>struct sigaction</code> handler结构体</li>
<li>调用sigaction(SIGNAL, &amp;handler, &amp;old_hanlders[SIGNAL])设置新的handler, 保存旧的</li>
<li>然后再新handler内处理不同信号的异常, 处理完再交给oldhandler处理, 类似Java</li>
<li>对于底层pthread创建的线程, 要通过<code>Jvm-&gt;AttatchCurrentThread</code>来获得新的env, 并且结束后Detach</li>
<li>如果<code>Jvm-&gt;GetEnv</code>返回JNI_OK, 则可以直接使用, 利用这两个机制创建Helper对象, 析构函数Detach简化Env的获取</li>
<li>如果Env是attach到native线程上的, 就无法拿到Java层的类了, 就需要通过底层保存的<code>classLoader</code>对象调用findClass来找到jclass</li>
<li>JNI只有GlobalRef才可以被返回, LocalRef出了函数就被回收了</li>
<li>需要使用备用栈 (<code>action.sa_flags |= SA_ONSTACK;</code>),  防止SIGSEGV栈循环溢出无法拿到</li>
<li>通过独立线程收集, 通过libcorkscrew.so(4.1-5.0),libunwind.so(5.0+)</li>
<li>通过线程对应Java崩溃堆栈, 分析问题</li>
</ul>
</li>
<li>只有C/C++才能编译so吗<ul>
<li>只要符合规定就可以运行<ul>
<li>静态绑定<ul>
<li>符号表可见</li>
<li>命名符合报名_类名_方法名</li>
<li>符号使用extern C修饰, 不能用C++</li>
</ul>
</li>
<li>动态绑定<ul>
<li>只要在JNI_OnLoad里注册就行</li>
</ul>
</li>
</ul>
</li>
<li>可选的编译成native的语言都可以<ul>
<li>Golang, Rust, Kotlin Native, Scala Native</li>
</ul>
</li>
<li>Kotlin Native<ul>
<li>@CName静态绑定native函数签名</li>
<li>JEnv*通过对象包装, CPointer<jnienvvar></jnienvvar></li>
<li>memScoped可以自动管理内存</li>
<li>动态注册需要通过<code>staticCFunction(::function)</code>拿到指针然后register</li>
</ul>
</li>
</ul>
</li>
<li>Activity启动<ul>
<li>Activity通过AMP(Proxy/Client)访问AMS<ul>
<li>解析Activity信息</li>
<li>处理启动参数</li>
<li>启动与绑定进程, 通过Zygote fork进程, 以便可以复用资源加快速度</li>
</ul>
</li>
<li>AMS通过ATP(Proxy/Client)#scheduleLaunchActivity返回Activity<ul>
<li>控制生命周期回调</li>
</ul>
</li>
<li>插件化就是在发起跟结束的时候欺上瞒下, hook发给AMS的信息, 并在返回ActivityThread后改回来</li>
<li>Bundler有缓冲区, 大小有限制, 数据必须序列化<ul>
<li>同一个进程就通过全局共享内存传大数据</li>
<li>进程间则可能需要ContentProvider之类的</li>
</ul>
</li>
<li>Activity跟Fragment都需要无参构造, 系统通过反射创建它<ul>
<li>new-&gt;attach-&gt;create-&gt;start-&gt;restoreState-&gt;postCreate-&gt;resume-&gt;makeVisible</li>
<li>attach-&gt;createPhoneWindow</li>
<li>create-&gt;installDecor (add, setContentView)</li>
<li>resume-&gt;显示 (status bar, action bar, content view)</li>
</ul>
</li>
<li>转场动画<ul>
<li>新页面显示之前, 拿到之前页面元素(共享元素)的位置信息, 应用到新元素并播放动画, 达到新页面位置</li>
</ul>
</li>
<li>跨App启动Activity<ul>
<li>sharedUserId相同, 直接通过Intent.setComponentName来启动</li>
<li>exported暴露, 公开可见</li>
<li>定义了私有的的action<ul>
<li>加上一个自定义permission, 但是必须主应用先安装, 才能申请到权限</li>
</ul>
</li>
<li>暴露的Activity如何防止其他人传未知类型导致crash, 拒绝服务漏洞<ul>
<li>trycatch包住intent.getExtra</li>
</ul>
</li>
</ul>
</li>
<li>Activity传参繁琐<ul>
<li>通过Builder设置Require以及Optional</li>
<li>在ActivityLifeCycleCallback的onActivityCreated里注入, 这是被onCreate触发的</li>
<li>onNewIntent需要单独手动处理</li>
<li>这些都可以通过注解生成器来生成<ul>
<li>需要合并父类的fields, 父类可能不需要生成builder</li>
<li>万一Activity是内部类可能需要特殊处理, 命名会有$</li>
<li>尽量少生成代码, kotlin与java之间类型的映射</li>
</ul>
</li>
<li>元编程<ul>
<li>apt (dagger, arouter), bytecode(replugin), generic, reflect, proxy(retrofit)</li>
</ul>
</li>
</ul>
</li>
<li>任意位置添加View<ul>
<li>GC回收<ul>
<li>被GCRoots持有都不会被回收<ul>
<li>虚拟机栈, 方法栈</li>
<li>静态类属性</li>
<li>常量引用</li>
<li>Native方法引用</li>
</ul>
</li>
<li>SoftRef<ul>
<li>内存快满才回收</li>
</ul>
</li>
<li>WeakRef<ul>
<li>GC一次就回收</li>
</ul>
</li>
</ul>
</li>
<li>Activity里面添加<ul>
<li>因为只有addContentView, 没有remove, 需要拿到decorview</li>
</ul>
</li>
<li>全局View<ul>
<li>通过window来添加</li>
</ul>
</li>
</ul>
</li>
<li>App右滑效果<ul>
<li>Fragment<ul>
<li>不涉及Window, View跟随手势</li>
<li>手势结束判断取消或者归位动画等</li>
</ul>
</li>
<li>Activity<ul>
<li>顶层Window背景为透明<ul>
<li>windowBackground</li>
<li>windowIsTranslucent (如果不设置, window背景会强制被改为不透明)</li>
</ul>
</li>
<li>多个Task<ul>
<li>在切task后会先显示另一个task最顶层再打开目标</li>
<li>可以通过偷偷放截图在下面障眼</li>
</ul>
</li>
<li>透明与生命周期<ul>
<li>看不到是create, 能看到是start, 顶层是resume</li>
</ul>
</li>
<li>SwipeBackActivity<ul>
<li>必须继承父类</li>
<li>必须设置windowIsTranslucent<ul>
<li>设置后下面的activity生命周期会变化, 永远会被绘制, 不会进入onStop </li>
</ul>
</li>
</ul>
</li>
<li>优化降低成本<ul>
<li>改继承为实现接口</li>
<li>通过隐藏方法在滑动的时候转换透明<ul>
<li>convertToTranslucent/convertFromTranslucent</li>
</ul>
</li>
</ul>
</li>
<li>造轮子, 或者改造现有轮子</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>非UI线程更新UI<ul>
<li>Zygote–main函数–&gt;ActivtyThread-&gt;Loop–退出后–&gt;RuntimeException</li>
<li>Handler.post-&gt;Looper.loop-&gt;MessageQueue-&gt;Handler.dispatchMessage-&gt;MainThread</li>
<li>UI变化快需要高效, 所以不能加锁, 所以必须单线程更新</li>
<li>SurfaceView可以在非UI线程绘制, lockCanvas-&gt;draw-&gt;unLockCanvasAndPost, 主线程只显示, 所以帧率高</li>
<li>GLSurfaceView是SurfaceView的子类, 有GLThread进行绘制, 死循环不断onDrawFrame</li>
<li>Handler.postDelay<ul>
<li>enqueueMessage-&gt;wake-&gt;write</li>
<li>epoll_wait-&gt;pollOnce-&gt;next(当前时间与消息队列第一条消息时间, 到了就执行, 不到就继续等)-&gt;执行消息</li>
<li>delay不靠谱, 大于Looper周期基本可靠 (&gt;50ms)</li>
<li>消息队列优化<ul>
<li>重复消息过滤</li>
<li>互斥消息取消</li>
<li>obtain复用消息, 避免太多触发gc</li>
<li>IdleHandler, glide3是用它移除ReferenceQueue监听到需要移除的弱引用</li>
<li>HandlerThread可以自己开线程穿件Looper, 内部已经Loop.prepare+loop过了</li>
</ul>
</li>
</ul>
</li>
<li>Looper与ANR<ul>
<li>Service(20s/200s), Broadcast(10s/60s), ContentProvider(10s), InputDispatch(5s)卡久了就ANR</li>
<li>AMS-&gt;ActiveService-&gt;到app启动Service, 开始后AS会发一个延迟的消息, scheduleServiceTimeoutLocked, 如果规定时间内没有执行完调用doneExecutingLocked, 就会发送handler message到UI线程, 弹出ANR对话框</li>
<li>Looper是消息循环, 里面出问题了才会有ANR</li>
<li>Looper空消息后调用epoll_wait, 等待文件消息, 不占用CPU<ul>
<li>epoll_ctl建立监听管道, rbtree</li>
<li>epoll_wait监听就绪列表, rdlist</li>
</ul>
</li>
<li>简单的Handler-Looper<ul>
<li>Handler内部用了开机后消耗了多少时间, 简单实现可以使用当前时间</li>
<li>Looper.prepare把对象存放在ThreadLocal里</li>
<li>Looper.loop启动循环调用next拿消息执行</li>
<li>MessageQueue可以用现成的DelayQueue来实现<ul>
<li>取消息阻塞类似于MessageQueue的nativePollOnce</li>
<li>不过take阻塞底层通过<code>pthread_cond_timeout</code>来实现</li>
<li>Android为何不使用DelayQueue<ul>
<li>没有合适的remove, android通过msg里的token(obj)移除</li>
<li>自己实现底层, 自由度更高</li>
<li>MessageQueue对单线程读取优化, 只有Looper现成读, 提前读取下一条消息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>避免OOM <ul>
<li>选择合适的数据结构<ul>
<li>SparseArray+ArrayMap<ul>
<li>数量少于1000, 增删不频繁就用, 扩容慢, 还能缩容</li>
<li>内存复用, </li>
</ul>
</li>
</ul>
</li>
<li>整形替代枚举 4byte vs 24byte<ul>
<li>@IntDef限制类型, 只能提示不能阻止, kotlin也不支持</li>
<li>inline class</li>
</ul>
</li>
<li>图片使用<ul>
<li>选择合适分辨率, 注意原始分辨率与缩放关系<ul>
<li>xxhdpi放的匹配图片放入hdpi里面会缩放2倍, 占用更多内存</li>
</ul>
</li>
<li>bitmap使用重采样, 缩略图</li>
</ul>
</li>
<li>不用帧动画, 用代码实现</li>
<li>谨慎使用多进程, 因为进程本身分配了很多内存</li>
<li>使用NDK内存跳出JVM限制</li>
<li>5R原则<ul>
<li>Reduce, Reuse, Recycle, Refactor, Revalue</li>
</ul>
</li>
<li>图片如何缓存<ul>
<li>三级缓存</li>
<li>获取成本 缓存成本 缓存价值(命中率) 随着时间的变化</li>
<li>LRU(对应的还有LFU), 最近使用交换位置排在最后, 干掉最开始不常用的<ul>
<li>LRU内部有一些private的算法统计字段xxxCount</li>
<li>LRU线程安全, 采用短锁</li>
<li>LRU内部使用LinkedHashMap, accessOrder设置true会自动发访问过的放最后</li>
</ul>
</li>
</ul>
</li>
<li>图片占用内存大小<ul>
<li>根据dpi抽象出canvas层, 在不同设备上进行缩放</li>
<li>getByteCount应该占用内存</li>
<li>getAllocationByteCount实际占用, 当小图复用大图时</li>
<li>预先计算<ul>
<li>宽<em>高</em>像素编码位数</li>
<li>高dpi手机拿低dpi文件夹下的, 图片会变大 (scale=屏幕dpi/图片目录dpi + 0.5f)</li>
</ul>
</li>
<li>inSampleSize采样大变小, 矩阵变换小变大</li>
<li>使用svg, rgb_565, 9-patch, 不用图</li>
<li>通过assets中透明的indexed-png+rgb565强行加载index-8类型<ul>
<li>因为skia库中对于透明的565格式返回图本身</li>
<li>该类型不能通过Bitmap创建Canvas, 不能放入缩放目录</li>
<li>8.1底层开始被移除了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Android P隐藏API<ul>
<li>@hide的函数可以通过自编jar骗过编译器</li>
<li>private的只能使用反射<ul>
<li>setAccessible绕过权限控制, 还可以修改final变量</li>
</ul>
</li>
<li>API名单<ul>
<li>白名单</li>
<li>浅灰名单 反射依旧可以用</li>
<li>深灰名单<ul>
<li>Targe低于28 可以使用</li>
<li>Targe&gt;=28 反射也不能用</li>
</ul>
</li>
<li>黑名单 反射也不能用</li>
</ul>
</li>
<li>Android修改了getDeclaredMethods方法, 调用底层检查是否在白名单或者是否是No_check的Policy</li>
<li>使用FreeReflection绕过检查<ul>
<li>修改Runtime的<code>hidden_api_policy</code><ul>
<li>底层通过JavaVM拿到JavaVMExt的私有变量Runtime</li>
<li>自己写个Struct凑位数, 第二个<code>void*</code>(没虚方法少一个vp)类型就是Runtime变量</li>
<li>Runtime里面通过每4个字节(内存对齐)查找定位变量位置</li>
<li>查找<code>target_sdk_version</code>做为定位点, 将Runtime转换为PartialRuntime拿到Policy修改</li>
</ul>
</li>
<li>修改<code>hidden_api_exemptions</code>, 让程序豁免<ul>
<li>类似于第一种方法拿到Runtime, 修改HiddenApiExemptions </li>
</ul>
</li>
</ul>
</li>
<li>修改想要使用的Class, 将其ClassLoader置空 <ul>
<li><code>fn_caller_is_trusted</code>判断如果classLoader是空认为是bootClassLoader</li>
<li>可以在Java层修改, 也可以在native层修改</li>
</ul>
</li>
</ul>
</li>
<li>换肤功能<ul>
<li>Theme只支持定义的时候配置的值, 无法外部与动态加载</li>
<li>资源加载Context-&gt;Resource-&gt;AssetsManager (xml, 非xml, ResourceValue, ResourceText)</li>
<li>Resources内缓存替换<ul>
<li>替换资源有限, 只能替换缓存过的</li>
<li>Hook繁琐</li>
</ul>
</li>
<li>ResourcesWrapper包装<ul>
<li>不支持style, assets目录</li>
<li>包装起来代码量大</li>
<li>id映射可以在编译时期一致, 或者动态映射<ul>
<li>Id映射成资源name, 然后替换package再查找资源包新Id</li>
</ul>
</li>
</ul>
</li>
<li>AssertManager替换<ul>
<li>支持style, assets, 替换简洁</li>
<li>不能动态映射, 只能编译器需要对齐资源ID<ul>
<li>aapt输入主包的id映射表, public.xml</li>
<li>或者修改resource.arsc</li>
<li>如果皮肤资源少, 不能剔除public.xml, 因为剔除后位置会被后续非public资源补位, 保持资源紧凑</li>
<li>皮肤包资源需要对自己没有而主包有的资源进行占位/补位, 保证主包资源能加载进来<ul>
<li>修改AAPT, 或者直接修改resource.arsc</li>
<li>ResourceTable#applyPublicEntryOrder中间为不存在的占坑</li>
<li>如果最后有少资源还需要补位</li>
</ul>
</li>
</ul>
</li>
<li>非运行时替换<ul>
<li>编译器主包跟皮肤包差分, 应用阶段主包再与差分包合成皮肤包, 需要资源重定向</li>
<li>创建新的AssertManager只需要加入一个包即可, 因为包含所有资源</li>
</ul>
</li>
<li>反射创建并调用AssertManager#addAssetPath方法加入主包, 皮肤包, L以上要单独把Assets拿出来最后再加一次<ul>
<li>插件化是为了资源并存</li>
<li>皮肤是为了覆盖</li>
</ul>
</li>
<li>创建WrapContext<ul>
<li>attatchBaseContext的时候包装, 替换掉里面的resource, assertManager, classLoader<ul>
<li>Resource可以通过AssertManager构造</li>
</ul>
</li>
<li>getBaseContext的时候解包</li>
<li>可以使用JavaAssist改字节码插入attatch/detach方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>VirtualAPK<ul>
<li>ClassLoader双亲委派<ul>
<li>DexClassLoader (user/plugin) -&gt; PathClassLoader (context) -&gt; BootClassLoader (parent)</li>
<li>先查看是否加载, 然后由父类查找, 父类查不到再让子类查找</li>
<li>他们都继承了BaseClassLoader-&gt;ClassLoader</li>
<li>BaseClassLoader#findClass会在pathList里查找类, 而这个list就是dex的list</li>
</ul>
</li>
</ul>
</li>
<li>Tinker<ul>
<li>Patch与Apk组成新Apk并放在Dex数组最前面<ul>
<li>基于Dex的差分, DexSectionDiffAlgorithm/DexSectionPatchAlogrithm<ul>
<li>先排序再用双指针分别指向</li>
<li>如果Old指针指向小于New指针指向, 说明DEL了</li>
<li>如果Old指针指向大于New指针指向, 说明ADD了</li>
<li>如果相等, 则更新映射</li>
<li>最后Index相同内容不同, 删除ADD/DEL操作, 标识为REPLACE</li>
<li>最终把变化转换为差分后的操作</li>
</ul>
</li>
</ul>
</li>
<li>Assets直接创建新的AssetsManager<ul>
<li>基于Entry的BSDiff, 得出资源差分包</li>
<li>与旧资源组成新包, 创建新的AssetsManager加载</li>
</ul>
</li>
<li>异常熔断<ul>
<li>加载之前checkpatch</li>
<li>单一进程启动三次失败</li>
<li>十秒钟内崩溃多次</li>
<li>大量注释, 46000代码, 69%代码</li>
<li>早起监控129个</li>
</ul>
</li>
</ul>
</li>
<li>Shadow<ul>
<li>使用Hook在海外直接下架</li>
<li>由反射转入编译器字节码, 注解处理器的方案</li>
<li>Shadow属于静态代理流派, 使用了很多字节码编辑</li>
<li>插件化流派<ul>
<li>动态Hook<ul>
<li>发送的时候靠占坑Activity替换绕过AMS检测, AMS返回的时候再换回PluginActivity</li>
</ul>
</li>
<li>静态代理<ul>
<li>将Activity的启动与生命周期靠ProxyActivity代理, 然后传递给PluginActivity, Plugin寄生与Proxy不被系统获知</li>
<li>在编译的时候, 通过字节码修改, 将PluginActivity修改成寄生的ShadowActivity</li>
</ul>
</li>
</ul>
</li>
<li>Shadow结构<ul>
<li>manager (插件管理, 如版本)<ul>
<li>plugin (ShadowActivity)</li>
<li>runtime (PluginContainerAcitity, Proxy)</li>
<li>loader (实现插件加载)</li>
<li>plugin, runtime, loader可以有多组, 没各插件都有一组, manager只有一个, 他们都是单独的apk</li>
</ul>
</li>
</ul>
</li>
<li>Shadow模块<ul>
<li>DynamicPluginManager与PluginProcessService都在Host里, 前者负责加载Manger, 反射创建PluginManager实例, 而该实例负责启动跨进程通信Service</li>
<li>PluginProcessService负责启动Loader与Runtime</li>
<li>Manager通过Binder接口直接控制Loader加载对应Plugin</li>
</ul>
</li>
<li>宿主与插件ClassLoader关系<ul>
<li>ApkClassLoader负责加载Manager, Loader</li>
<li>RuntimeClassLoader负责加载Runtime, 唯一的反射将其挂在PathClassLoader之上, 为了让系统启动Proxy壳子</li>
</ul>
</li>
<li>宿主与插件资源关系<ul>
<li>分开, ShadowActivity默认注入插件资源</li>
</ul>
</li>
<li>字节码编辑<ul>
<li>Java -&gt; APT (AST-&gt;Symbol)-&gt;Class-&gt;Dex-&gt;Apk</li>
<li>Class-&gt;Transform-&gt;Dex通过Transform修改</li>
<li>源码-&gt;Javassit-&gt;ASM-&gt;字节码, 越来越抽象</li>
</ul>
</li>
<li>插件系统通信机制<ul>
<li>主从通信<ul>
<li>插件注册Callback到宿主</li>
<li>插件通过binder与宿主通信</li>
</ul>
</li>
<li>对等结构<ul>
<li>通信模块可能也是特殊的插件</li>
<li>低频用Broadcast, 高频用LocalSocket</li>
</ul>
</li>
</ul>
</li>
<li>插件更新管理<ul>
<li>差分包<ul>
<li>Dex使用DexDiff(Tinker)</li>
<li>so使用Courgette(指令差分)</li>
<li>binary使用BSDiff</li>
</ul>
</li>
<li>v2签名<ul>
<li>插件包可以不需要签名</li>
<li>自研的更新服务器可重新签名<ul>
<li>可以拿到签名   <ul>
<li>先解包重新排列再签名</li>
<li>与重排列的完整包进行差分</li>
<li>合并插件</li>
</ul>
</li>
<li>拿不到签名<ul>
<li>拿到原始包压缩级别， entrylist</li>
<li>合成新的包, 可以做到复制签名信息等同等MD5值</li>
<li>google/archive-patcher</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>工程管理<ul>
<li>Maven版本管理, 但有缓存不好用</li>
<li>所有都在一个project中, 耦合性大</li>
<li>Git Submodule, 依赖git, 手动管理更新代码</li>
<li>Gradle CompositeBuild<ul>
<li>setting.gradle里面直接<code>includeBuild=path-to-other-project</code></li>
<li>也有一些插件简化该操作</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如何开展优化<ul>
<li>目标必须明确, 从定性到定量</li>
<li>定位关键问题, 找出最大的点, 梳理优先级</li>
<li>二八定律<ul>
<li>前期20%时间解决80%问题</li>
<li>后期则相反</li>
</ul>
</li>
<li>业内对比, 造轮子成本高</li>
<li>优化需要监控</li>
<li>算法策略优化<ul>
<li>对比现有方案, 论文或者经验交流</li>
<li>不同角度问题分析, 选择痛点</li>
<li>算法能否动态下发</li>
<li>监控报表与收益</li>
</ul>
</li>
<li>工程技术优化<ul>
<li>现有方案对比 <ul>
<li>系统方案, 开源方案, 基于开源自研方案</li>
</ul>
</li>
<li>基于开源自研优化<ul>
<li>针对特定Case进行处理, 如估算+再次判断</li>
<li>与产品探讨是否接受妥协, 使用估算代替精确</li>
</ul>
</li>
<li>开源协议License<ul>
<li>GPL 使用了就必须开源</li>
<li>LGPL 不用开源</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>系统设计<ul>
<li>需求分析与系统设计</li>
<li>需求-&gt;流程-&gt;细节</li>
<li>细节<ul>
<li>IO密集还是CPU密集</li>
<li>线程如何调度, 需要多少线程</li>
<li>使用RxJava还是Koroutine</li>
<li>网络接入<ul>
<li>长连接, 高频交互, 维护复杂<ul>
<li>心跳保活, 要求高6-9s, 一般30-40s</li>
</ul>
</li>
<li>短连接, 低频交互, 查询为主<ul>
<li>短轮询, 固定时间抓取</li>
<li>长轮询, 60秒时间如果有就返回, 没有就超时让客户端重新抓</li>
</ul>
</li>
</ul>
</li>
<li>加密算法<ul>
<li>对称加密 </li>
<li>非对称加密, 耗时太长, 对数据长度有限制(RSA)</li>
<li>一般用对称加密, 用非对称加密将对称加密秘钥加密</li>
</ul>
</li>
<li>热修复与插件化<ul>
<li>是否需要立即生效</li>
<li>是否修改或者新增类</li>
<li>是否有未来做平台的打算</li>
</ul>
</li>
<li>脚本化<ul>
<li>存在很多模式化逻辑, 游戏关卡, 自定义UI体系等</li>
<li>经常调整的策略</li>
</ul>
</li>
<li>可以执行<ul>
<li>是否存在复杂平台不想管逻辑, 抽象为so库</li>
</ul>
</li>
<li>性能问题<ul>
<li>算法时间空间复杂度</li>
<li>内存峰值OOM</li>
<li>CPU占用与耗电量</li>
</ul>
</li>
<li>监控<ul>
<li>异常捕获Java+Native</li>
<li>性能监控</li>
<li>优化指标监控</li>
<li>运营数据监控</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>短视频APP<ul>
<li>网络</li>
<li>相机<ul>
<li>新API都是异步, 状态难维护</li>
</ul>
</li>
<li>滤镜<ul>
<li>下发Shader Script给OpenGL渲染</li>
</ul>
</li>
<li>播放器<ul>
<li>H265 文件小, 硬件支持差, 解码慢, 适合热点小规模</li>
<li>H264 文件大一些, 硬件支持好, 解码快, 适合大规模</li>
<li>自带播放器一般收到一组GOP才能播放, FFmpeg收到关键帧就可以</li>
</ul>
</li>
<li>封装模式调整<ul>
<li>Mpeg4 (File Type Box, Movie Box, Media Data Box)</li>
<li>将一般的顺序由ftyp-mdat-moov改为ftyp-moov-mdat, 边下边播</li>
</ul>
</li>
</ul>
</li>
<li>网络请求框架<ul>
<li>依赖简单, 接口简单, 功能纯粹</li>
<li>协议 Http, WebSocket</li>
<li>基础组件<ul>
<li>连接管理</li>
<li>线程管理</li>
</ul>
</li>
<li>拦截器, 日志系统也是类似</li>
<li>重试机制, 渐进式重试, 最大重试次数与衰减因子</li>
<li>使用注解配置请求, 类似于retrofit与spring</li>
<li>支持第三方扩展, 支持rx, suspend</li>
<li>DNS增强, HttpDnsServer, 提速防止被劫持</li>
</ul>
</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/09/08/Android-Points/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
            <a
                href="/2020/09/08/Android-Points/"
                aria-label=": Java与Android的一些知识点"
            >
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="https://res.cloudinary.com/dtn0pkdmg/image/upload/v1599539474/note_zuxqpg.jpg"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/07/30/Android-Performance-Enhance/"
                            aria-label=": Android性能优化总结"
                        >
                            Android性能优化总结
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-07-30T18:28:53+08:00">
	
		    7月 30, 2020
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Android-Note/">Android Note</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>最近断断续续的看完了Android性能优化相关的一个系列视频, 感觉总结的非常不错, 很多地方都有深受启发.<br>期间也穿插着停下来研究了一些相关的技术,框架,与工具, 并做了一些小笔记, 现将整个体系总结下来, 以便翻阅与温习.</p>
                    
                        <a
                            href="/2020/07/30/Android-Performance-Enhance/"
                            class="postShorten-excerpt_link link"
                            aria-label=": Android性能优化总结"
                        >
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
            <a
                href="/2020/07/30/Android-Performance-Enhance/"
                aria-label=": Android性能优化总结"
            >
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="https://res.cloudinary.com/dtn0pkdmg/image/upload/v1596105259/performance_sjv0xm.png"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/02/12/Deep-explore-kotlin-coroutines/"
                            aria-label=": 探究高级的Kotlin Coroutines知识"
                        >
                            探究高级的Kotlin Coroutines知识
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-02-12T09:14:52+08:00">
	
		    2月 12, 2019
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>要说程序如何从简单走向复杂, 线程的引入必然功不可没, 当我们期望利用线程来提升程序效能的过程中, 处理线程的方式也发生了从原始时代向科技时代发生了一步一步的进化, 正如我们的Elisha大神所著文章<a href="https://medium.com/@elye.project/the-evolution-of-android-network-access-1e199fc6e9a2" target="_blank" rel="noopener">The Evolution of Android Network Access</a>中所讲到的, Future可能会是Kotlin Coroutines的时代.</p>
                    
                        <a
                            href="/2019/02/12/Deep-explore-kotlin-coroutines/"
                            class="postShorten-excerpt_link link"
                            aria-label=": 探究高级的Kotlin Coroutines知识"
                        >
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
            <a
                href="/2019/02/12/Deep-explore-kotlin-coroutines/"
                aria-label=": 探究高级的Kotlin Coroutines知识"
            >
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="https://res.cloudinary.com/dtn0pkdmg/image/upload/v1549934323/Coroutines_jnzotc.jpg"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/11/08/Flutter-self-learning-notes-as-an-android-developer/"
                            aria-label=": Android程序员的Flutter学习笔记"
                        >
                            Android程序员的Flutter学习笔记
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-11-08T11:17:10+08:00">
	
		    11月 08, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Flutter/">Flutter</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>作为忠实与较资深的Android汪, 最近抽出了一些时间研究了一下Google的亲儿子Flutter, 尚属皮毛, 只能算是个简单的记录吧.</p>
<p>Google自2017年第一次提出Flutter, 到2018年Beta, 再加之RN的各种风波与问题, 使得Flutter的热度不断上升, 国内不少公司都公布Flutter在其产品中的应用, 如美团, 闲鱼等.</p>
                    
                        <a
                            href="/2018/11/08/Flutter-self-learning-notes-as-an-android-developer/"
                            class="postShorten-excerpt_link link"
                            aria-label=": Android程序员的Flutter学习笔记"
                        >
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
            <a
                href="/2018/11/08/Flutter-self-learning-notes-as-an-android-developer/"
                aria-label=": Android程序员的Flutter学习笔记"
            >
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="https://res.cloudinary.com/dtn0pkdmg/image/upload/v1541647409/flutter_logo_yum7hs.png"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/30/How-to-correctly-use-android-espresso-to-test-your-UI/"
                            aria-label=": 如何正确使用Espresso来测试你的Android程序"
                        >
                            如何正确使用Espresso来测试你的Android程序
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-30T10:12:48+08:00">
	
		    9月 30, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>UI测试在Android平台上一直都是一个令人头痛的事情, 由于大家平时用的很少, 加之很多文档的缺失, 如果很多东西从头摸索,势必踩坑无数.</p>
<p>自Android24正式淘汰掉了<a href="https://developer.android.com/reference/android/test/InstrumentationTestCase" target="_blank" rel="noopener">InstrumentationTestCase</a>(位于android.test包), 推出<a href="https://developer.android.com/training/testing/espresso/" target="_blank" rel="noopener">Espresso</a>(位于android.support.test包), Google一直致力于降低UI测试的门槛.</p>
<p>了解测试金字塔的同学可能知道,UI测试属于功能测试(Functional Test), 或者按照其他的划分也属于集成测试(Integration Test), Google推出了<a href="https://developer.android.com/training/testing/ui-automator" target="_blank" rel="noopener">UIAutomator</a>与<a href="https://developer.android.com/training/testing/espresso" target="_blank" rel="noopener">Espresso</a>来分别处理跨App间的测试(<a href="https://zh.wikipedia.org/wiki/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">黑盒测试</a>)以及App内的测试(<a href="https://zh.wikipedia.org/wiki/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">白盒测试</a>).</p>
<p>测试步骤类似,分为:</p>
<ul>
<li>查找元素</li>
<li>触发行为</li>
<li>检测结果</li>
</ul>
<p>本文分为三部分, 第一部分简单介绍如何使用Espresso, 第二部分分析如何处理诸如异步, 依赖注入, 程序结构对UI测试的影响以及提供解决办法, 第三部分提供源码以及一些Reference的地址.</p>
                    
                        <a
                            href="/2018/09/30/How-to-correctly-use-android-espresso-to-test-your-UI/"
                            class="postShorten-excerpt_link link"
                            aria-label=": 如何正确使用Espresso来测试你的Android程序"
                        >
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
            <a
                href="/2018/09/30/How-to-correctly-use-android-espresso-to-test-your-UI/"
                aria-label=": 如何正确使用Espresso来测试你的Android程序"
            >
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="https://res.cloudinary.com/dtn0pkdmg/image/upload/v1538273751/espresso_wsc7bk.jpg"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/04/02/From-RxJava-to-RxJava2/"
                            aria-label=": 如何从RxJava升级到RxJava2"
                        >
                            如何从RxJava升级到RxJava2
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-02T10:29:31+08:00">
	
		    4月 02, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>RxJava2已经推出有一年半的时间,由于之前RxJava已经在现有项目中广泛使用,而RxJava2在除了很多命名外并没有太多革新,所以相信有很多人跟我一样都还没有升级.</p>
<p>随着老版本渐渐的失去维护,更重要的是有一定时间允许我来做这个迁移,其实弃老从新一直都是程序员的喜好.</p>
<p>虽然官方提供了<a href="https://github.com/ReactiveX/RxJava/wiki/What&#39;s-different-in-2.0" target="_blank" rel="noopener">文档</a>详尽的介绍了区别,但是文章之长,可能很多人读不下去,却有想快速的迁移过来,我将除了命名改变之外有用的地方总结成了几点,供大家参考.</p>
                    
                        <a
                            href="/2018/04/02/From-RxJava-to-RxJava2/"
                            class="postShorten-excerpt_link link"
                            aria-label=": 如何从RxJava升级到RxJava2"
                        >
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
            <a
                href="/2018/04/02/From-RxJava-to-RxJava2/"
                aria-label=": 如何从RxJava升级到RxJava2"
            >
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="http://res.cloudinary.com/dtn0pkdmg/image/upload/v1522636507/rxjava2_dgnvie.jpg"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/04/01/Android-Weekly-Issue-290/"
                            aria-label=": Android Weekly Issue #290"
                        >
                            Android Weekly Issue #290
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-01T10:37:28+08:00">
	
		    4月 01, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Android-Weekly/">Android Weekly</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>December 31st, 2017</p>
<h2 id="Android-Weekly-Issue-290"><a href="#Android-Weekly-Issue-290" class="headerlink" title="Android Weekly Issue #290"></a><a href="http://androidweekly.net/issues/issue-290" target="_blank" rel="noopener">Android Weekly Issue #290</a></h2><p>本期内容包括介绍Kotlin逆变协变的一篇(虽然没说清楚,但我补充了),IoT相关制作MIDI Controler的Part two,以及比较炫酷的Shared Element Reveal动画,以及LiveData与DataBinding相关,Kotlin扩展Fragment/Activity方法做测试,Rx逐条打Log等等.</p>
                    
                        <a
                            href="/2018/04/01/Android-Weekly-Issue-290/"
                            class="postShorten-excerpt_link link"
                            aria-label=": Android Weekly Issue #290"
                        >
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
            <a
                href="/2018/04/01/Android-Weekly-Issue-290/"
                aria-label=": Android Weekly Issue #290"
            >
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="http://res.cloudinary.com/dtn0pkdmg/image/upload/v1522636507/290_udxyq8.jpg"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2017/09/30/Advanced-Dagger2-Skills/"
                            aria-label=": Dagger2进阶必备技能"
                        >
                            Dagger2进阶必备技能
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-09-30T15:03:42+08:00">
	
		    9月 30, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>之前拙荆有一篇文章介绍Dagger2的<a href="http://www.cnblogs.com/mengdd/p/5613889.html" target="_blank" rel="noopener">初步知识</a>, 本篇文章主要介绍Dagger2的进阶知识点.</p>
<p>主要包含的内有有</p>
<ul>
<li>@Binds与@Provides的使用</li>
<li>Provider<t>与Lazy<t>的使用</t></t></li>
<li>依赖与包含</li>
<li>Dagger.Android</li>
</ul>
                    
                        <a
                            href="/2017/09/30/Advanced-Dagger2-Skills/"
                            class="postShorten-excerpt_link link"
                            aria-label=": Dagger2进阶必备技能"
                        >
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2017/09/30/Android-Weekly-Issue-276/"
                            aria-label=": Android Weekly Issue #276"
                        >
                            Android Weekly Issue #276
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-09-30T14:00:48+08:00">
	
		    9月 30, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Android-Weekly/">Android Weekly</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>September 24th, 2017</p>
<h2 id="Android-Weekly-Issue-276"><a href="#Android-Weekly-Issue-276" class="headerlink" title="Android Weekly Issue #276"></a><a href="http://androidweekly.net/issues/issue-276" target="_blank" rel="noopener">Android Weekly Issue #276</a></h2><p>本期内容包括LifeCycle与Architecture的相关文章,以及新的JSON解析库Moshi的介绍,还有<br>ConstraintLayout的一些特性,还包括一个加速你Debug的小技巧,喜欢数据库的也不容错过,有介绍Realm,Room,ObjectBox,Anko SQLite等等的对比与分析的文章哦.</p>
                    
                        <a
                            href="/2017/09/30/Android-Weekly-Issue-276/"
                            class="postShorten-excerpt_link link"
                            aria-label=": Android Weekly Issue #276"
                        >
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
            <a
                href="/2017/09/30/Android-Weekly-Issue-276/"
                aria-label=": Android Weekly Issue #276"
            >
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="http://res.cloudinary.com/dtn0pkdmg/image/upload/v1506751408/download_rarkl4.jpg"/>
                </div>
            </a>
            
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2017/09/27/Android-Weekly-Issue-275/"
                            aria-label=": Android Weekly Issue #275"
                        >
                            Android Weekly Issue #275
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-09-27T09:00:14+08:00">
	
		    9月 27, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Android-Weekly/">Android Weekly</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>September 17, 2017</p>
<h2 id="Android-Weekly-Issue-275"><a href="#Android-Weekly-Issue-275" class="headerlink" title="Android Weekly Issue #275"></a><a href="http://androidweekly.net/issues/issue-275" target="_blank" rel="noopener">Android Weekly Issue #275</a></h2><p>本期内容包括给Google Map实现一个Marker Adapter, 如何更好的让Kotlin类可测试, MVI的优势 Google的Room与Paging Library相关文章, 以及Realm如何实现React, 还有比较冷门的AsyncListUtil如何使用的介绍哦.</p>
                    
                        <a
                            href="/2017/09/27/Android-Weekly-Issue-275/"
                            class="postShorten-excerpt_link link"
                            aria-label=": Android Weekly Issue #275"
                        >
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
            <a
                href="/2017/09/27/Android-Weekly-Issue-275/"
                aria-label=": Android Weekly Issue #275"
            >
                <div class="postShorten-thumbnailimg">
                    <img alt="" src="http://res.cloudinary.com/dtn0pkdmg/image/upload/v1506482907/275_zyahvm.jpg"/>
                </div>
            </a>
            
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">第 1 页 共 1 页</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 Prince Chen. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <h4 id="about-card-name">Prince Chen</h4>
        
            <div id="about-card-bio"><p>Xi’an B/M EE <br> 热爱生活, 关爱老婆 <br> 友情链接 <a href="https://www.cnblogs.com/mengdd/">圣骑士</a></p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Worker</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Xi&#39;an
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="/assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">没有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2014/12/15/2014-12-15-first-blog/"
                            aria-label=": First Blog"
                        >
                            <h3 class="media-heading">First Blog</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2014年12月15日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2014/12/15/2014-12-15-robolectric-in-android-studio/"
                            aria-label=": Robolectric in Android Studio"
                        >
                            <img class="media-image" src="http://res.cloudinary.com/dtn0pkdmg/image/upload/v1506326188/robolectric_f8qftj.png" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2014/12/15/2014-12-15-robolectric-in-android-studio/"
                            aria-label=": Robolectric in Android Studio"
                        >
                            <h3 class="media-heading">Robolectric in Android Studio</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2014年12月15日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><h2 id="Robolectric"><a href="#Robolectric" class="headerlink" title="Robolectric"></a>Robolectric</h2><p>Robolectric is a unit test framework that de-fangs the Android SDK jar so you can test-drive the development of your Android app. Tests run inside the JVM on your workstation in seconds. With Robolectric you can write tests like this:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test class for MyActivity @RunWith(RobolectricTestRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivityTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Test</span>   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clickingButton_shouldChangeResultsViewText</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Activity activity = Robolectric.buildActivity(MyActivity.class).create().get();</span><br><span class="line">    Button pressMeButton = (Button) activity.findViewById(R.id.press_me_button);</span><br><span class="line">    TextView results = (TextView) activity.findViewById(R.id.results_text_view);</span><br><span class="line"></span><br><span class="line">    pressMeButton.performClick();</span><br><span class="line">    String resultsText = results.getText().toString();</span><br><span class="line">    assertThat(resultsText, equalTo(<span class="string">"Testing Android Rocks!"</span>));   &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>Robolectric makes this possible by rewriting Android SDK classes as they’re being loaded and making it possible for them to run on a regular JVM. </p>
<hr></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2014/12/18/2014-12-18-activity-chang-yong-shu-xing-yu-launch-mode-zheng-jie/"
                            aria-label=": Activity LaunchMode 与 Intent Flags 揭秘"
                        >
                            <img class="media-image" src="http://res.cloudinary.com/dtn0pkdmg/image/upload/v1506326188/lunchmode_fvssls.jpg" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2014/12/18/2014-12-18-activity-chang-yong-shu-xing-yu-launch-mode-zheng-jie/"
                            aria-label=": Activity LaunchMode 与 Intent Flags 揭秘"
                        >
                            <h3 class="media-heading">Activity LaunchMode 与 Intent Flags 揭秘</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2014年12月18日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>Android Activity所涉及的四种Launch Mode与其重要的几个属性，如taskAffinity，allowTaskReparenting等，包括Intent内的各种Flag的功效，一直是为广大开发者所苦恼，网上文章众说纷纭，开发文档又及其模糊且与实际情况有一定偏差，那么今天我们就来真正的揭秘，还原事实的真相。<br></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2014/12/23/2014-12-23-joda-time-zhong-ying-ge-shi-hua-xiang-guan-wen-ti/"
                            aria-label=": Joda Time 中英格式化相关问题 for Java"
                        >
                            <img class="media-image" src="http://res.cloudinary.com/dtn0pkdmg/image/upload/v1506326187/joda_e277de.png" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2014/12/23/2014-12-23-joda-time-zhong-ying-ge-shi-hua-xiang-guan-wen-ti/"
                            aria-label=": Joda Time 中英格式化相关问题 for Java"
                        >
                            <h3 class="media-heading">Joda Time 中英格式化相关问题 for Java</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2014年12月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><h1 id="Joda-Time"><a href="#Joda-Time" class="headerlink" title="Joda Time"></a>Joda Time</h1><p>Joda-Time提供了一组Java类包用于处理包括ISO8601标准在内的date和time。可以利用它把JDK Date和Calendar类完全替换掉，而且仍然能够提供很好的集成。  </p>
<h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>Joda已经更新到2.6版本,jar包的下载可以到<a href="https://github.com/JodaOrg/joda-time/releases/tag/v2.6" target="_blank" rel="noopener">Joda Jar</a>进行下载.<br>如果使用gradle管理,可添加 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;joda-time:joda-time:2.6&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2015/01/04/2015-01-04-android-yu-inject-yi-lai-zhu-ru-de-bu-jie-zhi-yuan/"
                            aria-label=": Android 与Inject(依赖注入)的不解之缘"
                        >
                            <img class="media-image" src="http://res.cloudinary.com/dtn0pkdmg/image/upload/v1506326188/butterknife_g7rpiq.png" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2015/01/04/2015-01-04-android-yu-inject-yi-lai-zhu-ru-de-bu-jie-zhi-yuan/"
                            aria-label=": Android 与Inject(依赖注入)的不解之缘"
                        >
                            <h3 class="media-heading">Android 与Inject(依赖注入)的不解之缘</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年1月4日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p> 依赖注入(DI)<br> 有些人说Android使用依赖注入是因为很多J2EE的人带来的异域思想, 满天飞的<code>注解</code>让人莫不找头脑, 使简单的行为变得复杂, 表面简化, 实则复杂.</p>
<p> 但是在使用其一段时间后, 确实还是挺不错的. 正如其思想之精髓, 让你只关注<strong>结果</strong>,而忽略<strong>制作过程</strong>, 呵呵, 跟<code>周星驰</code>他老母恰巧相反.  </p>
<p> 那么下面就讲讲Android开发中常常的用的一些DI框架, 来简化亲们的开发流程吧.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2015/01/07/2015-01-07-android-activity-quan-ping-fang-fa-zong-jie/"
                            aria-label=": Android Activity 全屏方法总结"
                        >
                            <img class="media-image" src="http://res.cloudinary.com/dtn0pkdmg/image/upload/v1506326189/fullscreen_lkruui.jpg" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2015/01/07/2015-01-07-android-activity-quan-ping-fang-fa-zong-jie/"
                            aria-label=": Android Activity 全屏方法总结"
                        >
                            <h3 class="media-heading">Android Activity 全屏方法总结</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年1月7日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>Android版本繁多, 新API, 新Flag层出不穷, 针对于如何完美全屏, 下面做以总结.</p>
<p>所有方法只涉及<strong>代码</strong>操作, 非xml修改Activity属性所致</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2015/01/26/2015-01-26-android-zhang-hao-yu-tong-bu-xi-tong-part-one/"
                            aria-label=": Android 构建账号与同步服务 Part One"
                        >
                            <img class="media-image" src="http://res.cloudinary.com/dtn0pkdmg/image/upload/v1506326189/sync1_sbvugj.png" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2015/01/26/2015-01-26-android-zhang-hao-yu-tong-bu-xi-tong-part-one/"
                            aria-label=": Android 构建账号与同步服务 Part One"
                        >
                            <h3 class="media-heading">Android 构建账号与同步服务 Part One</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年1月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><h4 id="账号与同步"><a href="#账号与同步" class="headerlink" title="账号与同步"></a>账号与同步</h4><p>Android从<code>API Level5</code>就有了自己的同步服务, 但很少有程序使用到, 一来大多数程序不需要所谓的同步,二来很多程序自己实现了后台的同步更新. 随着Android程序开发的逐渐程序, 越来越的的程序使用到了系统提供的服务来完成<code>账号认证</code>与<code>同步更新</code>, 我们可以打开系统设置–&gt;账号进行查看, 就能看到很多应用都这么做了. 这样做有两个好处, 一来系统服务做更新同步(<code>SyncAdapter</code>)唤醒更加绿色环保, 二来实现了账号认证(<code>Authenticator</code>)还可以为其他应用提供第三方认证服务, 如大家常见的使用QQ或者微博账号登录, 由于你手机上安装的QQ与微博实现了该接口, 便可以通过开发者账号获得授权Token来做第三方认证.</p>
<p>本期博客分三部分来讲, 通过一个小应用(Part Three提供源码)来概述所有相关内容, 大体章节如下</p>
<ul>
<li><p>数据模型建立与加载 (ContentProvider LoaderManager)</p>
</li>
<li><p>更新系统建立 (SyncAdapter)</p>
</li>
<li><p>账号系统建立 (Account Authenticator)</p>
</li>
</ul>
<p>下面先来讲讲如何轻松本地数据库并完成数据到界面的加载</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2015/02/04/2015-02-04-android-gou-jian-zhang-hao-yu-tong-bu-fu-wu-part-two/"
                            aria-label=": Android 构建账号与同步服务 Part Two"
                        >
                            <img class="media-image" src="http://res.cloudinary.com/dtn0pkdmg/image/upload/v1506326189/sync2_uyvihr.jpg" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2015/02/04/2015-02-04-android-gou-jian-zhang-hao-yu-tong-bu-fu-wu-part-two/"
                            aria-label=": Android 构建账号与同步服务 Part Two"
                        >
                            <h3 class="media-heading">Android 构建账号与同步服务 Part Two</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月4日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>紧接<a href="http://talentprince.github.io/blog/2015/01/26/android-zhang-hao-yu-tong-bu-xi-tong-part-one/">上一部分</a></p>
<h4 id="更新系统的建立"><a href="#更新系统的建立" class="headerlink" title="更新系统的建立"></a>更新系统的建立</h4><p>更新系统即是所说的<a href="http://developer.android.com/training/sync-adapters/creating-sync-adapter.html" target="_blank" rel="noopener">SyncAdapter</a>, 实现了这个系统服务, 就可以利用系统的定时器对程序数据<code>ContentProvider</code>进行更新, 也可以在系统设置-&gt;账号里面控制开启或者关闭(如果<code>SyncAdapter</code>的配置文件允许的话)</p>
<p>完成这些服务的布置大概有三步</p>
<ul>
<li>创建SyncService并提供SyncAdapter的IBinder接口以便让系统调用</li>
<li>声明Sync服务, 并制定SyncAdapter的配置文件</li>
<li>生成账户启动Sync</li>
</ul></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2015/02/10/2015-02-10-android-gou-jian-zhang-hao-yu-tong-bu-fu-wu-part-three/"
                            aria-label=": Android 构建账号与同步服务 Part Three"
                        >
                            <img class="media-image" src="http://res.cloudinary.com/dtn0pkdmg/image/upload/v1506326189/sync3_trl1qb.jpg" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2015/02/10/2015-02-10-android-gou-jian-zhang-hao-yu-tong-bu-fu-wu-part-three/"
                            aria-label=": Android 构建账号与同步服务 Part Three"
                        >
                            <h3 class="media-heading">Android 构建账号与同步服务 Part Three</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月10日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><h4 id="紧接上期"><a href="#紧接上期" class="headerlink" title="紧接上期"></a>紧接<a href="http://talentprince.github.io/blog/2015/02/04/android-gou-jian-zhang-hao-yu-tong-bu-fu-wu-part-two/">上期</a></h4><h4 id="账号系统建立-Account-Authenticator"><a href="#账号系统建立-Account-Authenticator" class="headerlink" title="账号系统建立 Account Authenticator"></a>账号系统建立 Account Authenticator</h4><p>如果只需要借助系统更新服务(SyncAdapter)来做定期维护, 那么通过前两部分的介绍, 已经可以达到所预期的目标了.</p>
<p>本期话题将会解决</p>
<ul>
<li>添加账号</li>
<li>获得授权</li>
</ul>
<p>这些服务全部都是可以跨进程的操作, 完成了这些操作, 我们就可以完成像<code>QQ</code> <code>新浪微博</code> 一样的功能, 账号系统可以为第三方应用授权.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2016/01/26/2016-01-26-qing-chu-yu-ming-bai/"
                            aria-label=": 清楚与明白"
                        >
                            <img class="media-image" src="http://res.cloudinary.com/dtn0pkdmg/image/upload/v1506326189/understand_fuwgh9.jpg" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://talentprince.github.io/2016/01/26/2016-01-26-qing-chu-yu-ming-bai/"
                            aria-label=": 清楚与明白"
                        >
                            <h3 class="media-heading">清楚与明白</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年1月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>许久未更新, 已渐渐落草, 回顾过去一年, checklist总归是完成为多, pending为少, 但这并不意味着很多事情都得到了清楚的解决, 也有很多事情可能还需要时间去琢磨才能想的明白.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="没有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 44 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/new_cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-aps5gauztkpi1ygcutx4tgx00wcsooq0okdwjt46e3hduxfhmurq7md3aeoa.min.js"></script>
<!--SCRIPTS END-->




    <script src="/assets/js/moment-with-locales.js"></script>
    <script src="/assets/js/algoliasearch.js"></script>
    <script>
      var algoliaClient = algoliasearch('Z7A3XW4R2I', '12db1ad54372045549ef465881c17e743');
      var algoliaIndex = algoliaClient.initIndex('my-hexo-blog');
    </script>


    </body>
</html>
